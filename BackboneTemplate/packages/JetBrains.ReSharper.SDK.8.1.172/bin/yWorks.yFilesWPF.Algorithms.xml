<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>yWorks.yFilesWPF.Algorithms</name>
  </assembly>
  <members>
    <member name="T:yWorks.yFiles.Algorithms.AlgorithmAbortedException">
      <summary>
            Exception that gets thrown by an algorithm when
            the thread executing the algorithm was interrupted.
            </summary>
      <remarks>
            Exception that gets thrown by an algorithm when
            the thread executing the algorithm was interrupted.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.AlgorithmAbortedException.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.AlgorithmAbortedException" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.AlgorithmAbortedException.#ctor(System.String)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.AlgorithmAbortedException" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.AlgorithmAbortedException.Check">
      <summary>
            Throws an AlgorithmInterruptedException if
            the current Thread has been interrupted.
            </summary>
      <remarks>
            Throws an AlgorithmInterruptedException if
            the current Thread has been interrupted.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.AlgorithmAbortedException.Check(System.String)">
      <summary>
            Throws an AlgorithmInterruptedException if
            the current Thread has been interrupted.
            </summary>
      <param name="msg">Exception message if raised</param>
      <remarks>
            Throws an AlgorithmInterruptedException if
            the current Thread has been interrupted.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Bfs">
      <summary>This class provides services that center around breadth first search (BFS)</summary>
      <remarks>This class provides services that center around breadth first search (BFS)</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Bfs" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList)" />
            , but this time the core nodes
            are identified by a boolean predicate.
            </summary>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList)" />
            , but this time the core nodes
            are identified by a boolean predicate.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            </summary>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)" />
            . Additionally
            the provided node map will be filled with integers that
            hold the layer number for each node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList)">
      <summary>Returns layers of nodes constructed by a breadth first search.</summary>
      <remarks>
            Returns layers of nodes constructed by a breadth first search.
            The first of these layers contains all nodes within the given NodeList.
            These nodes are the core nodes from where an
            undirected breath first search to the other nodes starts.
            <p />
            In the i-th layer are previously unassigned nodes that are
            connected to nodes in the (i-1)-th layer.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,System.Boolean,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns layers of nodes constructed by a breadth first search.</summary>
      <remarks>
            Returns layers of nodes constructed by a breadth first search.
            The first of these layers contains all nodes within the given NodeList.
            These nodes are the core nodes from where either a directed or undirected
            breath first search to the other nodes starts.
            <p />
            In the i-th layer are previously unassigned nodes that are
            successors to nodes in the (i-1)-th layer.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,System.Boolean,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Returns layers of nodes constructed by a breadth first search.</summary>
      <param name="graph">the graph the bfs is running on</param>
      <param name="coreNodes">contains the nodes the bfs run starts from</param>
      <param name="directed">true: only outgoing edges are attended, false: all edges</param>
      <param name="layerIDMap">is used to store the layer depths information in</param>
      <param name="maxLayers">number of layers that will be returned. "0" for all layers</param>
      <returns>
            an array of
            <see cref="T:yWorks.yFiles.Algorithms.NodeList" />
            s representing the layers
            </returns>
      <remarks>
            Returns layers of nodes constructed by a breadth first search.
            The first of these layers contains all nodes within the given NodeList.
            These nodes are the core nodes from where either a directed or undirected
            breath first search to the other nodes starts.
            <p />
            In the i-th layer are previously unassigned nodes that are
            successors to nodes in the (i-1)-th layer.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.BfsDirection,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Returns layers of nodes constructed by a breadth first search.</summary>
      <param name="graph">the graph the bfs is running on</param>
      <param name="coreNodes">contains the nodes the bfs run starts from</param>
      <param name="direction">
            specifies which edges to follow. One of
            <ul><li><see cref="F:yWorks.yFiles.Algorithms.BfsDirection.Predecessor" />
            ,</li><li><see cref="F:yWorks.yFiles.Algorithms.BfsDirection.Successor" />
            , or</li><li><see cref="F:yWorks.yFiles.Algorithms.BfsDirection.Both" /></li></ul></param>
      <param name="layerIDMap">is used to store the layer depths information in</param>
      <param name="maxLayers">number of layers that will be returned. "0" for all layers</param>
      <returns>
            an array of
            <see cref="T:yWorks.yFiles.Algorithms.NodeList" />
            s representing the layers
            </returns>
      <remarks>
            Returns layers of nodes constructed by a breadth first search.
            The first of these layers contains all nodes within the given NodeList.
            These nodes are the core nodes from where either a directed or undirected
            breath first search to the other nodes starts.
            <p />
            In the i-th layer are previously unassigned nodes that are
            successors to nodes in the (i-1)-th layer.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList)" />
            .
            </summary>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Bfs.GetLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList)" />
            . Additionally
            the provided node map will be filled with integers that
            hold the layer number for each node.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.BfsDirection" />
    <member name="F:yWorks.yFiles.Algorithms.BfsDirection.Predecessor">
      <summary>Edge direction specifier for incoming edges.</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.BfsDirection.Successor">
      <summary>Edge direction specifier for outgoing edges.</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.BfsDirection.Both">
      <summary>Edge direction specifier for both incoming and outgoing edges.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Bipartitions">
      <summary>Responsible for graph bipartition problems.</summary>
      <remarks>
            Responsible for graph bipartition problems.
            <p />
            A bipartite graph is a graph whose node set can be partitioned
            into two sets in such a way that all edges in the graph
            connect nodes that belong to different  partitions. In other words,
            there are no edges connecting nodes that belong to the same
            partition.
            <p />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bipartitions.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Bipartitions" /> class</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Bipartitions.Blue">
      <summary>Marker for a node that belongs to the blue partition</summary>
      <remarks>Marker for a node that belongs to the blue partition</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bipartitions.GetBipartition(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Calculates a bipartition of the given graph if one exists.</summary>
      <returns>
        <c>isBipartite(graph)</c>
      </returns>
      <remarks>
            Calculates a bipartition of the given graph if one exists.
            <p />
            If the graph is bipartite then for all nodes of the
            given graph either
            <see cref="F:yWorks.yFiles.Algorithms.Bipartitions.Red" />
            or
            <see cref="F:yWorks.yFiles.Algorithms.Bipartitions.Blue" />
            objects will put in the given node map, depending on
            the partition the node belongs to.
            <p />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Bipartitions.IsBipartite(yWorks.yFiles.Algorithms.Graph)">
      <summary>Tests whether or not the given graph is bipartite.</summary>
      <remarks>Tests whether or not the given graph is bipartite.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Bipartitions.Red">
      <summary>Marker for a node that belongs to the red partition</summary>
      <remarks>Marker for a node that belongs to the red partition</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Centrality">
      <summary>This class provides methods to determine various centrality indices of nodes or edges of a graph.</summary>
      <remarks>
            This class provides methods to determine various centrality indices of nodes or edges of a graph.
            Centrality indices serve to quantify an intuitive feeling that in most networks some nodes
            or edges are "more central" than others. The provided methods assign a value of type double to each node or edge of
            a graph that represents its centrality. The higher an assigned value the more central the element
            is considered by the algorithm.
            <p />
            Also, this class provides convenience methods that normalize the returned centrality values to lie within
            the interval <tt>[0..1]</tt>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Centrality" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.ClosenessCentrality(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes the closeness centrality for the nodes of a graph.</summary>
      <param name="graph">the input graph.</param>
      <param name="closeness">return value. A map which hold the centrality value of type <c>double</c> for every node.</param>
      <param name="directed">whether to consider the edges of the graph as directed or undirected.</param>
      <param name="edgeCosts">
            when <see langword="null" /> the edges of the graph are considered to have equal cost. Otherwise
            it must provide a non-negative <c>double</c> value (its cost) for every edge.
            </param>
      <remarks>
            Computes the closeness centrality for the nodes of a graph. Closeness centrality is defined as the reciprocal
            of the sum of
            shortest path distances of a node to all other nodes in the graph. Therefore a node with high closeness
            centrality has short distances to all other nodes of a graph. Also note, that for unconnected graphs
            the centrality values of all nodes will be zero, since the distance to some nodes is infinite.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.DegreeCentrality(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,System.Boolean)">
      <summary>Computes the degree centrality for the nodes of a graph.</summary>
      <param name="graph">the input graph.</param>
      <param name="centrality">return value. A map which provides the degree centrality as <c>double</c> value for every node.</param>
      <param name="considerInEdges" />
      <param name="considerOutEdges" />
      <remarks>
            Computes the degree centrality for the nodes of a graph. Degree centrality measures in-, out- or overall degree of
            a node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.EdgeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes betweenness centrality for each edge of a given graph.</summary>
      <param name="centrality">return value. A EdgeMap which will hold a non-negative centrality value of type <c>double</c> for each edge.</param>
      <remarks>
            Computes betweenness centrality for each edge of a given graph.
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Centrality.NodeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)" />
            but applied to edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.GraphCentrality(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes the graph centrality for the nodes of a graph.</summary>
      <param name="graph">the input graph.</param>
      <param name="centrality">return value. A map which hold the centrality value of type <c>double</c> for every node.</param>
      <param name="directed">whether to consider the edges of the graph as directed or undirected.</param>
      <param name="edgeCosts">
            when <see langword="null" /> the edges of the graph are considered to have equal cost. Otherwise
            it must provide a non-negative <c>double</c> value (its cost) for every edge.
            </param>
      <remarks>
            Computes the graph centrality for the nodes of a graph. Graph centrality is defined as the reciprocal
            of the maximum of all shortest path distances from a node to all other nodes in the graph.
            Nodes with high graph centrality have short distances to all other nodes in the graph.
            Also note, that for unconnected graphs the centrality values of all nodes will be zero, since the
            distance to some nodes is infinite.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.NodeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes betweenness centrality for each node of a given graph.</summary>
      <param name="graph">the input graph.</param>
      <param name="centrality">return value. A NodeMap which will holds a non-negative centrality value of type <c>double</c> for each node.</param>
      <param name="directed">
            whether to consider the edges of the graph as directed or undirected.
            If false, the algorithm traverse every edge in both direction regardless of the direction of the edge.
            </param>
      <param name="edgeCosts">
            if <see langword="null" /> the edges of the graph are considered to have equal cost. Otherwise
            it must provide a strictly positive <c>double</c> value (its cost) for every edge. Invalid values are assumed
            to be <c>1.0</c>.
            </param>
      <remarks>
            Computes betweenness centrality for each node of a given graph.
            Betweenness Centrality is a measure for how often a node lies on a shortest path between
            each pair of nodes in the graph. Removing a central node will cause many shortest paths to change.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.NodeEdgeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes betweenness centrality for each node and edge of a given graph.</summary>
      <param name="nodeCentrality">return value. A NodeMap which will hold the centrality value of type <c>double</c> for every node.</param>
      <param name="edgeCentrality">return value. A EdgeMap which will hold the centrality value of type <c>double</c> for every edge.</param>
      <remarks>
            Computes betweenness centrality for each node and edge of a given graph.
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Centrality.NodeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)" />
            but applied to both nodes and edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.Normalize(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Centrality.Normalize(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)" />
            , but for EdgeMap.
            </summary>
      <param name="graph">the input graph</param>
      <param name="map">return value that holds <c>double</c> values between zero and one.</param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Centrality.Normalize(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)" />
            , but for EdgeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.Normalize(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>This method normalizes the <c>double</c> values of a node map by dividing all values by the maximum of all values (maximum norm).</summary>
      <param name="graph">the input graph</param>
      <param name="map">return value that holds <c>double</c> values between zero and one.</param>
      <remarks>
            This method normalizes the <c>double</c> values of a node map by dividing all values by the maximum of all values (maximum norm).
            Note, if the maximum value is <c>Double.POSITIVE_INFINITY</c>, all values other than <c>Double.POSITIVE_INFINITY</c>
            are set to <c>0</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Centrality.WeightCentrality(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Computes the weight centrality for the nodes of a graph.</summary>
      <param name="graph">The input graph.</param>
      <param name="centrality">
            Return value.
            A map which provides the value centrality as <c>double</c> value for
            every node.
            </param>
      <param name="considerInEdges">Whether the weights associated with incoming edges should be considered.</param>
      <param name="considerOutEdges">Whether the weights associated with outgoing edges should be considered.</param>
      <param name="edgeWeights">
            When <see langword="null" /> the edges of the graph are considered to have uniform
            weight of 1.0.
            Otherwise it must provide a non-negative <c>double</c> value (the weight)
            for every edge.
            </param>
      <remarks>
            Computes the weight centrality for the nodes of a graph.
            Weight centrality measures the weight associated with incoming, outgoing, or
            all edges of a node.
            <p />
            Note that weight centrality degenerates to degree centrality when the edges
            have uniform weight.
            In particular, when parameter 'edgeWeights' is <see langword="null" /> then
            <see cref="M:yWorks.yFiles.Algorithms.Centrality.DegreeCentrality(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,System.Boolean)">degreeCentrality</see>
            is invoked instead.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Cycles">
      <summary>Responsible for finding cycles within a graph that have certain properties.</summary>
      <remarks>Responsible for finding cycles within a graph that have certain properties.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Cycles" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.FindAllCycleEdges(yWorks.yFiles.Algorithms.Graph,System.Boolean)">
      <summary>
            Returns all edges that are part of at least one directed or undirected
            simple cycle.
            </summary>
      <param name="graph">the input graph</param>
      <param name="directed">whether or not to look for edges on directed cycles</param>
      <returns>all edges that belong to a cycle</returns>
      <remarks>
            Returns all edges that are part of at least one directed or undirected
            simple cycle. A simple cycle is a closed edge path without repeating edges.
            Moreover, selfloops are always considered to be cycle edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.FindCycle(yWorks.yFiles.Algorithms.Graph,System.Boolean)">
      <summary>
            Returns an edge list that contains the edges of a cycle
            found in the given graph.
            </summary>
      <remarks>
            Returns an edge list that contains the edges of a cycle
            found in the given graph. The edges are returned in the
            order they appear in the found cycle.
            <p />
            If the returned cycle is empty then no cycle has been
            found in the given graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            This method marks edges of a given graph whose removal or reversal would make
            that graph acyclic.
            </summary>
      <param name="graph">the input graph</param>
      <param name="cycleEdges">
            return value. cycleEdge.getBool(e) == true  iff
            e is a detected cycle edge.
            </param>
      <remarks>
            This method marks edges of a given graph whose removal or reversal would make
            that graph acyclic. This method tries to minimize the number of marked edges
            for that task heuristically, since it is a well known hard problem to come up
            with an optimal solution.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            This method is similar to
            <see cref="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)" />
            , but instead of minimizing the
            number of marked edges it tries to find a set of marked edges, for which the associated
            cost is minimal.
            </summary>
      <param name="costDP">
            data provider that yields the reversal cost for each edge. The reversal cost
            for each edge must be a non-negative value of type <c>double</c>.
            </param>
      <remarks>
            This method is similar to
            <see cref="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)" />
            , but instead of minimizing the
            number of marked edges it tries to find a set of marked edges, for which the associated
            cost is minimal. In case each edge has cost <c>1.0</c> the result will be
            the same as the one returned by
            <see cref="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdgesDFS(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)" />
            this method marks
            edges of a given graph whose removal or reversal would make
            that graph acyclic.
            </summary>
      <param name="graph">the input graph</param>
      <param name="cycleEdges">
            return value. cycleEdge.getBool(e) == true  iff
            e is a detected cycle edge.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)" />
            this method marks
            edges of a given graph whose removal or reversal would make
            that graph acyclic. The implementation of this method is
            based on a Depth First Search. The number of marked cycle edges
            is expected to be slightly larger than when using
            <see cref="M:yWorks.yFiles.Algorithms.Cycles.FindCycleEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)" />
            . The advantage of this method
            is that the result set is more stable when edges get added or removed
            over the time.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Dfs">
      <summary>Framework class for depth first search (DFS) based algorithms.</summary>
      <remarks>
            Framework class for depth first search (DFS) based algorithms.
            To write graph algorithms that are based on a depth first search
            one can extend this class and overwrite appropriate callback
            methods provided by this class.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.#ctor">
      <summary>Instantiates a new Dfs object.</summary>
      <remarks>Instantiates a new Dfs object.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Dfs.Black">
      <summary>Node state specifier.</summary>
      <remarks>
            Node state specifier. Indicates that the node has been completed,
            i.e. it has been visited before and is not part of an active
            path in the dfs tree anymore.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Dfs.DirectedMode">
      <summary>
            Specifies whether or not to interpret the edges of the graph
            as directed.
            </summary>
      <remarks>
            Specifies whether or not to interpret the edges of the graph
            as directed.
            <p />
            By default directed mode is disabled.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Dfs.Gray">
      <summary>Node state specifier.</summary>
      <remarks>
            Node state specifier. Indicates that a node was already visited but
            has not been completed yet, i.e. it is still part of an active
            path of the dfs tree.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.LookFurther(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Callback method that will be invoked whenever dfs continues
            its search at a new root node.
            </summary>
      <remarks>
            Callback method that will be invoked whenever dfs continues
            its search at a new root node.
            By default this method does nothing
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Dfs.LookFurtherMode">
      <summary>
            Specifies whether or not to continue the depth first search
            after all nodes reachable from the first node were
            visited.
            </summary>
      <remarks>
            Specifies whether or not to continue the depth first search
            after all nodes reachable from the first node were
            visited.
            <p />
            By default look further mode is active.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.PostTraverse(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Callback method that will be invoked after the search returns
            from the given node.
            </summary>
      <remarks>
            Callback method that will be invoked after the search returns
            from the given node. The node has been reached via the given edge.
            By default this method does nothing.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.PostVisit(yWorks.yFiles.Algorithms.Node,System.Int32,System.Int32)">
      <summary>
            Callback method that will be invoked whenever a node visit has
            been completed.
            </summary>
      <remarks>
            Callback method that will be invoked whenever a node visit has
            been completed. The dfs number and the completion number
            of the given node will be passed in.
            By default this method does nothing
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.PreTraverse(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Callback method that will be invoked if the given edge
            will be looked at in the search the first (and only) time.
            </summary>
      <remarks>
            Callback method that will be invoked if the given edge
            will be looked at in the search the first (and only) time.
            <p />
            The given node is the node that will be visited next iff
            <c>treeEdge == true</c>.
            By default this method does nothing
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.PreVisit(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>
            Callback method that will be invoked whenever a formerly unvisited node
            gets visited the first time.
            </summary>
      <remarks>
            Callback method that will be invoked whenever a formerly unvisited node
            gets visited the first time. The given int is the dfs number of that
            node.
            <p />
            By default this method does nothing
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.Start(yWorks.yFiles.Algorithms.Graph)">
      <summary>Starts a depth first search on the given graph.</summary>
      <remarks>
            Starts a depth first search on the given graph.
            The first node in the graph will be visited first.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Dfs.Start(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>Starts a depth first search on the given graph.</summary>
      <remarks>
            Starts a depth first search on the given graph.
            The given node will be visited first.
            If <c>start</c> is null, this method returns silently.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Dfs.stateMap">
      <summary>
            NodeMap that indicates the state of the nodes as they
            are visited by this algorithm.
            </summary>
      <remarks>
            NodeMap that indicates the state of the nodes as they
            are visited by this algorithm.
            Possible states of a node are
            <see cref="F:yWorks.yFiles.Algorithms.Dfs.White">WHITE</see>
            ,
            <see cref="F:yWorks.yFiles.Algorithms.Dfs.Gray">GRAY</see>
            and
            <see cref="F:yWorks.yFiles.Algorithms.Dfs.Black">BLACK</see>
            .
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Dfs.White">
      <summary>Node state specifier.</summary>
      <remarks>Node state specifier. Indicates that a node was not yet visited.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Edge">
      <summary>
            Represents an edge, i.e., a directed connection between two nodes (represented
            by instances of class
            <see cref="T:yWorks.yFiles.Algorithms.Node" />
            ) in the directed graph data type
            <see cref="T:yWorks.yFiles.Algorithms.Graph" />
            .
            </summary>
      <remarks>
            Represents an edge, i.e., a directed connection between two nodes (represented
            by instances of class
            <see cref="T:yWorks.yFiles.Algorithms.Node" />
            ) in the directed graph data type
            <see cref="T:yWorks.yFiles.Algorithms.Graph" />
            .
            <br />
            The <i>directed</i> stems from the fact that an edge has a distinct source node
            and a distinct target node.
            Using pair notation, an edge would be written as
            (<i>&lt;source node&gt;</i>, <i>&lt;target node&gt;</i>).
            <p />
            Most notably, an edge provides access to its source node (
            <see cref="P:yWorks.yFiles.Algorithms.Edge.Source" />
            )
            and its target node (
            <see cref="P:yWorks.yFiles.Algorithms.Edge.Target" />
            ).
            Note that an edge can have the same node as its source and target.
            Such an edge is then called "self-loop" and method
            <see cref="P:yWorks.yFiles.Algorithms.Edge.SelfLoop" />
            yields
            <see langword="true" />.
            <p />
            <b>Important:</b>
            Class Graph is the single authority for any structural changes to the graph data
            type.
            Specifically, this means that there is no way to create or delete a node or an
            edge without using an actual Graph instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Edge.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.GraphElementInsertion,yWorks.yFiles.Algorithms.GraphElementInsertion)">
      <summary>Creates a new edge that belongs to the given graph.</summary>
      <param name="v">
            
            The source node of the edge.
            </param>
      <param name="e1">
            
            An edge with source node <c>v</c>.
            </param>
      <param name="w">
            
            The target node of the edge.
            </param>
      <param name="e2">
            
            An edge with target node <c>w</c>.
            </param>
      <param name="d1">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before" />
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After" />
            .
            </param>
      <param name="d2">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before" />
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After" />
            .
            </param>
      <remarks>
            Creates a new edge that belongs to the given graph.
            The new edge <c>e</c> has source node <c>v</c> and target node
            <c>w</c>.
            <br />
            <br />
            Edge <c>e</c> is inserted in such a way that an iteration over the edges
            at node <c>v</c> returns <c>e</c>
            <ul>
            <li>
            after <c>e1</c>, if <c>d1 == AFTER</c>
            </li>
            <li>
            before <c>e1</c>, if <c>d1 == BEFORE</c>,
            </li>
            </ul>
            and an iteration over the edges at <c>w</c> returns <c>e</c>
            <ul>
            <li>
            after <c>e2</c>, if <c>d2 == AFTER</c>
            </li>
            <li>
            before <c>e2</c>, if <c>d2 == BEFORE</c>.
            </li>
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Edge.CreateCopy(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a copy of this edge that will be inserted into the given graph connecting
            the given source and target nodes.
            </summary>
      <param name="g">
            
            The graph the created edge will belong to.
            </param>
      <param name="v">
            
            The source node of the created edge.
            </param>
      <param name="w">
            
            The target node of the created edge.
            </param>
      <returns>
            
            The newly created Edge object.
            </returns>
      <remarks>
            Creates a copy of this edge that will be inserted into the given graph connecting
            the given source and target nodes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.Graph">
      <summary>The graph this edge belongs to.</summary>
      <remarks>
            Returns the graph this edge belongs to.
            If the edge does not belong to a graph, because it was removed or hidden from
            it, this method returns <see langword="null" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.Index">
      <summary>The index of this edge within its graph G.</summary>
      <remarks>
            Returns the index of this edge within its graph G.
            Edge indices represent the ordering of standard edge iteration on G.
            The value of an index is <c> &gt;= 0</c> and <c> &lt; G.edgeCount()</c>.
            <p />
            Note that indices are subject to change whenever the sequence of edges in a
            graph is modified by either removing, hiding, reinserting, or unhiding an edge,
            or by explicitly changing its position in the sequence.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.NextInEdge">
      <summary>
            The successor of this edge in the list of incoming edges at its target
            node.
            </summary>
      <remarks>
            Returns the successor of this edge in the list of incoming edges at its target
            node.
            If this edge is the last incoming edge at its target node, then <see langword="null" />
            is returned.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.NextOutEdge">
      <summary>
            The successor of this edge in the list of outgoing edges at its source
            node.
            </summary>
      <remarks>
            Returns the successor of this edge in the list of outgoing edges at its source
            node.
            If this edge is the last outgoing edge at its source node, then <see langword="null" />
            is returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Edge.OnReinsert">
      <summary>
            Callback method that is invoked from a graph just before this edge will be
            reinserted into that graph.
            </summary>
      <remarks>
            Callback method that is invoked from a graph just before this edge will be
            reinserted into that graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Edge.Opposite(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the node at the opposite edge end with respect to the given node.</summary>
      <remarks>
            Returns the node at the opposite edge end with respect to the given node.
            <p />
            Note that self-loops have the same node at both edge ends.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.PrevInEdge">
      <summary>
            The predecessor of this edge in the list of incoming edges at its target
            node.
            </summary>
      <remarks>
            Returns the predecessor of this edge in the list of incoming edges at its target
            node.
            If this edge is the first incoming edge at its target node, then <see langword="null" />
            is returned.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.PrevOutEdge">
      <summary>
            The predecessor of this edge in the list of outgoing edges at its source
            node.
            </summary>
      <remarks>
            Returns the predecessor of this edge in the list of outgoing edges at its source
            node.
            If this edge is the first outgoing edge at its source node, then <see langword="null" />
            is returned.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.SelfLoop">
      <summary>
        <see langword="true" /> if and only if this edge is a self-loop.</summary>
      <remarks>
            Returns <see langword="true" /> if and only if this edge is a self-loop.
            An edge is called a self-loop, if it is adjacent to only one node, i.e.,
            source node and target node are the same.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.Source">
      <summary>The source node connected to this edge.</summary>
      <remarks>Returns the source node connected to this edge.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Edge.Target">
      <summary>The target node connected to this edge.</summary>
      <remarks>Returns the target node connected to this edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Edge.ToString">
      <summary>Returns a String representation of this edge.</summary>
      <remarks>Returns a String representation of this edge.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.EdgeList">
      <summary>
            Specialized list implementation for instances of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            .
            </summary>
      <remarks>
            Specialized list implementation for instances of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor">
      <summary>Creates an empty edge list.</summary>
      <remarks>Creates an empty edge list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates a list that is initialized with a single edge provided.</summary>
      <remarks>Creates a list that is initialized with a single edge provided.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Creates a list that is initialized with the edges provided by the given array
            of edges.
            </summary>
      <remarks>
            Creates a list that is initialized with the edges provided by the given array
            of edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Creates a list that is initialized with an EdgeList.</summary>
      <remarks>Creates a list that is initialized with an EdgeList.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>
            Creates a list that is initialized with the edges provided by the given EdgeCursor
            object.
            </summary>
      <remarks>
            Creates a list that is initialized with the edges provided by the given EdgeCursor
            object.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Algorithms.IEdgeCursor,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Creates a list that is initialized with those edges from the given EdgeCursor
            object for which the given data provider returns <see langword="true" /> upon
            calling its
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method.
            </summary>
      <param name="ec">
            
            An edge cursor providing edges that should be added to this list.
            </param>
      <param name="predicate">
            
            A data provider that acts as a inclusion predicate for each edge accessible
            by the given edge cursor.
            </param>
      <remarks>
            Creates a list that is initialized with those edges from the given EdgeCursor
            object for which the given data provider returns <see langword="true" /> upon
            calling its
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.#ctor(yWorks.yFiles.Util.IIterator)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            Iterator object.
            </summary>
      <remarks>
            Creates a list that is initialized with the elements provided by the given
            Iterator object.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.Edges">
      <summary>Returns an edge cursor for this edge list.</summary>
      <returns>
            
            An edge cursor granting access to the edges within this list.
            </returns>
      <remarks>Returns an edge cursor for this edge list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.FirstEdge">
      <summary>
            Returns the first edge in this list, or <see langword="null" /> when the list is
            empty.
            </summary>
      <returns>
            
            The first edge in the list.
            </returns>
      <remarks>
            Returns the first edge in this list, or <see langword="null" /> when the list is
            empty.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.GetEnumerator" />
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.LastEdge">
      <summary>Returns the last edge in this list, or <see langword="null" /> when the list is empty.</summary>
      <returns>
            
            The last edge in the list.
            </returns>
      <remarks>Returns the last edge in this list, or <see langword="null" /> when the list is empty.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.PopEdge">
      <summary>Removes the first edge from this list and returns it.</summary>
      <returns>
            
            The first edge from the list.
            </returns>
      <remarks>Removes the first edge from this list and returns it.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.EdgeList.ToEdgeArray">
      <summary>
            Returns an edge array containing all elements of this list in the canonical
            order.
            </summary>
      <remarks>
            Returns an edge array containing all elements of this list in the canonical
            order.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Graph">
      <summary>This class implements a directed graph structure.</summary>
      <remarks>
            This class implements a directed graph structure.
            Basically, a directed graph consists of a set of objects called "nodes" (represented
            by instances of class
            <see cref="T:yWorks.yFiles.Algorithms.Node" />
            ) and a set of node pairs which are called
            "edges" (represented by instances of class
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            ).
            <br />
            The <i>directed</i> stems from the fact that all edges in the graph have direction,
            i.e., they have a distinct source node and a distinct target node.
            Using the aforementioned pair notation, an edge would be written as
            (<i>&lt;source node&gt;</i>, <i>&lt;target node&gt;</i>).
            <p />
            Class Graph presents a proper data type that provides support for all essential
            operations like element creation, removal, access, and iteration.
            <br />
            <b>Important:</b>
            Class Graph is the single authority for any structural changes to the graph data
            type.
            Specifically, this means that there is no way to create or delete a node or an
            edge without using an actual Graph instance.
            <p />
            Furthermore, this class is also responsible for providing access to its elements.
            This is done by means of bidirectional cursors that present a read-only view
            on the node set (interface
            <see cref="T:yWorks.yFiles.Algorithms.INodeCursor" />
            ) and edge set (interface
            <see cref="T:yWorks.yFiles.Algorithms.IEdgeCursor" />
            ).
            <p />
            Class Graph fires notification events that signal structural changes, like, e.g.,
            creation, removal, reinsertion, or modification of graph elements.
            <br />
            Classes that implement the
            <see cref="T:yWorks.yFiles.Algorithms.IGraphListener" />
            interface can be registered
            with this class using the
            <see cref="M:yWorks.yFiles.Algorithms.Graph.AddGraphListener(yWorks.yFiles.Algorithms.IGraphListener)">addGraphListener</see>
            
            method in order to receive such events.
            <p />
            This class provides direct support for the notion of data accessors.
            It allows to register so-called data providers (implementations of interface
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            ) that hold arbitrary data which is associated to its nodes
            and/or edges.
            <br />
            Also, it serves as a factory to create so-called maps (
            <see cref="T:yWorks.yFiles.Algorithms.INodeMap" />
            ,
            <see cref="T:yWorks.yFiles.Algorithms.IEdgeMap" />
            ) that can be utilized to bind arbitrary data to nodes and edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.#ctor">
      <summary>Instantiates an empty Graph object.</summary>
      <remarks>Instantiates an empty Graph object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Instantiates a new Graph object as a copy of the given graph.</summary>
      <param name="argGraph">
            
            The graph to be copied.
            </param>
      <remarks>
            Instantiates a new Graph object as a copy of the given graph.
            Values bound to the argument graph via node and edge keys are available in
            the new Graph instance with the keys registered with <c>argGraph</c>.
            Only references to these values are copied.
            <p />
            The new Graph instance also inherits all graph listeners registered with the
            given graph.
            <p />
            This constructor does not use a
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.ICursor)">
      <summary>Instantiates a new Graph object as a partial copy of the given graph.</summary>
      <param name="graph">
            
            The graph to be (partially) copied.
            </param>
      <param name="subNodes">
            
            A cursor to iterate over the nodes that actually induce the subgraph to be
            copied.
            </param>
      <remarks>
            Instantiates a new Graph object as a partial copy of the given graph.
            Only the subgraph induced by the given cursor will be copied to the new Graph
            instance.
            Values bound to the argument graph via node and edge keys are available in
            the new Graph instance with the keys registered with <c>graph</c>.
            Only references to these values are copied.
            <p />
            The new Graph instance also inherits all graph listeners registered with the
            given graph.
            <p />
            This constructor does not use a
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.AddDataProvider(System.Object,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Registers the given data provider using the given look-up key.</summary>
      <remarks>
            Registers the given data provider using the given look-up key.
            If there is already a data provider registered with that key, then it will
            be overwritten with the new one.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.AddGraphListener(yWorks.yFiles.Algorithms.IGraphListener)">
      <summary>Registers the given graph listener with this graph.</summary>
      <remarks>
            Registers the given graph listener with this graph.
            The listener will receive graph events that signal structural changes occurring
            within this graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ChangeEdge(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.GraphElementInsertion,yWorks.yFiles.Algorithms.GraphElementInsertion)">
      <summary>
            Redefines an edge's end points and fires corresponding notification events
            to inform registered listeners.
            </summary>
      <param name="e">
            
            The edge to be changed.
            </param>
      <param name="e1">
            
            Reference edge for insertion at a new source node.
            </param>
      <param name="e2">
            
            Reference edge for insertion at a new target node.
            </param>
      <param name="d1">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before" />
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After" />
            .
            </param>
      <param name="d2">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before" />
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After" />
            .
            </param>
      <remarks>
            Redefines an edge's end points and fires corresponding notification events
            to inform registered listeners.
            Edge <c>e</c> has
            source node <c>v := e1.source()</c>
            and
            target node <c>w := e2.target()</c>.
            <br />
            <br />
            Edge <c>e</c> is inserted in such a way that an iteration over the edges
            at <c>v</c> returns <c>e</c>
            <ul>
            <li>
            after <c>e1</c>, if <c>d1 == AFTER</c>
            </li>
            <li>
            before <c>e1</c>, if <c>d1 == BEFORE</c>,
            </li>
            </ul>
            and an iteration over the edges at <c>w</c> returns <c>e</c>
            <ul>
            <li>
            after <c>e2</c>, if <c>d2 == AFTER</c>
            </li>
            <li>
            before <c>e2</c>, if <c>d2 == BEFORE</c>.
            </li>
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ChangeEdge(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.GraphElementInsertion,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.GraphElementInsertion)">
      <summary>
            Redefines an edge's end points and fires corresponding notification events
            to inform registered listeners.
            </summary>
      <param name="e">
            
            The edge to be changed.
            </param>
      <param name="newSource">
            
            The new source node.
            </param>
      <param name="sourceReference">
            
            Reference edge for insertion at the new source node.
            </param>
      <param name="sourceD">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before" />
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After" />
            .
            </param>
      <param name="newTarget">
            
            The new target node.
            </param>
      <param name="targetReference">
            
            Reference edge for insertion at the new target node.
            </param>
      <param name="targetD">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before" />
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After" />
            .
            </param>
      <remarks>
            Redefines an edge's end points and fires corresponding notification events
            to inform registered listeners.
            Edge <c>e</c> has
            source node <c>v := sourceReference.source()</c> or <c>v := newSource</c>,
            if <c>sourceReference == null</c>
            and
            target node <c>w := targetReference.target()</c> or <c>w := newTarget</c>,
            if <c>targetReference == null</c>.
            <br />
            <br />
            Edge <c>e</c> is inserted in such a way that an iteration over the edges
            at <c>v</c> returns <c>e</c>
            <ul>
            <li>
            after <c>sourceReference</c>, if <c>sourceD == AFTER</c>
            </li>
            <li>
            before <c>sourceReference</c>, if <c>sourceD == BEFORE</c>,
            </li>
            </ul>
            and an iteration over the edges at <c>w</c> returns <c>e</c>
            <ul>
            <li>
            after <c>targetReference</c>, if <c>targetD == AFTER</c>
            </li>
            <li>
            before <c>targetReference</c>, if <c>targetD == BEFORE</c>.
            </li>
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ChangeEdge(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Redefines an edge's end points and fires corresponding notification events
            to inform registered listeners.
            </summary>
      <param name="e">
            
            The edge to be changed.
            </param>
      <param name="newSource">
            
            The new source node of the given edge.
            </param>
      <param name="newTarget">
            
            The new target node of the given edge.
            </param>
      <remarks>
            Redefines an edge's end points and fires corresponding notification events
            to inform registered listeners.
            <p />
            The edge is appended to the lists of incoming and outgoing edges at the given
            source node and target node, respectively.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Clear">
      <summary>
            Removes all nodes and edges from this graph and fires corresponding notification
            events to inform registered listeners.
            </summary>
      <remarks>
            Removes all nodes and edges from this graph and fires corresponding notification
            events to inform registered listeners.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Contains(yWorks.yFiles.Algorithms.Edge)">
      <summary>Whether or not this graph contains the given edge.</summary>
      <remarks>Whether or not this graph contains the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Whether or not this graph contains the given node.</summary>
      <remarks>Whether or not this graph contains the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ContainsEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not this graph contains an edge that connects the given
            nodes.
            </summary>
      <param name="source">
            
            The source node.
            </param>
      <param name="target">
            
            The target node.
            </param>
      <remarks>
            Returns whether or not this graph contains an edge that connects the given
            nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateCopy">
      <summary>Creates a copy of this graph.</summary>
      <returns>The newly created Graph object.</returns>
      <remarks>
            Creates a copy of this graph.
            Invokes
            <see cref="M:yWorks.yFiles.Algorithms.Graph.#ctor(yWorks.yFiles.Algorithms.Graph)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.GraphElementInsertion,yWorks.yFiles.Algorithms.GraphElementInsertion)">
      <summary>
            Creates a new edge in this graph and fires a corresponding notification event
            to inform registered listeners.
            </summary>
      <param name="v">
            
            The source node of the edge.
            </param>
      <param name="e1">
            
            An edge with source node <c>v</c>.
            </param>
      <param name="w">
            
            The target node of the edge.
            </param>
      <param name="e2">
            
            An edge with target node <c>w</c>.
            </param>
      <param name="d1">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before" />
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After" />
            .
            </param>
      <param name="d2">
            
            One of the object insertion specifiers
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before" />
            or
            <see cref="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After" />
            .
            </param>
      <returns>The newly created Edge object.</returns>
      <remarks>
            Creates a new edge in this graph and fires a corresponding notification event
            to inform registered listeners.
            The new edge <c>e</c> has source node <c>v</c> and target node
            <c>w</c>, i.e., would be written as edge <c>e = (v, w)</c>.
            <br />
            <br />
            Edge <c>e</c> is inserted in such a way that an iteration over the edges
            at node <c>v</c> returns <c>e</c>
            <ul>
            <li>
            after <c>e1</c>, if <c>d1 == AFTER</c>
            </li>
            <li>
            before <c>e1</c>, if <c>d1 == BEFORE</c>,
            </li>
            </ul>
            and an iteration over the edges at <c>w</c> returns <c>e</c>
            <ul>
            <li>
            after <c>e2</c>, if <c>d2 == AFTER</c>
            </li>
            <li>
            before <c>e2</c>, if <c>d2 == BEFORE</c>.
            </li>
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a new edge in this graph and fires a corresponding notification event
            to inform registered listeners.
            </summary>
      <param name="v">
            
            The source node of the edge.
            </param>
      <param name="w">
            
            The target node of the edge.
            </param>
      <returns>
            
            The newly created Edge object.
            </returns>
      <remarks>
            Creates a new edge in this graph and fires a corresponding notification event
            to inform registered listeners.
            The new edge has source node <c>v</c> and target node <c>w</c>,
            i.e., would be written as edge <c>e = (v, w)</c>.
            <p />
            The edge is appended to the lists of incoming and outgoing edges at the source
            node and target node, respectively.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateEdgeMap">
      <summary>Returns a newly created edge map that is valid for the edges in this graph.</summary>
      <remarks>
            Returns a newly created edge map that is valid for the edges in this graph.
            The implementation returned by this method can be used for any edge that is
            part of this Graph instance at any point of time, i.e., it is safe to modify
            the graph structure (add and remove nodes and edges) freely.
            <p />
            The implementation returned uses <c>O(m)</c> memory at all times and
            provides true <c>O(1)</c> read and write access for each edge.
            <p />
            In order to release the resources held by this map,
            <see cref="M:yWorks.yFiles.Algorithms.Graph.DisposeEdgeMap(yWorks.yFiles.Algorithms.IEdgeMap)" />
            
            has to be called.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateGraph">
      <summary>Creates an empty base object of the same type as this graph.</summary>
      <remarks>
            Creates an empty base object of the same type as this graph.
            <p />
            Subclasses should override this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateGraphCopyFactory">
      <summary>
            Factory method that is called by
            <see cref="P:yWorks.yFiles.Algorithms.Graph.GraphCopyFactory" />
            to create a (possibly shared) instance.
            </summary>
      <returns>the (possibly shared) instance.</returns>
      <remarks>
            Factory method that is called by
            <see cref="P:yWorks.yFiles.Algorithms.Graph.GraphCopyFactory" />
            to create a (possibly shared) instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateNode">
      <summary>
            Creates a new node in this graph and fires a corresponding notification event
            to inform registered listeners.
            </summary>
      <returns>
            
            The newly created Node object.
            </returns>
      <remarks>
            Creates a new node in this graph and fires a corresponding notification event
            to inform registered listeners.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.CreateNodeMap">
      <summary>Returns a newly created node map that is valid for the nodes in this graph.</summary>
      <remarks>
            Returns a newly created node map that is valid for the nodes in this graph.
            The implementation returned by this method can be used for any node that is
            part of this Graph instance at any point of time, i.e., it is safe to modify
            the graph structure (add and remove nodes and edges) freely.
            <p />
            The implementation returned uses <c>O(n)</c> memory at all times and
            provides true <c>O(1)</c> read and write access for each node.
            <p />
            In order to release the resources held by this map,
            <see cref="M:yWorks.yFiles.Algorithms.Graph.DisposeNodeMap(yWorks.yFiles.Algorithms.INodeMap)" />
            
            has to be called.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.DataProviderKeys">
      <summary>
            An array of all data provider look-up keys that are registered with
            this graph.
            </summary>
      <remarks>
            Returns an array of all data provider look-up keys that are registered with
            this graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.DisposeEdgeMap(yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Informs the graph that the given edge map is no longer needed.</summary>
      <remarks>
            Informs the graph that the given edge map is no longer needed.
            This method is used for EdgeMap implementations that have been obtained using
            the
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateEdgeMap" />
            factory method.
            <p />
            Calling this method will destroy the edge map and associated resources can
            be freed.
            It is strongly recommended to dispose of all edge maps that are not needed
            anymore using this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.DisposeNodeMap(yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Informs the graph that the given node map is no longer needed.</summary>
      <remarks>
            Informs the graph that the given node map is no longer needed.
            This method is used for NodeMap implementations that have been obtained using
            the
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateNodeMap" />
            factory method.
            <p />
            Calling this method will destroy the node map and associated resources can
            be freed.
            It is strongly recommended to dispose of all node maps that are not needed
            anymore using this method.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.E">
      <summary>The number of edges in this graph.</summary>
      <remarks>
            Returns the number of edges in this graph.
            Same as
            <see cref="P:yWorks.yFiles.Algorithms.Graph.EdgeCount" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.EdgeCount">
      <summary>The number of edges in this graph.</summary>
      <remarks>Returns the number of edges in this graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.EdgeObjects">
      <summary>Returns an iterator that provides access to all edges residing in this graph.</summary>
      <remarks>Returns an iterator that provides access to all edges residing in this graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.Edges">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" />
            for <see cref="T:yWorks.yFiles.Algorithms.Edge" />s that can be used to iterate over the edges that are contained in this instance.
            </summary>
      <remarks>
            This is a live enumerable and will thus reflect the current state of the graph.
            Note that changes to the graph structure during the traversal should be carried out with great care.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.Empty">
      <summary>
        <see langword="true" /> if this graph contains no nodes.</summary>
      <remarks>Returns <see langword="true" /> if this graph contains no nodes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FireGraphEvent(yWorks.yFiles.Algorithms.GraphEvent)">
      <summary>Propagates the given graph event to all registered graph listeners.</summary>
      <remarks>Propagates the given graph event to all registered graph listeners.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FirePostEvent">
      <summary>Propagates a so-called POST event to all registered graph listeners.</summary>
      <remarks>
            Propagates a so-called POST event to all registered graph listeners.
            This method should only be used if a corresponding call to
            <see cref="M:yWorks.yFiles.Algorithms.Graph.FirePreEvent" />
            
            was made.
            <p />
            Generally, PRE and POST events serve as a means to bracket a sequence of graph
            events.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FirePostEvent(System.Object)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Graph.FirePostEvent" />
            .
            </summary>
      <param name="id">
            
            An identifying tag for the event.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Graph.FirePostEvent" />
            .
            Additionally, an event ID may be specified.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FirePreEvent">
      <summary>Propagates a so-called PRE event to all registered graph listeners.</summary>
      <remarks>
            Propagates a so-called PRE event to all registered graph listeners.
            This method should only be used if a corresponding call to
            <see cref="M:yWorks.yFiles.Algorithms.Graph.FirePostEvent" />
            
            follows.
            <p />
            Generally, PRE and POST events serve as a means to bracket a sequence of graph
            events.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FirePreEvent(System.Object)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Graph.FirePreEvent" />
            .
            </summary>
      <param name="id">
            
            An identifying tag for the event.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Graph.FirePreEvent" />
            .
            Additionally, an event ID may be specified.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.FirstEdge">
      <summary>The first edge in this graph.</summary>
      <remarks>Returns the first edge in this graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.FirstNode">
      <summary>The first node in this graph.</summary>
      <remarks>Returns the first node in this graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.FirstOutEdge(yWorks.yFiles.Algorithms.Node)">
      <summary>Low-level iteration support for adjacent edges.</summary>
      <remarks>Low-level iteration support for adjacent edges.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetDataProvider(System.Object)">
      <summary>
            Returns the data provider that is registered with the graph using the given
            look-up key.
            </summary>
      <remarks>
            Returns the data provider that is registered with the graph using the given
            look-up key.
            The look-up domain of a returned data provider normally consists of either
            the nodes of the graph, or its edges, or both.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetEdgeArray">
      <summary>Returns an array containing all edges of this graph.</summary>
      <remarks>Returns an array containing all edges of this graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetEdgeCursor">
      <summary>Provides access to the edges of the graph.</summary>
      <returns>
            
            An EdgeCursor to iterate over the edges in the graph.
            </returns>
      <remarks>Provides access to the edges of the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetNodeArray">
      <summary>Returns an array containing all nodes of this graph.</summary>
      <remarks>Returns an array containing all nodes of this graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetNodeCursor">
      <summary>Provides access to the nodes of the graph.</summary>
      <returns>
            
            A NodeCursor to iterate over the nodes in the graph.
            </returns>
      <remarks>Provides access to the nodes of the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetSource(System.Object)">
      <summary>Returns the source node associated with the given edge.</summary>
      <remarks>Returns the source node associated with the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.GetTarget(System.Object)">
      <summary>Returns the target node associated with the given edge.</summary>
      <remarks>Returns the target node associated with the given edge.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.GraphCopyFactory">
      <summary>The copy factory that is associated with this instance.</summary>
      <remarks>
            Specifies the copy factory that is associated with this instance.
            The factory should be used by software that wants to create
            copies of this graph instance if it is in need of a factory.
            If no factory has been set, this method will initialize this instance's
            factory using factory method
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateGraphCopyFactory" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.GraphListeners">
      <summary>An iterator that grants access to all registered graph listeners.</summary>
      <remarks>Returns an iterator that grants access to all registered graph listeners.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.HasListeners">
      <summary>Determines whether there are listeners registered with this instance.</summary>
      <remarks>Determines whether there are listeners registered with this instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Hide(yWorks.yFiles.Algorithms.Edge)">
      <summary>Hides the given edge from this graph.</summary>
      <remarks>
            Hides the given edge from this graph.
            Hiding an edge means to (temporarily) remove the edge from the graph.
            <p />
            The only difference to a proper edge removal as performed by
            <see cref="M:yWorks.yFiles.Algorithms.Graph.RemoveEdge(yWorks.yFiles.Algorithms.Edge)" />
            
            is that no
            <see cref="T:yWorks.yFiles.Algorithms.GraphEvent" />
            will be emitted that signals the structural change
            (i.e. the edge's removal).
            <p />
            Generally, hiding should <i>only</i> be used in the sense of temporarily removing
            an object that will be reinserted shortly after.
            <p />
            To reinsert a hidden edge use
            <see cref="M:yWorks.yFiles.Algorithms.Graph.Unhide(yWorks.yFiles.Algorithms.Edge)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Hide(yWorks.yFiles.Algorithms.Node)">
      <summary>Hides the given node from this graph.</summary>
      <remarks>
            Hides the given node from this graph.
            Hiding a node means to (temporarily) remove the node from the graph.
            <p />
            The only difference to a proper node removal as performed by
            <see cref="M:yWorks.yFiles.Algorithms.Graph.RemoveNode(yWorks.yFiles.Algorithms.Node)" />
            
            is that no
            <see cref="T:yWorks.yFiles.Algorithms.GraphEvent" />
            will be emitted that signals the structural change
            (i.e. the node's removal).
            <p />
            Generally, hiding should <i>only</i> be used in the sense of temporarily removing
            an object that will be reinserted shortly after.
            <p />
            To reinsert a hidden node use
            <see cref="M:yWorks.yFiles.Algorithms.Graph.Unhide(yWorks.yFiles.Algorithms.Node)" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.LastEdge">
      <summary>The last edge in this graph.</summary>
      <remarks>Returns the last edge in this graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.LastNode">
      <summary>The last node in this graph.</summary>
      <remarks>Returns the last node in this graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.MoveSubGraph(yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.Graph)">
      <summary>Moves an induced subgraph to another graph.</summary>
      <param name="subNodes">
            
            A list of nodes that induce the subgraph to be moved.
            </param>
      <param name="targetGraph">
            
            The graph where the subgraph is moved to.
            </param>
      <returns>
            
            A list of removed edges that connected the induced subgraph to this graph.
            </returns>
      <remarks>Moves an induced subgraph to another graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.MoveToFirst(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Moves the given edge to the first position within the sequence of edges in
            this graph.
            </summary>
      <remarks>
            Moves the given edge to the first position within the sequence of edges in
            this graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.MoveToFirst(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Moves the given node to the first position within the sequence of nodes in
            this graph.
            </summary>
      <remarks>
            Moves the given node to the first position within the sequence of nodes in
            this graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.MoveToLast(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Moves the given edge to the last position within the sequence of edges in this
            graph.
            </summary>
      <remarks>
            Moves the given edge to the last position within the sequence of edges in this
            graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.MoveToLast(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Moves the given node to the last position within the sequence of nodes in this
            graph.
            </summary>
      <remarks>
            Moves the given node to the last position within the sequence of nodes in this
            graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.N">
      <summary>The number of nodes in this graph.</summary>
      <remarks>
            Returns the number of nodes in this graph.
            Same as
            <see cref="P:yWorks.yFiles.Algorithms.Graph.NodeCount" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.NodeCount">
      <summary>The number of nodes in this graph.</summary>
      <remarks>Returns the number of nodes in this graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.NodeObjects">
      <summary>Returns an iterator that provides access to all nodes residing in this graph.</summary>
      <remarks>Returns an iterator that provides access to all nodes residing in this graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.Nodes">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" />
            for <see cref="T:yWorks.yFiles.Algorithms.Node" />s that can be used to iterate over the nodes that are contained in this instance.
            </summary>
      <remarks>
            This is a live enumerable and will thus reflect the current state of the graph.
            Note that changes to the graph structure during the traversal should be carried out with great care.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.PrintNodeSlotSize">
      <summary>For internal debugging purposes only.</summary>
      <remarks>For internal debugging purposes only.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.RegisteredEdgeMaps">
      <summary>
            All edge maps that have been created by this graph but have not yet
            been disposed.
            </summary>
      <remarks>
            Returns all edge maps that have been created by this graph but have not yet
            been disposed.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Graph.RegisteredNodeMaps">
      <summary>
            All node maps that have been created by this graph but have not yet
            been disposed.
            </summary>
      <remarks>
            Returns all node maps that have been created by this graph but have not yet
            been disposed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ReInsertEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Reinserts a formerly removed edge into this graph and fires a corresponding
            notification event to inform registered listeners.
            </summary>
      <param name="e">
            
            The edge to be reinserted.
            </param>
      <remarks>
            Reinserts a formerly removed edge into this graph and fires a corresponding
            notification event to inform registered listeners.
            <p />
            The reinserted edge is appended to the sequence of edges in this graph, i.e.,
            normally, its new position does not match the position before its removal.
            The same holds for the edge's positions in the list of incoming and outgoing
            edges at its source node and target node, respectively.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ReInsertNode(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Reinserts a formerly removed node into this graph and fires a corresponding
            notification event to inform registered listeners.
            </summary>
      <param name="v">
            
            The node to be reinserted.
            </param>
      <remarks>
            Reinserts a formerly removed node into this graph and fires a corresponding
            notification event to inform registered listeners.
            <p />
            The reinserted node is appended to the sequence of nodes in this graph, i.e.,
            normally, its new position does not match the position before its removal.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.RemoveDataProvider(System.Object)">
      <summary>Removes the data provider that is registered using the given look-up key.</summary>
      <remarks>Removes the data provider that is registered using the given look-up key.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.RemoveEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Removes the given edge from this graph and fires a corresponding notification
            event to inform registered listeners.
            </summary>
      <param name="e">
            
            The edge to be removed.
            </param>
      <remarks>
            Removes the given edge from this graph and fires a corresponding notification
            event to inform registered listeners.
            <p />
            The edge will be deselected before it gets removed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.RemoveGraphListener(yWorks.yFiles.Algorithms.IGraphListener)">
      <summary>Removes the given graph listener from this graph.</summary>
      <remarks>Removes the given graph listener from this graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.RemoveNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes the given node from this graph.</summary>
      <param name="v">
            
            The node to be removed from this graph.
            </param>
      <remarks>
            Removes the given node from this graph.
            All edges connecting to the given node are removed as well (preceding the actual
            node removal).
            Corresponding notification events are fired to inform registered listeners.
            <p />
            The node will be deselected before it gets removed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ReverseEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Reverses the given edge and fires corresponding notification events to inform
            registered listeners.
            </summary>
      <remarks>
            Reverses the given edge and fires corresponding notification events to inform
            registered listeners.
            This operation exchanges source and target node of the edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.SortEdges(System.Collections.IComparer)">
      <summary>Sorts the internally held list of edges.</summary>
      <param name="comp">The comparator used for the edges.</param>
      <remarks>
            Sorts the internally held list of edges.
            If the given comparator is <see langword="null" />, then the edges will not be sorted.
            This list determines the order of the edges as returned by
            <see cref="M:yWorks.yFiles.Algorithms.Graph.GetEdgeCursor" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.SortEdges(System.Collections.IComparer,System.Collections.IComparer)">
      <summary>Sorts incoming and outgoing edges at each node of the graph.</summary>
      <param name="inComp">
            
            The comparator used for the incoming edges at each node.
            </param>
      <param name="outComp">
            
            The comparator used for the outgoing edges at each node.
            </param>
      <remarks>
            Sorts incoming and outgoing edges at each node of the graph.
            If a given comparator is <see langword="null" />, then the corresponding edges (i.e.,
            incoming/outgoing) will not be sorted.
            This sorts the order of the edges as returned by
            <see cref="M:yWorks.yFiles.Algorithms.Node.GetOutEdgeCursor" />
            and
            <see cref="M:yWorks.yFiles.Algorithms.Node.GetInEdgeCursor" />
            respectively.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.SortNodes(System.Collections.IComparer)">
      <summary>Sorts the internally held list of nodes.</summary>
      <param name="comp">The comparator used for the nodes.</param>
      <remarks>
            Sorts the internally held list of nodes.
            If the given comparator is <see langword="null" />, then the nodes will not be sorted.
            This list determines the order of the nodes as returned by
            <see cref="M:yWorks.yFiles.Algorithms.Graph.GetNodeCursor" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.ToString">
      <summary>Returns a String representation of this graph.</summary>
      <remarks>
            Returns a String representation of this graph.
            The result contains the String representations of all nodes followed by the
            String representations of all edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Unhide(yWorks.yFiles.Algorithms.Edge)">
      <summary>Unhides the given edge in this graph.</summary>
      <remarks>
            Unhides the given edge in this graph.
            Unhiding an edge means to reinsert an edge that was formerly hidden from this
            graph by a call to
            <see cref="M:yWorks.yFiles.Algorithms.Graph.Hide(yWorks.yFiles.Algorithms.Edge)" />
            .
            <p />
            The only difference to a proper edge reinsertion as performed by
            <see cref="M:yWorks.yFiles.Algorithms.Graph.ReInsertEdge(yWorks.yFiles.Algorithms.Edge)" />
            
            is that no
            <see cref="T:yWorks.yFiles.Algorithms.GraphEvent" />
            will be emitted that signals the structural change
            (i.e. the edge's reinsertion).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Graph.Unhide(yWorks.yFiles.Algorithms.Node)">
      <summary>Unhides the given node in this graph.</summary>
      <remarks>
            Unhides the given node in this graph.
            Unhiding a node means to reinsert a node that was formerly hidden from this
            graph by a call to
            <see cref="M:yWorks.yFiles.Algorithms.Graph.Hide(yWorks.yFiles.Algorithms.Node)" />
            .
            <p />
            The only difference to a proper node reinsertion as performed by
            <see cref="M:yWorks.yFiles.Algorithms.Graph.ReInsertNode(yWorks.yFiles.Algorithms.Node)" />
            
            is that no
            <see cref="T:yWorks.yFiles.Algorithms.GraphEvent" />
            will be emitted that signals the structural change
            (i.e. the node's reinsertion).
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphChecker">
      <summary>
            Provides methods that check structural properties of
            a given graph.
            </summary>
      <remarks>
            Provides methods that check structural properties of
            a given graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsAcyclic(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph contains to directed cycle.</summary>
      <remarks>Checks whether or not the given graph contains to directed cycle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsBiconnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph his biconnected.</summary>
      <remarks>Checks whether or not the given graph his biconnected.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsBipartite(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph his bipartite.</summary>
      <remarks>Checks whether or not the given graph his bipartite.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsConnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is connected.</summary>
      <remarks>Checks whether or not the given graph is connected.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsCyclic(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph contains a directed cycle.</summary>
      <remarks>Checks whether or not the given graph contains a directed cycle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsForest(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is a forest, i.e.</summary>
      <remarks>
            Checks whether or not the given graph is a forest, i.e.
            a graph whose connected components are rooted trees.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsMultipleEdgeFree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph contains multiple edges, i.e.</summary>
      <remarks>
            Checks whether or not the given graph contains multiple edges, i.e.
            contains no two distinct edges <c>e1, e2</c> that
            connect the same pairs of nodes in either direction.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsNaryTree(yWorks.yFiles.Algorithms.Graph,System.Int32)">
      <summary>
            Checks whether or not the given graph is a rooted tree
            where each node has a maximum of <c>n</c> children.
            </summary>
      <remarks>
            Checks whether or not the given graph is a rooted tree
            where each node has a maximum of <c>n</c> children.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsPlanar(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is planar.</summary>
      <remarks>Checks whether or not the given graph is planar.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsRootedTree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is a rooted tree.</summary>
      <remarks>Checks whether or not the given graph is a rooted tree.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsSelfLoopFree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph contains self-loops.</summary>
      <remarks>Checks whether or not the given graph contains self-loops.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsSimple(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is simple, i.e.</summary>
      <remarks>
            Checks whether or not the given graph is simple, i.e.
            contains no two distinct edges <c>e1, e2</c> where
            <c>e1.source() == e2.source() &amp;&amp; e1.target() == e2.target().</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsStronglyConnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is strongly connected.</summary>
      <remarks>Checks whether or not the given graph is strongly connected.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphChecker.IsTree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is an undirected tree.</summary>
      <remarks>Checks whether or not the given graph is an undirected tree.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphConnectivity">
      <summary>Provides algorithms for determining certain connectivity components within a graph.</summary>
      <remarks>
            Provides algorithms for determining certain connectivity components within a graph.
            Also provides convenience method for working with these components.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.GraphConnectivity" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph)">
      <summary>Calculates the biconnected components of a given undirected graph.</summary>
      <param name="graph">the input graph</param>
      <remarks>
            Calculates the biconnected components of a given undirected graph.
            The result is returned as an array of EdgeList objects each containing all
            edges that belong to the same biconnected component of
            the graph.
            <p>
            <b>Note:</b> Selfloops do not belong to any biconnected component.
            Therefore no selfloops are included in the returned edge lists.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Calculates the biconnected components of a given undirected graph.</summary>
      <param name="graph">the input graph</param>
      <param name="compNum">
            return value that provides for each edge a zero-based index
            of the biconnected component it belongs to or
            <c>-1</c> for selfloops.
            </param>
      <returns>the number of biconnected components found</returns>
      <remarks>
            Calculates the biconnected components of a given undirected graph.
            The main result is returned in the form of an EdgeMap that provides
            for each edge a zero-based index of the biconnected component it belongs to.
            <p>
            <b>Note:</b> Selfloops do not belong to any biconnected component.
            Therefore the component index for selfloops is always <c>-1</c>.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Calculates the biconnected components of a given undirected graph.</summary>
      <param name="aPoint">
            return value that provides for each node  a boolean value
            indicating whether or not it is an articulation point.
            </param>
      <remarks>
            Calculates the biconnected components of a given undirected graph.
            Additionally, this method calculates the articulation points of the input
            graph. Articulation points are returned in the form of a NodeMap that
            provides for each node a boolean value indicating whether or not it is an
            articulation point.
            <p>
            <b>Note:</b> Selfloops do not belong to any biconnected component.
            Therefore the component index for selfloops is always <c>-1</c>.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns the connected components of a given graph.</summary>
      <param name="graph">the input graph</param>
      <returns>
            an array of NodeLists each of which contains the nodes that belong to
            a common connected component of the graph.
            </returns>
      <remarks>
            Returns the connected components of a given graph.
            <p />
            A graph <c>G</c> is called connected if there is an
            undirected path between each pair of nodes belonging to <c>G</c>.
            The connected components of <c>G</c> are connected
            subgraphs that <c>G</c> consists of.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns the connected components of a given graph.</summary>
      <param name="graph">the input graph</param>
      <param name="compNum">
            return value that will hold the zero-based number
            of the connected component that it belongs to. The component number of
            Node <c>v</c> is <c>compNum.getInt()</c>.
            </param>
      <returns>the number of connected components of this graph.</returns>
      <remarks>
            Returns the connected components of a given graph.
            <p />
            A graph <c>G</c> is called connected if there is an
            undirected path between each pair of nodes belonging to <c>G</c>.
            The connected components of <c>G</c> are connected
            subgraphs that <c>G</c> consists of.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.GetNeighbors(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,System.Int32)">
      <summary>Determines the direct or indirect neighbors of a given set of nodes.</summary>
      <param name="graph">the graph to act upon</param>
      <param name="startNodes">contains the node the search is started from</param>
      <param name="maxDistance">
            limits the distance between a start node and a returned node. For all returned
            nodes there must be a path to a start node that has a length equal or smaller than maxDistance.
            Setting maxDistance to <c>1</c> will only yield the direct neighbors of all start nodes. On the other hand,
            setting maxDistance to <c>graph.N()</c> or larger, will yield all neighbors of all start nodes.
            </param>
      <returns>
            a NodeList that contains all direct and indirect neighbors of a node.
            The order of the returned nodes follows is determined by a breadth first search.
            No start node will be part of the resulting set.
            </returns>
      <remarks>
            Determines the direct or indirect neighbors of a given set of nodes. A direct neighbor
            of a node is directly connected by an edge to that node.
            An indirect neighbor of a node is directly connected to another direct or indirect neighbor of a node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.GetPredecessors(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,System.Int32)">
      <summary>Determines the direct or indirect predecessors of a given set of nodes.</summary>
      <param name="graph">the graph to act upon</param>
      <param name="startNodes">contains the node the search is started from</param>
      <param name="maxDistance">
            limits the distance between a start node and a returned node. For all returned
            nodes there must be a path to a start node that has a length equal or smaller than maxDistance.
            Setting maxDistance to <c>1</c> will only yield the direct predecessors of all start nodes. On the other hand,
            setting maxDistance to <c>graph.N()</c> or larger, will yield all predecessors of all start nodes.
            </param>
      <returns>
            a NodeList that contains all direct and indirect predecessors of a node. The order
            of the returned nodes follows is determined by a breadth first search.
            No start node will be part of the resulting set.
            </returns>
      <remarks>
            Determines the direct or indirect predecessors of a given set of nodes. A direct predecessor
            of a node is the source node of an ingoing edge connected to a node.
            An indirect predecessor of a node is a direct predecessor to another predecessor of a node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.GetSuccessors(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,System.Int32)">
      <summary>Determines the direct or indirect successors of a given set of nodes.</summary>
      <param name="graph">the graph to act upon</param>
      <param name="startNodes">contains the node the search is started from</param>
      <param name="maxDistance">
            limits the distance between a start node and a returned node. For all returned
            nodes there must be a path to a start node that has a length equal or smaller than maxDistance.
            Setting maxDistance to <c>1</c> will only yield the direct successors of all start nodes. On the other hand,
            setting maxDistance to <c>graph.N()</c> or larger, will yield all successors of all start nodes.
            </param>
      <returns>
            a NodeList that contains all direct and indirect successors of a node. The order
            of the returned nodes follows is determined by a breadth first search.
            No start node will be part of the resulting set.
            </returns>
      <remarks>
            Determines the direct or indirect successors of a given set of nodes. A direct successor
            of a node is the target node of an outgoing edge connected to a node.
            An indirect successor of a node is a direct successor to another successor of a node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.IsBiconnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph his biconnected.</summary>
      <remarks>Checks whether or not the given graph his biconnected.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.IsConnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is connected.</summary>
      <remarks>Checks whether or not the given graph is connected.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.IsStronglyConnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is strongly connected.</summary>
      <remarks>Checks whether or not the given graph is strongly connected.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.MakeBiconnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Makes the given graph biconnected by inserting a minimum number of edges
            in the graph.
            </summary>
      <param name="graph">the input graph</param>
      <returns>an edge list containing the edges added to this graph.</returns>
      <remarks>
            Makes the given graph biconnected by inserting a minimum number of edges
            in the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.MakeConnected(yWorks.yFiles.Algorithms.Graph)">
      <summary>Makes a graph connected by adding additional edges to the graph.</summary>
      <param name="graph">the input graph</param>
      <returns>an edge list containing the edges added to this graph.</returns>
      <remarks>
            Makes a graph connected by adding additional edges to the graph.
            The number of edges that will be added is equal to one less the number of
            separate components of the original graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.Reachable(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Boolean[])">
      <summary>
            Determines the set of nodes that can be reached in the given graph when starting
            from a given node.
            </summary>
      <param name="graph">the graph the search is performed on</param>
      <param name="start">the node the search is started from</param>
      <param name="directed">
            traverses edges only from source to target if <see langword="true" />. Otherwise
            traverses edges in both directions.
            </param>
      <param name="reached">
            the return value. a boolean array that has value <see langword="true" /> at field
            <c>v.index()</c> iff node v can be reached by the dfs search.
            </param>
      <remarks>
            Determines the set of nodes that can be reached in the given graph when starting
            from a given node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.Reachable(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Boolean[],System.Boolean[])">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.Reachable(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Boolean[])" />
            .
            </summary>
      <param name="graph">the graph DFS is performed on</param>
      <param name="start">the node DFS is started from</param>
      <param name="directed">
            traverses edges only from source to target if <see langword="true" />. Otherwise
            traverses edges in both directions.
            </param>
      <param name="forbidden">
            marks edges that may not be traversed by DFS. An edge <c>e</c>
            is marked as forbidden if <c>forbidden[e.index()] == true</c>.
            </param>
      <param name="reached">
            the return value. a boolean array that has value <see langword="true" /> at field
            <c>v.index()</c> iff node v can be reached by the dfs search.
            </param>
      <remarks>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.Reachable(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Boolean[])" />
            . Additionally
            it is possible to specify a set of forbidden edges that will not be traversed
            when performing the search.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.StronglyConnectedComponents(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns the connected components of a given graph.</summary>
      <param name="graph">the input graph</param>
      <returns>
            an array of NodeLists each of which contains the nodes that belong to
            a common connected component of the graph.
            </returns>
      <remarks>
            Returns the connected components of a given graph.
            <p />
            A graph <c>G</c> is called strongly connected if there is an
            directed path between each pair of nodes belonging to <c>G</c>.
            The strongly connected components of <c>G</c> are strongly connected
            subgraphs that <c>G</c> consists of.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.StronglyConnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns the connected components of a given graph.</summary>
      <param name="graph">the input graph</param>
      <param name="compNum">
            return value that will hold the zero-based number
            of the strongly connected component that it belongs to. The component number of
            Node <c>v</c> is <c>compNum.getInt()</c>.
            </param>
      <returns>the number of strongly connected components of this graph.</returns>
      <remarks>
            Returns the connected components of a given graph.
            <p />
            A graph <c>G</c> is called strongly connected if there is an
            directed path between each pair of nodes belonging to <c>G</c>.
            The strongly connected components of <c>G</c> are strongly connected
            subgraphs that <c>G</c> consists of.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.ToEdgeListArray(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,System.Int32)">
      <summary>
            Transforms the return values of
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)" />
            to
            an array of
            <see cref="T:yWorks.yFiles.Algorithms.EdgeList" />
            s, like it is returned by
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph)" />
            .
            </summary>
      <remarks>
            Transforms the return values of
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap)" />
            to
            an array of
            <see cref="T:yWorks.yFiles.Algorithms.EdgeList" />
            s, like it is returned by
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.yFiles.Algorithms.Graph)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphConnectivity.ToNodeListArray(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>
            Transforms the return values of
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)" />
            to
            an array of type NodeList, like it is returned by
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.yFiles.Algorithms.Graph)" />
            .
            </summary>
      <remarks>
            Transforms the return values of
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)" />
            to
            an array of type NodeList, like it is returned by
            <see cref="M:yWorks.yFiles.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.yFiles.Algorithms.Graph)" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphCopyFactory">
      <summary>
            Very simple default implementation of a Copy Factory that creates
            <see cref="T:yWorks.yFiles.Algorithms.Graph" />
            instances
            and simply delegates to the
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateNode" />
            and
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)" />
            method.
            </summary>
      <remarks>
            Very simple default implementation of a Copy Factory that creates
            <see cref="T:yWorks.yFiles.Algorithms.Graph" />
            instances
            and simply delegates to the
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateNode" />
            and
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)" />
            method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.GraphCopyFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.CopyEdge(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Copies the <c>originalEdge</c> from the source graph to the new <c>targetGraph</c>
            using the specified new source and target node in the target graph.
            </summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="newSource">the source node in the target graph to use for the newly created edge</param>
      <param name="newTarget">the target node in the target graph to use for the newly created edge</param>
      <param name="originalEdge">the original edge from the source graph</param>
      <returns>the newly created edge</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.CopyNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>Copies the <c>originalNode</c> from the source graph to the new <c>targetGraph</c></summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="originalNode">the original node from the source graph</param>
      <returns>the newly created node</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.CreateGraph">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Algorithms.Graph" />
            .
            </summary>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Algorithms.Graph" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.PostCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>This implementation does nothing.</summary>
      <remarks>This implementation does nothing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphCopyFactory.PreCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>This implementation does nothing.</summary>
      <remarks>This implementation does nothing.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphElementInsertion">
      <summary>Object insertion specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphElementInsertion.Before">
      <summary>
            Object insertion specifier.
            An object gets inserted before another one.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphElementInsertion.After">
      <summary>
            Object insertion specifier.
            An object gets inserted after another one.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphEvent">
      <summary>An event which indicates that a graph structure change occurred.</summary>
      <remarks>
            An event which indicates that a graph structure change occurred.
            This low-level event is generated by a graph when its structure changes.
            The event is passed to every
            <see cref="T:yWorks.yFiles.Algorithms.IGraphListener" />
            object that registered to
            receive such events using the graph's
            <see cref="M:yWorks.yFiles.Algorithms.Graph.AddGraphListener(yWorks.yFiles.Algorithms.IGraphListener)">addGraphListener</see>
            method.
            <p />
            The object that implements the GraphListener interface gets this GraphEvent when
            the event occurs.
            <p />
            Each GraphEvent has a type that signals what kind of change occurred in the graph
            and a data object that is the object (either node or edge) that was involved
            in the structural change of the graph, e.g., the node that has been created or
            the edge that has been reversed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphEvent.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.GraphEventType,System.Object)">
      <summary>Creates a new GraphEvent instance with given type and data.</summary>
      <remarks>Creates a new GraphEvent instance with given type and data.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.GraphEvent.Data">
      <summary>The data object associated with this graph event.</summary>
      <remarks>
            Returns the data object associated with this graph event.
            For a "Node"-associated event, it returns an object of type y.base.Node.
            For an "Edge"-associated event, it returns an object of type y.base.Edge.
            To check the type of event, see the method getType()
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.GraphEvent.Graph">
      <summary>The graph that is the emitter of this event.</summary>
      <remarks>Returns the graph that is the emitter of this event.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.GraphEvent.ToString">
      <summary>Returns a String representation of this GraphEvent object's type.</summary>
      <remarks>Returns a String representation of this GraphEvent object's type.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.GraphEvent.Type">
      <summary>The type of this GraphEvent.</summary>
      <remarks>
            Returns the type of this GraphEvent.
            It can be either of the type constants defined in this class.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphEventType" />
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.NodeCreation">
      <summary>
            Type constant that identifies an event that gets fired immediately after a
            node has been created.
            The data of the event is the newly created node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.EdgeCreation">
      <summary>
            Type constant that identifies an event that gets fired immediately after an
            edge has been created.
            The data of the event is the newly created edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PreNodeRemoval">
      <summary>
            Type constant that identifies an event that gets fired immediately before a
            node will be removed from the graph.
            The data of the event is the node to be removed.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PostNodeRemoval">
      <summary>
            Type constant that identifies an event that gets fired immediately after a
            node has been removed from the graph.
            The data of the event is the removed node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PreEdgeRemoval">
      <summary>
            Type constant that identifies an event that gets fired immediately before an
            edge will be removed from the graph.
            The data of the event is the edge to be removed.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PostEdgeRemoval">
      <summary>
            Type constant that identifies an event that gets fired immediately after an
            edge has been removed from the graph.
            The data of the event is the removed edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.NodeReinsertion">
      <summary>
            Type constant that identifies an event that gets fired immediately after a
            node has been reinserted into the graph.
            The data of the event is the reinserted node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.EdgeReinsertion">
      <summary>
            Type constant that identifies an event that gets fired immediately after an
            edge has been reinserted into the graph.
            The data of the event is the reinserted edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PreEdgeChange">
      <summary>
            Type constant that identifies an event that gets fired immediately before the
            end points of an edge will be changed.
            The data of the event is the edge to be redefined.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PostEdgeChange">
      <summary>
            Type constant that identifies an event that gets fired immediately after the
            end points of an edge have been changed.
            The data of the event is the redefined edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.SubgraphInsertion">
      <summary>
            Type constant that identifies an event that gets fired after a subgraph of
            a graph G has been moved to the emitting graph.
            The data of the event is a
            <see cref="T:yWorks.yFiles.Algorithms.NodeList" />
            containing the nodes that induce
            the moved subgraph.
            <p />
            This event gets fired just after the
            <see cref="F:yWorks.yFiles.Algorithms.GraphEventType.SubgraphRemoval" />
            event got fired
            on the subgraph's original graph G.
            Note that at the time the event gets fired, the nodes from the node list are
            already part of the emitting graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.SubgraphRemoval">
      <summary>
            Type constant that identifies an event that gets fired after a subgraph of
            the emitting graph has been moved to a graph G.
            The data of the event is a
            <see cref="T:yWorks.yFiles.Algorithms.NodeList" />
            containing the nodes that induce
            the moved subgraph.
            <p />
            This event gets fired just before the
            <see cref="F:yWorks.yFiles.Algorithms.GraphEventType.SubgraphInsertion" />
            event will
            be fired on the subgraph's new graph G.
            Note that at the time the event gets fired, the nodes from the node list are
            already part of graph G.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PreEvent">
      <summary>
            Type constant that signals the start of a some logically coherent event sequence.
            If specified, the data of this event is its ID.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.GraphEventType.PostEvent">
      <summary>
            Type constant that signals the end of a some logically coherent event sequence.
            If specified, the data of this event is its ID.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.GraphObject">
      <summary>
            Common base type for both <see cref="T:yWorks.yFiles.Algorithms.Node" /> and <see cref="T:yWorks.yFiles.Algorithms.Edge" />.
            </summary>
      <remarks>
            This type does not add public functionality to its base type.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Groups">
      <summary>This class provides methods for automatically partitioning nodes of a graph into groups.</summary>
      <remarks>This class provides methods for automatically partitioning nodes of a graph into groups.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Groups.BiconnectedComponentGrouping(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>This method partitions the graph by analyzing its biconnected component structure.</summary>
      <param name="graph">the input graph.</param>
      <param name="groupIDs">used as return value. This map gets a cluster ID of integer type for every node.</param>
      <returns>the number of different groups found.</returns>
      <remarks>
            This method partitions the graph by analyzing its biconnected component structure. Nodes will be grouped in a way
            that the nodes within each group are biconnected. Nodes that belong to multiple biconnected components will be
            assigned to exactly one of these components.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Groups.EdgeBetweennessClustering(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,System.Int32,System.Int32,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Partitions the graph into groups using edge betweenness centrality (see
            <see cref="M:yWorks.yFiles.Algorithms.Centrality.EdgeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            </summary>
      <param name="graph">the input graph.</param>
      <param name="clusterIDs">used as return value. This map gets a cluster ID of integer type for every node.</param>
      <param name="directed">whether or not to consider the edges of the graph as directed.</param>
      <param name="minGroupCount">the minimum number of groups to be returned.</param>
      <param name="maxGroupCount">
            the maximum number of groups to be returned. The smaller this value is chosen the faster the
            overall computation time. Note that the upper bound on the number of groups is
            <c>graph.N()</c>. Note, that the number of returned groups is never less than the number
            of connected components of the graph.
            </param>
      <param name="edgeCosts">
            if <see langword="null" /> the edges of the graph are considered to have equal cost. Otherwise
            it must provide a non-negative <c>double</c> value (its cost) for every edge.
            </param>
      <returns>the number of different groups found.</returns>
      <remarks>
            Partitions the graph into groups using edge betweenness centrality (see
            <see cref="M:yWorks.yFiles.Algorithms.Centrality.EdgeBetweenness(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)" />
            . In each iteration the edge with the highest
            betweenness centrality is removed from the graph. The method stops, if there are no more edges to remove. The
            clustering with the best quality reached during the process will be returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Groups.EdgeBetweennessClustering(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Double,System.Int32,System.Int32,System.Boolean)">
      <summary>Partitions the graph into groups using <em>Edge Betweenness Clustering</em> proposed by Girvan and Newman.</summary>
      <param name="graph">the input graph.</param>
      <param name="clusterIDs">used as return value. This map gets a cluster ID of integer type for every node.</param>
      <param name="qualityTimeRatio">
            a value between 0.0 (low quality, fast) and 1.0 (high quality, slow). The recommended value
            is 0.5.
            </param>
      <param name="minGroupCount">the minimum number of groups to be returned.</param>
      <param name="maxGroupCount">
            the maximum number of groups to be returned. The smaller this value is chosen the faster
            the overall computation time. Note, that the upper bound on the number of groups is
            <c>graph.N()</c> and that the number of returned groups is never less than the number
            of connected components of the graph.
            </param>
      <param name="refine">whether the algorithm refines or discards the current grouping.</param>
      <returns>the number of different groups found</returns>
      <remarks>
            Partitions the graph into groups using <em>Edge Betweenness Clustering</em> proposed by Girvan and Newman. In each
            iteration the edge with the highest betweenness centrality is removed from the graph. The method stops, if there
            are no more edges to remove or if the requested maximum number of groups is found. The clustering with the best
            quality reached during the process is returned.
            <p />
            The algorithm includes several heuristic speed-up techniques available through the quality/time ratio.  For the
            highest quality setting, it is used almost unmodified. The fast betweenness approximation of Brandes und Pich
            (<em>Centrality Estimation in Large Networks</em>) is employed for values around 0.5. Typically, this results in a
            tiny decrease in quality but a large speed-up and is the recommended setting. To achieve the lowest running time, a
            local betweenness calculation is used (Gregory: <em>Local Betweenness for Finding Communities in Networks</em>).
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.ICursor">
      <summary>A general interface for iterating over a collection of objects.</summary>
      <remarks>
            A general interface for iterating over a collection of objects.
            It can be regarded as a read-only view of such a collection.
            <p />
            A YCursor acts like a movable pointer on the elements of a collection.
            The pointer can be moved forward and backward and the element currently pointed
            on can be accessed.
            The removal of elements can only be performed on the provider of the cursor,
            not on the cursor itself.
            (That's why the cursor presents a read-only view.)
            <p />
            Implementations of this interface do not need to support operations marked "optional."
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.ICursor.Current">
      <summary>The object currently pointed on.</summary>
      <remarks>Returns the object currently pointed on.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ICursor.Next">
      <summary>Moves this cursor one position forward.</summary>
      <remarks>Moves this cursor one position forward.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.ICursor.Ok">
      <summary>
        <see langword="true" /> if the current cursor position is valid.</summary>
      <remarks>Returns <see langword="true" /> if the current cursor position is valid.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ICursor.Prev">
      <summary>Moves this cursor one position backward (optional).</summary>
      <remarks>Moves this cursor one position backward (optional).</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.ICursor.Size">
      <summary>The number of elements that can be accessed with this cursor.</summary>
      <remarks>Returns the number of elements that can be accessed with this cursor.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ICursor.ToFirst">
      <summary>Moves this cursor to the first valid cursor position (optional).</summary>
      <remarks>Moves this cursor to the first valid cursor position (optional).</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ICursor.ToLast">
      <summary>Moves this cursor to the last valid cursor position (optional).</summary>
      <remarks>Moves this cursor to the last valid cursor position (optional).</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IDataAcceptor">
      <summary>A general interface for setting data.</summary>
      <remarks>
            A general interface for setting data.
            A data acceptor associates data with data holders.
            It constitutes a write-only view on particular data.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataAcceptor.Set(System.Object,System.Object)">
      <summary>Sets an object value associated with the given data holder.</summary>
      <remarks>
            Sets an object value associated with the given data holder.
            This method may throw an UnsupportedOperationException.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetBool(System.Object,System.Boolean)">
      <summary>Sets a boolean value associated with the given data holder.</summary>
      <remarks>
            Sets a boolean value associated with the given data holder.
            This method may throw an UnsupportedOperationException.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetDouble(System.Object,System.Double)">
      <summary>Sets a double value associated with the given data holder.</summary>
      <remarks>
            Sets a double value associated with the given data holder.
            This method may throw an UnsupportedOperationException.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetInt(System.Object,System.Int32)">
      <summary>Sets an integer value associated with the given data holder.</summary>
      <remarks>
            Sets an integer value associated with the given data holder.
            This method may throw an UnsupportedOperationException.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IDataMap">
      <summary>
            Interface that combines the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            and
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            interfaces.
            </summary>
      <remarks>
            Interface that combines the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            and
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            interfaces. This interface does not declare any additional methods.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IDataProvider">
      <summary>A general interface for data provision.</summary>
      <remarks>
            A general interface for data provision.
            A data provider grants access to data associated
            with one or more data holders. It constitutes a read-only
            view on particular data.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)">
      <summary>Returns an object value associated with the given data holder.</summary>
      <remarks>
            Returns an object value associated with the given data holder.
            This method may throw an UnsupportedOperationException.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">
      <summary>Returns a boolean value associated with the given data holder.</summary>
      <remarks>
            Returns a boolean value associated with the given data holder.
            This method may throw an UnsupportedOperationException.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataProvider.GetDouble(System.Object)">
      <summary>Returns a double value associated with the given data holder.</summary>
      <remarks>
            Returns a double value associated with the given data holder.
            This method may throw an UnsupportedOperationException.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IDataProvider.GetInt(System.Object)">
      <summary>Returns an integer value associated with the given data holder.</summary>
      <remarks>
            Returns an integer value associated with the given data holder.
            This method may throw an UnsupportedOperationException.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IEdgeCursor">
      <summary>A cursor interface for iterating over edges.</summary>
      <remarks>A cursor interface for iterating over edges.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeCursor.CyclicNext">
      <summary>Moves the cursor to the cyclic next element of the underlying sequence.</summary>
      <remarks>
            Moves the cursor to the cyclic next element of the underlying sequence.
            This is the next element if available, else it is the first element.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeCursor.CyclicPrev">
      <summary>Moves the cursor to the cyclic previous element of the underlying sequence.</summary>
      <remarks>
            Moves the cursor to the cyclic previous element of the underlying sequence.
            This is the previous element if available, else it is the last element.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.IEdgeCursor.Edge">
      <summary>The edge at the current location of the cursor.</summary>
      <remarks>
            Returns the edge at the current location of the cursor.
            This method is the typed variant of
            <see cref="P:yWorks.yFiles.Algorithms.ICursor.Current" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IEdgeMap">
      <summary>Provides access to data associated with an edge.</summary>
      <remarks>
            Provides access to data associated with an edge.
            An edge map can be considered as a map that allows
            only edges as keys. Edge keys of an edge map must belong
            to the same graph.
            <p />
            There are data access methods defined for the most common typed
            values as well.
            <p />
            The edge values are initialized with Java(TM) default values
            (null, 0, 0.0, false) upon initialization.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.Get(System.Object)">
      <summary>Returns the value bound to the given edge.</summary>
      <remarks>Returns the value bound to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given edge.</summary>
      <remarks>Returns the boolean value bound to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given edge.</summary>
      <remarks>Returns the double value bound to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given edge.</summary>
      <remarks>Returns the integer value bound to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given edge.</summary>
      <remarks>Associates the given value to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given edge.</summary>
      <remarks>Associates the given boolean value to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given edge.</summary>
      <remarks>Associates the given double value to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IEdgeMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given edge.</summary>
      <remarks>Associates the given integer value to the given edge.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IGraphInterface">
      <summary>
            An interface that describes the structural information of a graph and the data
            that is associated with its nodes and edges.
            </summary>
      <remarks>
            An interface that describes the structural information of a graph and the data
            that is associated with its nodes and edges.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.IGraphInterface.DataProviderKeys">
      <summary>
            An array of all data provider look-up keys that are registered with
            the graph.
            </summary>
      <remarks>
            Returns an array of all data provider look-up keys that are registered with
            the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphInterface.EdgeObjects">
      <summary>Returns an iterator that provides access to all edges residing in the graph.</summary>
      <remarks>Returns an iterator that provides access to all edges residing in the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphInterface.GetDataProvider(System.Object)">
      <summary>
            Returns the data provider that is registered with the graph using the given
            look-up key.
            </summary>
      <remarks>
            Returns the data provider that is registered with the graph using the given
            look-up key.
            The look-up domain of a returned data provider normally consists of either
            the nodes of the graph, or its edges, or both.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphInterface.GetSource(System.Object)">
      <summary>Returns the source node associated with the given edge.</summary>
      <remarks>Returns the source node associated with the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphInterface.GetTarget(System.Object)">
      <summary>Returns the target node associated with the given edge.</summary>
      <remarks>Returns the target node associated with the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphInterface.NodeObjects">
      <summary>Returns an iterator that provides access to all nodes residing in the graph.</summary>
      <remarks>Returns an iterator that provides access to all nodes residing in the graph.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IGraphListener">
      <summary>The listener interface for receiving graph events.</summary>
      <remarks>
            The listener interface for receiving graph events.
            A class that is interested in processing a graph event implements this interface.
            The object created with that class is then registered with a graph.
            When the graph structure changes, the listener object's
            <see cref="M:yWorks.yFiles.Algorithms.IGraphListener.OnGraphEvent(yWorks.yFiles.Algorithms.GraphEvent)">onGraphEvent</see>
            method is invoked.
            <p />
            The listener object's onGraphEvent method is also invoked on so-called PRE and
            POST events emitted by the graph.
            These events signal that a (possibly empty) sequence of graph events is about
            to be emitted (PRE event) or that the sequence is completed (POST event).
            <p />
            For example, if a node is about to be removed from a graph, then the following
            sequence of graph events can be observed:
            <ol>
            <li>
            a PRE event
            </li>
            <li>
            a (possibly empty) sequence of edge removal events
            </li>
            <li>
            the actual node removal event
            </li>
            <li>
            a POST event
            </li>
            </ol>
            The POST event concludes the logically coherent sequence of structural graph
            changes that has been opened by the PRE event.
            <p />
            PRE and POST events must constitute a well-formed bracket-structure, e.g.,
            ( ( () ) () ).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IGraphListener.OnGraphEvent(yWorks.yFiles.Algorithms.GraphEvent)">
      <summary>Invoked when the structure of the graph has changed.</summary>
      <remarks>
            Invoked when the structure of the graph has changed.
            The code written for this method performs the operations that need to occur
            when the graph changes.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.IndependentSets">
      <summary>This class provides methods for calculating independent sets.</summary>
      <remarks>This class provides methods for calculating independent sets.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IndependentSets.GetIndependentSet(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Calculates an independent set for a given conflict graph (each pair of nodes of the independent set is non-adjacent
            in the conflict graph).
            </summary>
      <param name="conflictGraph">the input graph.</param>
      <returns>a NodeList containing an independent set of nodes</returns>
      <remarks>
            Calculates an independent set for a given conflict graph (each pair of nodes of the independent set is non-adjacent
            in the conflict graph). We use a greedy heuristic which tries to find a large independent set.
            <p />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.IndependentSets.GetIndependentSets(yWorks.yFiles.Algorithms.Graph)">
      <summary>Partitions the vertex set of the given conflict graph into independent sets.</summary>
      <param name="conflictGraph">the input graph.</param>
      <returns>a NodeList array where each entry contains an independent set of nodes.</returns>
      <remarks>
            Partitions the vertex set of the given conflict graph into independent sets.
            <p />
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.INodeCursor">
      <summary>A cursor interface for iterating over nodes.</summary>
      <remarks>A cursor interface for iterating over nodes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeCursor.CyclicNext">
      <summary>Moves the cursor to the cyclic next element of the underlying sequence.</summary>
      <remarks>
            Moves the cursor to the cyclic next element of the underlying sequence.
            This is the next element if available, else it is the first element.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeCursor.CyclicPrev">
      <summary>Moves the cursor to the cyclic previous element of the underlying sequence.</summary>
      <remarks>
            Moves the cursor to the cyclic previous element of the underlying sequence.
            This is the previous element if available, else it is the last element.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.INodeCursor.Node">
      <summary>The node at the current location of the cursor.</summary>
      <remarks>
            Returns the node at the current location of the cursor.
            This method is the typed variant of
            <see cref="P:yWorks.yFiles.Algorithms.ICursor.Current" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.INodeMap">
      <summary>Provides access to data associated with a node.</summary>
      <remarks>
            Provides access to data associated with a node.
            A node map can be considered as a map that allows
            only nodes as keys. Node keys of a node map must belong
            to the same graph.
            <p />
            There are data access methods defined for the most common typed
            values as well.
            <p />
            The node values are initialized with Java(TM) default values
            (null, 0, 0.0, false) upon initialization.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
      <remarks>Returns the value bound to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
      <remarks>Returns the boolean value bound to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
      <remarks>Returns the double value bound to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
      <remarks>Returns the integer value bound to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given node.</summary>
      <remarks>Associates the given value to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given node.</summary>
      <remarks>Associates the given boolean value to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given node.</summary>
      <remarks>Associates the given double value to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given node.</summary>
      <remarks>Associates the given integer value to the given node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.INodeSequencer">
      <summary>
            Generic Interface for classes that provide an ordering
            for the nodes of a graph.
            </summary>
      <remarks>
            Generic Interface for classes that provide an ordering
            for the nodes of a graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.INodeSequencer.Nodes(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns a cursor that grants access to <b>all</b> nodes of the given
            graph in some order.
            </summary>
      <remarks>
            Returns a cursor that grants access to <b>all</b> nodes of the given
            graph in some order.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.InvalidGraphStructureException">
      <summary>Exception thrown when a graph-structural precondition is violated.</summary>
      <remarks>
            Exception thrown when a graph-structural precondition is violated.
            <p />
            Some graph algorithms make only sense on specially structured graphs, like,
            e.g., trees, DAGs (short for directed acyclic graph), or planar graphs.
            Methods that detect graph-structural mismatch will throw this exception then.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.InvalidGraphStructureException.#ctor(System.String)">
      <summary>Constructs a WrongGraphStructure exception with the specified message.</summary>
      <remarks>Constructs a WrongGraphStructure exception with the specified message.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.ListCell">
      <summary>
            Represents a so-called "cell" or "link" of the doubly linked list implementation
            <see cref="T:yWorks.yFiles.Algorithms.YList" />
            .
            </summary>
      <remarks>
            Represents a so-called "cell" or "link" of the doubly linked list implementation
            <see cref="T:yWorks.yFiles.Algorithms.YList" />
            .
            It may be used to perform fast access and remove operations on that type of list.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.ListCell.Info">
      <summary>The element stored in this cell.</summary>
      <remarks>Specifies the element stored in this cell.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ListCell.Pred">
      <summary>Returns the predecessor cell of this cell.</summary>
      <remarks>
            Returns the predecessor cell of this cell.
            If there is no predecessor, then <see langword="null" /> is returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ListCell.Succ">
      <summary>Returns the successor cell of this cell.</summary>
      <remarks>
            Returns the successor cell of this cell.
            If there is no successor, then <see langword="null" /> is returned.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.NetworkFlows">
      <summary>
            Provides sophisticated algorithms for solving classical network flow problems
            like MinCostFlow or MaxFlow.
            </summary>
      <remarks>
            Provides sophisticated algorithms for solving classical network flow problems
            like MinCostFlow or MaxFlow.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.NetworkFlows" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.CalcMaxFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Solves a maximum flow problem using the preflow-push method.</summary>
      <param name="graph">the network.</param>
      <param name="source">the source of the network.</param>
      <param name="sink">the sink of the network.</param>
      <param name="eCapDP">
            the capacity of the arcs.
            Infinite capacity is denoted by
            <c>Integer.MAX_VALUE</c></param>
      <param name="flowEM">here the resulting flow is stored.</param>
      <returns>the maximum flow value.</returns>
      <remarks>
            Solves a maximum flow problem using the preflow-push method.
            (see Mehlhorn, Naeher: LEDA: a platform for combinatorial and geometric computing,
            Cambridge University Press, 2000, pp. 443-488)
            The worst case running time is O(mdeg * n^2 * m^(1/2)), where n is the number of
            nodes in the network, m the number of edges and mdeg the maximal degree of any node.
            <p />
            Edges may have infinite capacity, which is denoted by
            the value <c>Integer.MAX_VALUE</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.CalcMaxFlowMinCut(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.NetworkFlows.CalcMaxFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap)" />
            this method
            solves a maximum flow problem.
            </summary>
      <param name="sourceCutNM">
            return value. This map will provide a boolean value for each node
            that indicates whether or not a node belongs to the cut set associated
            with the source of the network.
            </param>
      <returns>
            the maximum flow value which also corresponds to the capacity
            of all edges that cross from the cut set associated with the network source
            to the cut set associated with the network sink.
            </returns>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.NetworkFlows.CalcMaxFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap)" />
            this method
            solves a maximum flow problem. Additionally, this method marks all nodes
            that belong to the minimum cut set that is associated with the
            source of the network.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.MinCostFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Solves a minimum cost flow problem with a capacity scaling algorithm.</summary>
      <param name="graph">the network.</param>
      <param name="lCapDP">
            the lower bound on the arc flow.
            May be <see langword="null" />.
            </param>
      <param name="uCapDP">
            the capacity of the arcs.
            Infinite capacity is denoted by
            <c>Integer.MAX_VALUE</c></param>
      <param name="cost0DP">the costs of the arcs.</param>
      <param name="supplyDP">
            the supply/demand of the nodes.
            Supply is denoted by a positive value, demand by a
            negative value.
            </param>
      <param name="flowEM">here the resulting flow is stored.</param>
      <param name="dualsNM">
            here the resulting dual values are stored.
            Dual values are also referred as potentials.
            May be <see langword="null" />.
            </param>
      <returns>the cost of the flow.</returns>
      <remarks>
            Solves a minimum cost flow problem with a capacity scaling algorithm.
            (see Ahuja,Magnanti,Orlin: Network flows, Prentice Hall, 1993, pp.360-362).
            This algorithm is a variant of the successive shortest path algorithm.
            (see Ahuja,Magnanti,Orlin: Network flows, Prentice Hall, 1993, pp.320-324).
            It has the pseudo-polynomial running time O(m*log U*(m+n log n)) where n is the
            number of nodes in the network, m the number of edges and U the maximal edge
            capacity.
            <p />
            Edges may have infinite capacity, which is denoted by
            the value <c>Integer.MAX_VALUE</c>.
            <p />
            There are no restriction for the costs, especially they
            can be negative.
            Solves a min-cost flow optimization problem.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.MinCostFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Solves a min-cost flow optimization problem.</summary>
      <param name="graph">the network.</param>
      <param name="uCapDP">
            the capacity of the arcs.
            Infinite capacity is denoted by
            <c>Integer.MAX_VALUE</c></param>
      <param name="cost0DP">the costs of the arcs.</param>
      <param name="supplyDP">
            the supply/demand of the nodes.
            Supply is denoted by a positive value, demand by a
            negative value.
            </param>
      <param name="flowEM">here the resulting flow is stored.</param>
      <param name="dualsNM">
            here the resulting dual values are stored.
            Dual values are also referred as potentials.
            </param>
      <returns>the cost of the flow.</returns>
      <remarks>Solves a min-cost flow optimization problem.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NetworkFlows.MinCostFlow(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Solves a min-cost max-flow optimization problem.</summary>
      <param name="graph">the network.</param>
      <param name="s">source of the network.</param>
      <param name="t">sink of the network.</param>
      <param name="uCapDP">
            the capacity of the arcs.
            Infinite capacity is denoted by
            <c>Integer.MAX_VALUE</c></param>
      <param name="cost0DP">the costs of the arcs.</param>
      <param name="flowEM">here the resulting flow is stored.</param>
      <param name="dualsNM">
            here the resulting dual values are stored.
            Dual values are also referred as potentials.
            </param>
      <returns>the cost of the flow.</returns>
      <remarks>Solves a min-cost max-flow optimization problem.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Node">
      <summary>
            Represents a so-called node in the directed graph data type
            <see cref="T:yWorks.yFiles.Algorithms.Graph" />
            .
            </summary>
      <remarks>
            Represents a so-called node in the directed graph data type
            <see cref="T:yWorks.yFiles.Algorithms.Graph" />
            .
            Most notably, a node provides access to its adjacent edges (represented by instances
            of class
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            ).
            These can be distinguished into the sets of incoming and outgoing edges.
            <p />
            Iteration over all three sets of edges is provided by means of bidirectional
            cursors that present a read-only view of the respective set (
            <see cref="M:yWorks.yFiles.Algorithms.Node.GetEdgeCursor" />
            ,
            <see cref="M:yWorks.yFiles.Algorithms.Node.GetInEdgeCursor" />
            ,
            <see cref="M:yWorks.yFiles.Algorithms.Node.GetOutEdgeCursor" />
            ).
            Also supported is iteration over all nodes at opposite ends of either incoming
            edges or outgoing edges (
            <see cref="M:yWorks.yFiles.Algorithms.Node.GetPredecessorCursor" />
            ,
            <see cref="M:yWorks.yFiles.Algorithms.Node.GetSuccessorCursor" />
            ).
            <p />
            The number of overall edges at a node is called its degree (
            <see cref="P:yWorks.yFiles.Algorithms.Node.Degree" />
            ),
            which is the sum of incoming and outgoing edges (
            <see cref="P:yWorks.yFiles.Algorithms.Node.InDegree" />
            ,
            <see cref="P:yWorks.yFiles.Algorithms.Node.OutDegree" />
            ).
            <p />
            <b>Important:</b>
            Class Graph is the single authority for any structural changes to the graph data
            type.
            Specifically, this means that there is no way to create or delete a node or an
            edge without using an actual Graph instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Instantiates a new Node object that will be part of the given graph.</summary>
      <param name="g">
            
            The graph that the created node will belong to.
            </param>
      <remarks>Instantiates a new Node object that will be part of the given graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.CreateCopy(yWorks.yFiles.Algorithms.Graph)">
      <summary>Creates a copy of this node that will be inserted into the given graph.</summary>
      <param name="g">
            
            The graph that the created node will belong to.
            </param>
      <returns>
            
            The newly created Node object.
            </returns>
      <remarks>Creates a copy of this node that will be inserted into the given graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Degree">
      <summary>The overall number of incoming and outgoing edges at this node.</summary>
      <remarks>
            Returns the overall number of incoming and outgoing edges at this node.
            <p />
            Note that self-loops are counted twice.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Edges">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" />
            for <see cref="T:yWorks.yFiles.Algorithms.Edge" />s that can be used to iterate over the adjacent edges at this instance.
            </summary>
      <remarks>
            This is a live enumerable and will thus reflect the current state of the node's adjacency.
            Note that changes to the graph structure during the traversal should be carried out with great care.
            Note that self-loop edges are reported twice (as in edge and as out edge).
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.FirstInEdge">
      <summary>
            The first incoming edge at this node, or <see langword="null" /> if it does
            not exist.
            </summary>
      <remarks>
            Returns the first incoming edge at this node, or <see langword="null" /> if it does
            not exist.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.FirstOutEdge">
      <summary>
            The first outgoing edge at this node, or <see langword="null" /> if it does
            not exist.
            </summary>
      <remarks>
            Returns the first outgoing edge at this node, or <see langword="null" /> if it does
            not exist.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetEdge(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns an edge that connects this node with the given node, if such an edge
            exists.
            </summary>
      <remarks>
            Returns an edge that connects this node with the given node, if such an edge
            exists.
            Otherwise <see langword="null" /> is returned.
            <p />
            Note that the first matching edge is returned, and that outgoing edges are
            tested prior to incoming edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetEdgeCursor">
      <summary>Returns an edge cursor for all incoming and outgoing edges at this node.</summary>
      <remarks>Returns an edge cursor for all incoming and outgoing edges at this node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetEdgeFrom(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns an incoming edge that connects the given node with this node, if such
            an edge exists.
            </summary>
      <remarks>
            Returns an incoming edge that connects the given node with this node, if such
            an edge exists.
            Otherwise <see langword="null" /> is returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetEdgeTo(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns an outgoing edge that connects this node with the given node, if such
            an edge exists.
            </summary>
      <remarks>
            Returns an outgoing edge that connects this node with the given node, if such
            an edge exists.
            Otherwise <see langword="null" /> is returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetInEdgeCursor">
      <summary>Returns an edge cursor for all incoming edges at this node.</summary>
      <remarks>Returns an edge cursor for all incoming edges at this node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetInEdgeCursor(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns an edge cursor for incoming edges at this node.</summary>
      <param name="startEdge">
            
            The first edge being accessed by the returned cursor.
            </param>
      <remarks>
            Returns an edge cursor for incoming edges at this node.
            The cursor starts at the given edge, and the cyclic sequence order is the same
            as returned by
            <see cref="M:yWorks.yFiles.Algorithms.Node.GetInEdgeCursor" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetNeighborCursor">
      <summary>Returns a node cursor for all neighbor nodes of this node.</summary>
      <remarks>
            Returns a node cursor for all neighbor nodes of this node.
            Neighbor nodes are those at the opposite ends of both incoming and outgoing
            edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetOutEdgeCursor">
      <summary>Returns an edge cursor for all outgoing edges at this node.</summary>
      <remarks>Returns an edge cursor for all outgoing edges at this node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetOutEdgeCursor(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns an edge cursor for outgoing edges at this node.</summary>
      <param name="startEdge">
            
            The first edge being accessed by the returned cursor.
            </param>
      <remarks>
            Returns an edge cursor for outgoing edges at this node.
            The cursor starts at the given edge, and the cyclic sequence order is the same
            as returned by
            <see cref="M:yWorks.yFiles.Algorithms.Node.GetOutEdgeCursor" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetPredecessorCursor">
      <summary>Returns a node cursor for all predecessor nodes of this node.</summary>
      <remarks>
            Returns a node cursor for all predecessor nodes of this node.
            Predecessor nodes are those at the opposite ends of incoming edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.GetSuccessorCursor">
      <summary>Returns a node cursor for all successor nodes of this node.</summary>
      <remarks>
            Returns a node cursor for all successor nodes of this node.
            Successor nodes are those at the opposite ends of outgoing edges.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Graph">
      <summary>The graph this node belongs to.</summary>
      <remarks>
            Returns the graph this node belongs to.
            If the node does not belong to a graph, because it was removed or hidden from
            it, this method returns <see langword="null" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.InDegree">
      <summary>The number of incoming edges at this node.</summary>
      <remarks>Returns the number of incoming edges at this node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Index">
      <summary>The index of this node within its graph G.</summary>
      <remarks>
            Returns the index of this node within its graph G.
            Node indices represent the ordering of standard node iteration on G.
            The value of an index is <c> &gt;= 0</c> and <c> &lt; G.nodeCount()</c>.
            <p />
            Note that indices are subject to change whenever the sequence of nodes in a
            graph is modified by either removing, hiding, reinserting, or unhiding a node,
            or by explicitly changing its position in the sequence.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.InEdges">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" />
            for <see cref="T:yWorks.yFiles.Algorithms.Edge" />s that can be used to iterate over ingoing edges at this instance.
            </summary>
      <remarks>
            This is a live enumerable and will thus reflect the current state of the node's adjacency.
            Note that changes to the graph structure during the traversal should be carried out with great care.
            Note that self-loop edges are reported, too.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.LastInEdge">
      <summary>
            The last incoming edge at this node, or <see langword="null" /> if it does
            not exist.
            </summary>
      <remarks>
            Returns the last incoming edge at this node, or <see langword="null" /> if it does
            not exist.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.LastOutEdge">
      <summary>
            The last outgoing edge at this node, or <see langword="null" /> if it does
            not exist.
            </summary>
      <remarks>
            Returns the last outgoing edge at this node, or <see langword="null" /> if it does
            not exist.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Neighbors">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" />
            for <see cref="T:yWorks.yFiles.Algorithms.Node" />s that can be used to iterate over the opposite sides of adjacent adjacent edges at this instance.
            </summary>
      <remarks>
            This is a live enumerable and will thus reflect the current state of the node's adjacency.
            Note that changes to the graph structure during the traversal should be carried out with great care.
            Note that for self-loop edges this node itself will be reported as a neighbor, twice.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.OutDegree">
      <summary>The number of outgoing edges at this node.</summary>
      <remarks>Returns the number of outgoing edges at this node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.OutEdges">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" />
            for <see cref="T:yWorks.yFiles.Algorithms.Edge" />s that can be used to iterate over outgoing edges at this instance.
            </summary>
      <remarks>
            This is a live enumerable and will thus reflect the current state of the node's adjacency.
            Note that changes to the graph structure during the traversal should be carried out with great care.
            Note that self-loop edges are reported, too.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Predecessors">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" />
            for <see cref="T:yWorks.yFiles.Algorithms.Node" />s that can be used to iterate over the opposite sides of adjacent incoming edges at this instance.
            </summary>
      <remarks>
            This is a live enumerable and will thus reflect the current state of the node's adjacency.
            Note that changes to the graph structure during the traversal should be carried out with great care.
            Note that for self-loop edges this node itself will be reported as a predecessor.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.SortInEdges(System.Collections.IComparer)">
      <summary>Sorts incoming edges at this node according to the given comparator.</summary>
      <remarks>Sorts incoming edges at this node according to the given comparator.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">
      <summary>Sorts outgoing edges at this node according to the given comparator.</summary>
      <remarks>Sorts outgoing edges at this node according to the given comparator.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Node.Successors">
      <summary>
            Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" />
            for <see cref="T:yWorks.yFiles.Algorithms.Node" />s that can be used to iterate over the opposite sides of adjacent outgoing edges at this instance.
            </summary>
      <remarks>
            This is a live enumerable and will thus reflect the current state of the node's adjacency.
            Note that changes to the graph structure during the traversal should be carried out with great care.
            Note that for self-loop edges this node itself will be reported as a successor.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Node.ToString">
      <summary>Returns a String representation of this node.</summary>
      <remarks>Returns a String representation of this node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.NodeList">
      <summary>
            Specialized list implementation for instances of type
            <see cref="T:yWorks.yFiles.Algorithms.Node" />
            .
            </summary>
      <remarks>
            Specialized list implementation for instances of type
            <see cref="T:yWorks.yFiles.Algorithms.Node" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor">
      <summary>Creates an empty node list.</summary>
      <remarks>Creates an empty node list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Algorithms.INodeCursor)">
      <summary>
            Creates a list that is initialized with the nodes provided by the given NodeCursor
            object.
            </summary>
      <remarks>
            Creates a list that is initialized with the nodes provided by the given NodeCursor
            object.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Algorithms.INodeCursor,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Creates a list that is initialized with those nodes from the given NodeCursor
            object for which the given data provider returns <see langword="true" /> upon
            calling its
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method.
            </summary>
      <param name="nc">
            
            A node cursor providing nodes that should be added to this list.
            </param>
      <param name="predicate">
            
            A data provider that acts as a inclusion predicate for each node accessible
            by the given node cursor.
            </param>
      <remarks>
            Creates a list that is initialized with those nodes from the given NodeCursor
            object for which the given data provider returns <see langword="true" /> upon
            calling its
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Algorithms.Node)">
      <summary>Creates a list that is initialized with a single node provided.</summary>
      <remarks>Creates a list that is initialized with a single node provided.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Algorithms.Node[])">
      <summary>
            Creates a list that is initialized with the nodes provided by the given array
            of nodes.
            </summary>
      <remarks>
            Creates a list that is initialized with the nodes provided by the given array
            of nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Algorithms.NodeList)">
      <summary>Creates a list that is initialized with the entries of the given list.</summary>
      <param name="list">the values are added to the new list</param>
      <remarks>Creates a list that is initialized with the entries of the given list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.#ctor(yWorks.yFiles.Util.IIterator)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            Iterator object.
            </summary>
      <remarks>
            Creates a list that is initialized with the elements provided by the given
            Iterator object.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.FirstNode">
      <summary>
            Returns the first node in this list, or <see langword="null" /> when the list is
            empty.
            </summary>
      <returns>
            
            The first node in the list.
            </returns>
      <remarks>
            Returns the first node in this list, or <see langword="null" /> when the list is
            empty.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.GetEnumerator" />
    <member name="M:yWorks.yFiles.Algorithms.NodeList.LastNode">
      <summary>Returns the last node in this list, or <see langword="null" /> when the list is empty.</summary>
      <returns>
            
            The last node in the list.
            </returns>
      <remarks>Returns the last node in this list, or <see langword="null" /> when the list is empty.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.Nodes">
      <summary>Returns a node cursor for this node list.</summary>
      <returns>
            
            A node cursor granting access to the nodes within this list.
            </returns>
      <remarks>Returns a node cursor for this node list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.PopNode">
      <summary>Removes the first node from this list and returns it.</summary>
      <returns>
            
            The first node from the list.
            </returns>
      <remarks>Removes the first node from this list and returns it.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeList.ToNodeArray">
      <summary>
            Returns a node array containing all elements of this list in the canonical
            order.
            </summary>
      <remarks>
            Returns a node array containing all elements of this list in the canonical
            order.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.NodeOrders">
      <summary>
            Provides graph algorithms that order the nodes of a graph
            by a specific criterion.
            </summary>
      <remarks>
            Provides graph algorithms that order the nodes of a graph
            by a specific criterion.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.NodeOrders" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.DfsCompletion(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.NodeOrders.DfsCompletion(yWorks.yFiles.Algorithms.Graph,System.Int32[])" />
            but the result is returned
            as a NodeList.
            </summary>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.NodeOrders.DfsCompletion(yWorks.yFiles.Algorithms.Graph,System.Int32[])" />
            but the result is returned
            as a NodeList.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.DfsCompletion(yWorks.yFiles.Algorithms.Graph,System.Int32[])">
      <summary>
            This method calculates a node order that is identical with
            the order of node completion events in a depth first search.
            </summary>
      <remarks>
            This method calculates a node order that is identical with
            the order of node completion events in a depth first search.
            This order is a reversed topological order in case the input graph
            is acyclic.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph,System.Int32[])" />
            but the result is returned as
            a NodeList.
            </summary>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph,System.Int32[])" />
            but the result is returned as
            a NodeList.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph,System.Int32[])">
      <summary>Assigns an ST-order to the nodes of a biconnected graph.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="stOrder">
            result value that holds for each node <c>v</c> the
            zero-based index within the calculated order,
            i.e <c>stOrder[v.index()] == 5</c>
            means that <c>v</c> is the 6-th node within the order.
            </param>
      <remarks>
            Assigns an ST-order to the nodes of a biconnected graph.
            An ST order <c>(v_1,v_2,....,v_n)</c> for a biconnected graph
            is a node order which guarantees that
            <ol>
            <li>the first node <c>S</c> and the last node <c>T</c>
            are connected by an edge.</li>
            <li>For each node <c>v_i</c> in the order that
            are not <c>S</c> or <c>T</c> there are
            neighbors <c>v_j</c> and <c>v_k</c> with
            <c>j &lt; i</c> and <c>k &gt; i</c>.</li>
            </ol>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph,System.Int32[],yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph,System.Int32[])" />
            .
            </summary>
      <param name="stEdge">an edge that connects the first node of the ordering with the last node of the ordering.</param>
      <remarks>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.NodeOrders.St(yWorks.yFiles.Algorithms.Graph,System.Int32[])" />
            . Additionally, the edge between the first node <c>S</c> and
            the last node <c>T</c> of the returned ordering can be specified.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.ToNodeList(yWorks.yFiles.Algorithms.Graph,System.Int32[])">
      <summary>
            Converts an array-based result yield by a method of this class
            to a NodeList that contains all nodes of the order in the
            correct sequence.
            </summary>
      <remarks>
            Converts an array-based result yield by a method of this class
            to a NodeList that contains all nodes of the order in the
            correct sequence.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.ToNodeMap(yWorks.yFiles.Algorithms.Graph,System.Int32[],yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Copies an array-based result yield by a method of this class
            to a NodeMap that will provide values of basic type <c>int</c>.
            </summary>
      <remarks>
            Copies an array-based result yield by a method of this class
            to a NodeMap that will provide values of basic type <c>int</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.ToNodeMap(yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Copies a list-based result yield by a method of this class
            to a NodeMap.
            </summary>
      <remarks>
            Copies a list-based result yield by a method of this class
            to a NodeMap. The resulting NodeMap will provide for each node
            the index of the node within the given order. The index is of basic type
            <c>int</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.Topological(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns a topological node order of an acyclic graph.</summary>
      <remarks>Returns a topological node order of an acyclic graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.NodeOrders.Topological(yWorks.yFiles.Algorithms.Graph,System.Int32[])">
      <summary>Assigns a topological order to the nodes of an acyclic graph.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="order">
            result value that holds for each node <c>v</c> the
            zero-based index within the calculated order,
            i.e <c>topOrder[v.index()] == 5</c>
            means that <c>v</c> is the 6-th node within the order.
            </param>
      <remarks>
            Assigns a topological order to the nodes of an acyclic graph.
            <p />
            If the given graph is not acyclic then this method returns <see langword="false" />
            leaving the contents of result <c>topOrder</c> unspecified.
            <p />
            A topological node order of an acyclic graph has the property that for
            each node <c>v</c> all of its successors have a higher rank in the order
            than <c>v</c> itself.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Paths">
      <summary>
            Responsible for finding paths within a graph that have
            certain properties.
            </summary>
      <remarks>
            Responsible for finding paths within a graph that have
            certain properties.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Paths" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.ConstructNodePath(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Constructs a node path from a given edge path.</summary>
      <remarks>
            Constructs a node path from a given edge path. The returned node path
            has length <c>path.size()+1</c>, if the given path is not empty.
            Otherwise the returned path will be empty. The i-th node in the
            returned path will be either source or target node of the i-th edge
            in the given path.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindAllChains(yWorks.yFiles.Algorithms.Graph,System.Boolean)">
      <summary>Returns all chains present in the given graph.</summary>
      <param name="graph">the input graph</param>
      <returns>
            an array of EdgeList objects, each of which has at least length 2.
            An edge list contains the edges that make up a chain. Method
            <see cref="M:yWorks.yFiles.Algorithms.Paths.ConstructNodePath(yWorks.yFiles.Algorithms.EdgeList)" />
            can be used to convert an edge path
            to a node path.
            </returns>
      <remarks>
            Returns all chains present in the given graph. A chain in a graph is
            a paths of maximal length, where each internal node on the path has degree 2.
            The internal nodes on directed chains all have in-degree 1 and out-degree 1.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindAllPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>Returns all simple directed or undirected paths that connect <c>start</c> with <c>end</c> node.</summary>
      <param name="graph">the input graph</param>
      <param name="startNode">the start node</param>
      <param name="endNode">the end node</param>
      <param name="directed">whether or not to consider the edges in the graph to be directed or not.</param>
      <returns>an array of EdgeLists each representing a path between start and end node.</returns>
      <remarks>
            Returns all simple directed or undirected paths that connect <c>start</c> with <c>end</c> node.
            One should note that the number of different paths connecting two nodes can be exponential
            in number of nodes and edges of a given graph. This said, even for small graphs the runtime and memory
            consumption of the algorithm can be excessive. To significantly lower memory consumption use
            <see cref="M:yWorks.yFiles.Algorithms.Paths.FindAllPathsCursor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean)" />
            instead.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindAllPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Predicate{yWorks.yFiles.Algorithms.EdgeList})">
      <summary>
            A variant of
            <see cref="M:yWorks.yFiles.Algorithms.Paths.FindAllPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean)" />
            
            that additionally allows to specify a filter for the paths to be returned.
            </summary>
      <param name="filter">a filter that tests for each found EdgeList if it should make it to the result list.</param>
      <remarks>
            A variant of
            <see cref="M:yWorks.yFiles.Algorithms.Paths.FindAllPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean)" />
            
            that additionally allows to specify a filter for the paths to be returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindAllPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Marks all edges that belong to a directed path from <c>start</c> to <c>end</c> node.</summary>
      <param name="g">the input graph</param>
      <param name="start">the start node</param>
      <param name="end">the end node</param>
      <param name="pathEdges">
            the result. For each edge a boolean value will indicate whether or not
            it belongs to a path connecting the two nodes.
            </param>
      <remarks>Marks all edges that belong to a directed path from <c>start</c> to <c>end</c> node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindAllPathsCursor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            A variant of
            <see cref="M:yWorks.yFiles.Algorithms.Paths.FindAllPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean)" />
            
            that returns its result not as a list but as a special cursor that calculates
            the next path in the sequence only when needed.
            </summary>
      <remarks>
            A variant of
            <see cref="M:yWorks.yFiles.Algorithms.Paths.FindAllPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean)" />
            
            that returns its result not as a list but as a special cursor that calculates
            the next path in the sequence only when needed.
            The returned cursor only supports the operation
            <see cref="P:yWorks.yFiles.Algorithms.ICursor.Ok" />
            ,
            <see cref="P:yWorks.yFiles.Algorithms.ICursor.Current" />
            ,
            <see cref="P:yWorks.yFiles.Algorithms.ICursor.Size" />
            and
            <see cref="M:yWorks.yFiles.Algorithms.ICursor.Next" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindLongestPath(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns the longest directed path within the given acyclic graph.</summary>
      <param name="g">a directed acyclic graph</param>
      <returns>
            an edge list representing the longest directed path within
            the given graph
            </returns>
      <remarks>Returns the longest directed path within the given acyclic graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindLongestPath(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns the longest directed path within a given acyclic weighted
            graph.
            </summary>
      <param name="g">a directed acyclic graph</param>
      <param name="edgeLength">
            a data provider that must provide the length of each
            edge as an int value
            </param>
      <returns>
            an edge list representing the longest directed path within
            the given graph
            </returns>
      <remarks>
            Returns the longest directed path within a given acyclic weighted
            graph.
            All edges of the graph have an  integral length associated
            with them. The longest path is defined as one of all
            directed paths within the graph for which the edge lengths
            of all contained edges sum up to a maximum.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindLongestPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            Calculates the longest path from one vertex to all other vertices
            in a given acyclic graph
            </summary>
      <param name="g">a directed acyclic graph.</param>
      <param name="startNode">the node, for which the distances are calculated.</param>
      <param name="dist">the distances for the edges.</param>
      <param name="maxDist">here the result will be stored.</param>
      <param name="predicate">only edges for which predicate is true are considered.</param>
      <remarks>
            Calculates the longest path from one vertex to all other vertices
            in a given acyclic graph
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindLongPath(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns an edge list that contains the edges of a
            undirected simple path within the given graph.
            </summary>
      <remarks>
            Returns an edge list that contains the edges of a
            undirected simple path within the given graph.
            The edges are returned in the order they appear in the found path.
            <p />
            A heuristic is used to find a path that is long.
            It is not guaranteed though that the returned path is
            actually the longest path within the given graph, since that is
            a well known hard to solve problem.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindPath(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Returns an edge list that contains the edges of a path
            from the given start node to the given end node,
            if such a path exists.
            </summary>
      <param name="graph">the input graph</param>
      <param name="startNode">the first node of the path</param>
      <param name="endNode">the last node of the path</param>
      <param name="directed">whether to search for a directed or undirected path</param>
      <remarks>
            Returns an edge list that contains the edges of a path
            from the given start node to the given end node,
            if such a path exists.
            The edges are returned in the
            order they appear in the found path.
            <p />If the returned path is empty then no path between the
            given nodes was found.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Paths.FindPath(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            Returns whether or not there is a directed path from one node to another node
            in an acyclic graph
            </summary>
      <param name="g">the acyclic graph which contains the two nodes.</param>
      <param name="topSort">a topological sorting of the nodes of the graph.</param>
      <param name="predicate">only edges for which predicate is true are considered.</param>
      <remarks>
            Returns whether or not there is a directed path from one node to another node
            in an acyclic graph
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.RankAssignments">
      <summary>Provides algorithms for solving the rank assignment problem.</summary>
      <remarks>
            Provides algorithms for solving the rank assignment problem.
            <p />
            Let G=(V,E) be a directed acyclic graph. Let length(e) denote
            the minimal length and weight(e) the weight of an
            edge e.
            The rank assignment problem is to find values x(v) for all
            v in V, such that x(v) - x(w) &gt;= length(v,w) for all (v,w) in E,
            and that the sum weight(v,w)*(x(v)-x(w)) over all (v,w) in E
            is minimal.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.RankAssignments" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simple(yWorks.yFiles.Algorithms.Graph,System.Int32[],System.Int32[])">
      <summary>
            This method quickly calculates a tight tree
            using a highly optimized version of Gansner's algorithm .
            </summary>
      <param name="g">
            the graph, where all the edges have directions, such that
            rank[source] &lt; rank[target] and rank[target] - rank[source] &gt;= minlength[edge]
            </param>
      <param name="rank">the initial ranking</param>
      <param name="minLength">
            the minimal (tight) lengths for each edge. Values must be
            non-negative.
            </param>
      <returns>the number of layers.</returns>
      <remarks>
            This method quickly calculates a tight tree
            using a highly optimized version of Gansner's algorithm .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simple(yWorks.yFiles.Algorithms.Graph,System.Int32[],System.Int32[],System.Int64)">
      <summary>
            This method quickly calculates a tight tree
            using a highly optimized version of Gansner's algorithm .
            </summary>
      <param name="g">
            the graph, where all the edges have directions, such that
            rank[source] &lt; rank[target] and rank[target] - rank[source] &gt;= minlength[edge]
            </param>
      <param name="rank">the initial ranking</param>
      <param name="minLength">
            the minimal (tight) lengths for each edge. Values must be
            non-negative.
            </param>
      <param name="maximalDuration">a preferred time limit for the algorithm in milliseconds.</param>
      <returns>the number of layers.</returns>
      <remarks>
            This method quickly calculates a tight tree
            using a highly optimized version of Gansner's algorithm .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simple(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>
            This method quickly calculates a tight tree
            using a highly optimized version of Gansner's algorithm .
            </summary>
      <param name="g">
            the graph, where all the edges have directions, such that
            rank[source] &lt; rank[target] and rank[target] - rank[source] &gt;= minlength[edge]
            </param>
      <param name="rank">the initial ranking</param>
      <param name="minLength">
            the minimal (tight) lengths for each edge. Values must be
            non-negative.
            </param>
      <returns>the number of layers.</returns>
      <remarks>
            This method quickly calculates a tight tree
            using a highly optimized version of Gansner's algorithm .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simple(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap,System.Int64)">
      <summary>
            This method quickly calculates a tight tree
            using a highly optimized version of Gansner's algorithm .
            </summary>
      <param name="g">
            the graph, where all the edges have directions, such that
            rank[source] &lt; rank[target] and rank[target] - rank[source] &gt;= minlength[edge]
            </param>
      <param name="rank">the initial ranking</param>
      <param name="minLength">
            the minimal (tight) lengths for each edge. Values must be
            non-negative.
            </param>
      <param name="maximalDuration">a preferred time limit for the algorithm in milliseconds.</param>
      <returns>the number of layers.</returns>
      <remarks>
            This method quickly calculates a tight tree
            using a highly optimized version of Gansner's algorithm .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Solves the rank assignment problem using the simplex method.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the ranking is stored.</param>
      <param name="w">here the weight of an edge is stored.</param>
      <param name="minLength">here the minimal length of an edge is stored.</param>
      <returns>the number of layers</returns>
      <remarks>
            Solves the rank assignment problem using the simplex method.
            This method assigns a minimal rank to the nodes in a acyclic graph.
            Although its time complexity has not been proven polynomial, in practice
            it takes few iterations and runs quickly.
            <p />
            The algorithm is based on:
            <p />
            E.R. Gansner et al, <i>A Technique for Drawing Directed Graphs</i>,
            IEEE Transactions on Software Engineering, Vol.19, No.3,
            March 1993,
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,System.Int64)">
      <summary>Solves the rank assignment problem using the simplex method.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the ranking is stored.</param>
      <param name="w">here the weight of an edge is stored.</param>
      <param name="minLength">here the minimal length of an edge is stored.</param>
      <param name="maximalDuration">a preferred time limit for the algorithm in milliseconds.</param>
      <returns>the number of layers</returns>
      <remarks>
            Solves the rank assignment problem using the simplex method.
            This method assigns a minimal rank to the nodes in a acyclic graph.
            Although its time complexity has not been proven polynomial, in practice
            it takes few iterations and runs quickly.
            <p />
            The algorithm is based on:
            <p />
            E.R. Gansner et al, <i>A Technique for Drawing Directed Graphs</i>,
            IEEE Transactions on Software Engineering, Vol.19, No.3,
            March 1993,
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            </summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the ranking is stored.</param>
      <param name="w">here the weight of an edge is stored.</param>
      <param name="minLength">here the minimal length of an edge is stored.</param>
      <param name="validRanking">
            if <see langword="true" />, the argument
            <c>layer</c> contains a valid ranking.
            </param>
      <param name="tree">may contain a valid tree solution.</param>
      <param name="_root">the root of the tree solution.</param>
      <returns>the number of layers</returns>
      <remarks>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)" />
            . Additionally
            it is possible to provide a valid initial tree solution for the problem.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Int64)">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            </summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the ranking is stored.</param>
      <param name="w">here the weight of an edge is stored.</param>
      <param name="minLength">here the minimal length of an edge is stored.</param>
      <param name="validRanking">
            if <see langword="true" />, the argument
            <c>layer</c> contains a valid ranking.
            </param>
      <param name="tree">may contain a valid tree solution.</param>
      <param name="_root">the root of the tree solution.</param>
      <param name="maximalDuration">a preferred time limit for the algorithm in milliseconds.</param>
      <returns>the number of layers</returns>
      <remarks>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.RankAssignments.Simplex(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)" />
            . Additionally
            it is possible to provide a valid initial tree solution for the problem.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.ShortestPaths">
      <summary>
            Provides diverse algorithms and helper methods for solving the shortest path problem
            on weighted graphs.
            </summary>
      <remarks>
            Provides diverse algorithms and helper methods for solving the shortest path problem
            on weighted graphs.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Double[],System.Double[])">
      <summary>This method solves the single-source shortest path problem for <b>acyclic</b> directed graphs.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the start node for the shortest path search</param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="dist">
            return value that will hold the shortest distance from node <c>s</c> to
            all other nodes. The distance from <c>s</c> to <c>v</c> is
            <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>
            then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
      <returns>
        <see langword="false" /> if the input graph was not acyclic.</returns>
      <remarks>
            This method solves the single-source shortest path problem for <b>acyclic</b> directed graphs.
            Associated with each edge is an arbitrary double value that represents the cost of that edge.
            This method yields the shortest distance from a given node <c>s</c> to all other nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Double[],System.Double[])" />
            but additionally this method
            yields the path edges of each calculated shortest path.
            </summary>
      <param name="pred">
            return value that holds for each node <c>t</c> the shortest
            path edge <c>pred[t.index()]</c> which is the last edge on the shortest
            path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there
            is no shortest path from <c>s</c> to <c>t</c> then
            <c>pred[t.index()] == null</c>.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Double[],System.Double[])" />
            but additionally this method
            yields the path edges of each calculated shortest path.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but uses NodeMaps and DataProviders instead of arrays.
            </summary>
      <param name="cost">must provide a double value for each edge.</param>
      <param name="dist">return value. the map will provide a double value for each node.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Acyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but uses NodeMaps and DataProviders instead of arrays.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.AllPairs(yWorks.yFiles.Algorithms.Graph,System.Boolean,System.Double[],System.Double[][])">
      <summary>
            This method solves the all-pairs shortest path problem for graphs with arbitrary
            edge costs.
            </summary>
      <param name="graph">the graph being acted upon</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="dist">
            return value that will hold the shortest path distances from all pairs of
            nodes <c>s</c> and <c>t</c> in the graph.
            The distance from <c>s</c> to <c>t</c> is
            <c>dist[s.index()][t.index()]</c>. If there is no path from <c>s</c> to <c>t</c>
            then <c>dist[s.index()][t.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
      <returns>whether or not the given graph contains a negative cost cycle.</returns>
      <remarks>
            This method solves the all-pairs shortest path problem for graphs with arbitrary
            edge costs. If the given graph contains a negative cost cycle, then <see langword="false" /> is
            returned and the values returned in <c>dist</c> are left unspecified.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])">
      <summary>This method solves the single-source shortest path problem for arbitrary graphs.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the start node for the shortest path search</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="dist">
            return value that will hold the shortest distance from node <c>s</c> to
            all other nodes. The distance from <c>s</c> to <c>v</c> is
            <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>
            then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
      <returns>
        <see langword="false" /> if this weighted graph contains a negative cost cycle,
            <see langword="true" /> otherwise.
            </returns>
      <remarks>
            This method solves the single-source shortest path problem for arbitrary graphs.
            Associated with each edge is an arbitrary double value that represents
            the cost of that edge. In case the given weighted graph contains no <b>negative cost cycles</b>
            this method will yield the shortest distance from a given node <c>s</c> to all other nodes.
            If, on the other hand, the given graph contains negative-cost cycles this method will yield
            no reasonable result which will be indicated by the return value <see langword="false" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])" />
            but additionally this method
            yields the path edges of each calculated shortest path.
            </summary>
      <param name="pred">
            return value that holds for each node <c>t</c> the shortest
            path edge <c>pred[t.index()]</c> which is the last edge on the shortest
            path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there
            is no shortest path from <c>s</c> to <c>t</c> then
            <c>pred[t.index()] == null</c>.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])" />
            but additionally this method
            yields the path edges of each calculated shortest path.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but uses NodeMaps and DataProviders instead of arrays.
            </summary>
      <param name="cost">must provide a double value for each edge.</param>
      <param name="dist">return value. the map will provide a double value for each node.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.BellmanFord(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but uses NodeMaps and DataProviders instead of arrays.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Convenience method that constructs an explicit edge path from the
            result yielded by one of the shortest paths methods defined in this class.
            </summary>
      <param name="s">
            the start node of the shortest path. This must be the
            same start node that was specified when <c>pred</c> was calculated.
            </param>
      <param name="t">the end node of the path</param>
      <param name="pred">
            the shortest path edge result array returned by one of the
            shortest path edge methods defined in this class.
            </param>
      <returns>
            an edge list that holds the edges on the shortest path
            from <c>s</c> to <c>t</c> in the correct order. If there
            is no path from <c>s</c> to <c>t</c> then an empty
            list is returned.
            </returns>
      <remarks>
            Convenience method that constructs an explicit edge path from the
            result yielded by one of the shortest paths methods defined in this class.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge[])" />
            with the difference that
            the path edges are given by a DataProvider.
            </summary>
      <param name="pred">
            the shortest path edge result DataProvider returned by one of the
            shortest path edge methods defined in this class.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge[])" />
            with the difference that
            the path edges are given by a DataProvider.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructNodePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Convenience method that constructs an explicit node path from the
            result yielded by one of the shortest paths methods defined in this class.
            </summary>
      <param name="s">
            the start node of the shortest path. This must be the
            same start node that was specified when <c>pred</c> was calculated.
            </param>
      <param name="t">the end node of the path</param>
      <param name="pred">
            the shortest path edge result array returned by one of the
            shortest path edge methods defined in this class.
            </param>
      <returns>
            a node list that holds the nodes on the shortest path
            from <c>s</c> to <c>t</c> in the correct order. If there
            is no path from <c>s</c> to <c>t</c> then an empty
            list is returned.
            </returns>
      <remarks>
            Convenience method that constructs an explicit node path from the
            result yielded by one of the shortest paths methods defined in this class.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructNodePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructNodePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge[])" />
            with the difference that
            the path edges are given by a DataProvider.
            </summary>
      <param name="pred">
            the shortest path edge result DataProvider returned by one of the
            shortest path edge methods defined in this class.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.ConstructNodePath(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge[])" />
            with the difference that
            the path edges are given by a DataProvider.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])">
      <summary>This method solves the single-source shortest path problem for arbitrary graphs.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the start node for the shortest path search</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="dist">
            return value that will hold the shortest distance from node <c>s</c> to
            all other nodes. The distance from <c>s</c> to <c>v</c> is
            <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>
            then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
      <remarks>
            This method solves the single-source shortest path problem for arbitrary graphs.
            Associated with each edge is a <b>non-negative</b> double value that represents
            the cost of that edge.
            This method yields the shortest distance from a given node <c>s</c> to all other nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])" />
            but additionally this method
            yields the path edges of each calculated shortest path.
            </summary>
      <param name="pred">
            return value that holds for each node <c>t</c> the shortest
            path edge <c>pred[t.index()]</c> which is the last edge on the shortest
            path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there
            is no shortest path from <c>s</c> to <c>t</c> then
            <c>pred[t.index()] == null</c>.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])" />
            but additionally this method
            yields the path edges of each calculated shortest path.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but uses NodeMaps and DataProviders instead of arrays.
            </summary>
      <param name="cost">must provide a double value for each edge.</param>
      <param name="dist">return value. the map will provide a double value for each node.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Dijkstra(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but uses NodeMaps and DataProviders instead of arrays.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.FindShortestUniformPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,System.Boolean,System.Int32,yWorks.yFiles.Algorithms.EdgeList,yWorks.yFiles.Algorithms.NodeList)">
      <summary>
            Finds all nodes and edges that belong to a shortest path from <c>start</c> to a set of target nodes in the graph not
            farther away than a given distance.
            </summary>
      <param name="graph">the input graph</param>
      <param name="start">the start node</param>
      <param name="targetMap">
            a boolean data provider that marks the target nodes. If the data provider is <see langword="null" />
            all nodes in the graph are assumed to be target nodes.
            </param>
      <param name="directed">whether or not to work on directed edges</param>
      <param name="maxLength">
            the maximum edge length of the shortest paths. Shortest paths
            that are longer than this value will not be considered.
            </param>
      <param name="pathEdges">
            a return value. If this parameter is not null, this algorithm first clears the list and then adds
            all edges that belong to the detected shortest paths.
            </param>
      <param name="pathNodes">
            a return value. If this parameter is not null, this algorithm first clears the list and then adds
            all nodes that belong to the detected shortest paths.
            </param>
      <remarks>
            Finds all nodes and edges that belong to a shortest path from <c>start</c> to a set of target nodes in the graph not
            farther away than a given distance.
            This method assumes that each edge of the input graph has a <b>cost of 1.0</b>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.FindShortestUniformPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Marks all edges that belong to a shortest path from <c>start</c> to <c>end</c> node.</summary>
      <param name="graph">the input graph</param>
      <param name="start">the start node</param>
      <param name="end">the end node</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="pathMap">
            the result. For each edge a boolean value will indicate whether or not
            it belongs to a shortest path connecting the two nodes.
            </param>
      <remarks>
            Marks all edges that belong to a shortest path from <c>start</c> to <c>end</c> node.
            This method assumes that each edge of the input graph has a <b>cost of 1.0</b>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.KShortestPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>
            This method finds the <c>k</c> shortest paths
            connecting a pair of nodes in a directed graph with non-negative edge costs.
            </summary>
      <param name="graph">the graph being acted upon</param>
      <param name="costDP">
            a data provider that provides a double-valued cost for each edge
            of the input graph.
            </param>
      <param name="start">start node of the shortest paths</param>
      <param name="end">the end node of the shortest paths</param>
      <param name="k" />
      <returns>
            a list of EdgeList objects each of which representing a path from
            <c>start</c> to <c>end</c> node. The i-th path in the
            list contains the i-th shortest path between <c>start</c> and <c>end</c>
            node. Note that the returned list may contain less than <c>k</c> paths in case
            there are fewer directed paths between start and end node.
            </returns>
      <remarks>
            This method finds the <c>k</c> shortest paths
            connecting a pair of nodes in a directed graph with non-negative edge costs.
            The result will be returned as a list of EdgeList objects.
            Note that the returned paths are not required to be simple, i.e. they may contain
            a node or an edge multiple times.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.KShortestPathsCursor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>
            A variant of
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.KShortestPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Int32)" />
            
            that returns its result not as a list but as a special cursor that calculates
            the next path in the sequence only when needed.
            </summary>
      <remarks>
            A variant of
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.KShortestPaths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Int32)" />
            
            that returns its result not as a list but as a special cursor that calculates
            the next path in the sequence only when needed.
            The returned cursor only supports the operation
            <see cref="P:yWorks.yFiles.Algorithms.ICursor.Ok" />
            ,
            <see cref="P:yWorks.yFiles.Algorithms.ICursor.Current" />
            and
            <see cref="M:yWorks.yFiles.Algorithms.ICursor.Next" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.ShortestPair(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns two edge-disjoint paths from in a nonnegatively-weighted directed graph, so that both paths connect
            <c>s</c> and <c>t</c> and have minimum total length.
            </summary>
      <param name="graph">the graph being acted upon</param>
      <param name="source">source node of the shortest pair</param>
      <param name="target">end node of the shortest pair</param>
      <param name="directed">whether or not to interpret the edges as directed or undirected</param>
      <param name="costDP">
            a data provider that provides a double-valued cost for each edge
            of the input graph.
            </param>
      <returns>
            a two-dimensional EdgeList array that holds the resulting edge-disjoint paths, or <see langword="null" /> if no such
            edge-disjoint paths exist.
            </returns>
      <remarks>
            Returns two edge-disjoint paths from in a nonnegatively-weighted directed graph, so that both paths connect
            <c>s</c> and <c>t</c> and have minimum total length.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])">
      <summary>This method solves the single-source shortest path problem for arbitrary graphs.</summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the start node for the shortest path search</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="dist">
            return value that will hold the shortest distance from node <c>s</c> to
            all other nodes. The distance from <c>s</c> to <c>v</c> is
            <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>
            then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
      <returns>
        <see langword="false" /> if this weighted graph contains a negative cost cycle,
            <see langword="true" /> otherwise.
            </returns>
      <remarks>
            This method solves the single-source shortest path problem for arbitrary graphs.
            Depending on the structure of the given graph and the values of the given edge costs it
            delegates its job to the algorithm with the theoretically best running time.
            Please note that theory does not necessarily reflect practice.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])" />
            but additionally this method
            yields the path edges of each calculated shortest path.
            </summary>
      <param name="pred">
            return value that holds for each node <c>t</c> the shortest
            path edge <c>pred[t.index()]</c> which is the last edge on the shortest
            path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there
            is no shortest path from <c>s</c> to <c>t</c> then
            <c>pred[t.index()] == null</c>.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[])" />
            but additionally this method
            yields the path edges of each calculated shortest path.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but uses NodeMaps and DataProviders instead of arrays.
            </summary>
      <param name="cost">must provide a double value for each edge.</param>
      <param name="dist">return value. the map will provide a double value for each node.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSource(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but uses NodeMaps and DataProviders instead of arrays.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[])">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but instead of returning the shortest distance between the source and sink
            the actual shortest edge path between these nodes will be returned.
            </summary>
      <returns>a shortest path between source and sink</returns>
      <remarks>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but instead of returning the shortest distance between the source and sink
            the actual shortest edge path between these nodes will be returned.
            If the returned path is empty then there is no path between the nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            This method solves the single-source single-sink shortest path problem
            for arbitrary graphs.
            </summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the source node for the shortest path search</param>
      <param name="t">the sink   node for the shortest path search</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="cost">
            holds the costs for traversing each edge. Edge <c>e</c>
            has cost <c>cost[e.index()]</c>.
            </param>
      <param name="pred">
            return value that holds for each node <c>v</c> on the
            the shortest the path from <c>s</c> to <c>t</c> an edge
            <c>pred[v.index()]</c> which is the last edge on
            the shortest path from <c>s</c> to <c>v</c>. If <c>v == s</c> or if there
            is no shortest path from <c>s</c> to <c>v</c> then
            <c>pred[v.index()] == null</c>.
            </param>
      <returns>
            the distance between <c>s</c> and <c>t</c> if a path between these two
            nodes exist and <c>Double.POSITIVE_INFINITY</c> otherwise.
            </returns>
      <remarks>
            This method solves the single-source single-sink shortest path problem
            for arbitrary graphs.
            Associated with each edge is a <b>non-negative</b> double value that represents
            the cost of that edge.
            This method returns the shortest distance from node <c>s</c> to node <c>t</c>.
            It also returns information to construct the actual path between these to nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap)" />
            
            but instead of returning the shortest distance between the source and sink
            the actual shortest edge path between these nodes will be returned.
            </summary>
      <returns>a shortest path between source and sink</returns>
      <remarks>
            Similar to
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap)" />
            
            but instead of returning the shortest distance between the source and sink
            the actual shortest edge path between these nodes will be returned.
            If the returned path is empty then there is no path between the nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but uses NodeMaps and DataProviders instead of arrays.
            </summary>
      <param name="cost">must provide a double value for each edge.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            
            but uses NodeMaps and DataProviders instead of arrays.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[])">
      <summary>
            This method solves the single-source shortest path problem for arbitrary graphs
            where each edge has a <b>uniform cost of 1.0</b>.
            </summary>
      <param name="graph">the graph being acted upon</param>
      <param name="s">the start node for the shortest path search</param>
      <param name="directed">
            whether or not to consider the graph as directed. If the graph is
            to be considered undirected then each edge can be traversed in both directions and
            the returned shortest paths can thus be undirected.
            </param>
      <param name="dist">
            return value that will hold the shortest distance from node <c>s</c> to
            all other nodes. The distance from <c>s</c> to <c>v</c> is
            <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>
            then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.
            </param>
      <remarks>
            This method solves the single-source shortest path problem for arbitrary graphs
            where each edge has a <b>uniform cost of 1.0</b>.
            This method yields the shortest distance from a given node <c>s</c> to all other nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[])" />
            but additionally this method
            yields the path edges of each calculated shortest path.
            </summary>
      <param name="pred">
            return value that holds for each node <c>t</c> the shortest
            path edge <c>pred[t.index()]</c> which is the last edge on the shortest
            path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there
            is no shortest path from <c>s</c> to <c>t</c> then
            <c>pred[t.index()] == null</c>.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[])" />
            but additionally this method
            yields the path edges of each calculated shortest path.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            but uses NodeMaps instead of
            arrays.
            </summary>
      <param name="dist">return value. the map will provide a double value for each node.</param>
      <param name="pred">return value. the map will provide an Edge for each node.</param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.ShortestPaths.Uniform(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,System.Double[],yWorks.yFiles.Algorithms.Edge[])" />
            but uses NodeMaps instead of
            arrays.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.ShortestPaths.UniformCost(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Convenience method that returns an array containing
            uniform edge costs of <c>1.0</c> for each edge
            of the given graph.
            </summary>
      <returns>
            an array <c>cost[]</c> that contains uniform
            edge costs of 1.0 for each edge <c>e: cost[e.index()] == 1.0</c>.
            </returns>
      <remarks>
            Convenience method that returns an array containing
            uniform edge costs of <c>1.0</c> for each edge
            of the given graph.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Sorting">
      <summary>
            This class provides methods for efficiently sorting graph elements in graph
            structures.
            </summary>
      <remarks>
            This class provides methods for efficiently sorting graph elements in graph
            structures.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Sorting.SortNodesByDegree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Sort nodes by degree in ascending order</summary>
      <remarks>Sort nodes by degree in ascending order</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Sorting.SortNodesByIntKey(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Sort nodes by an integer key associated to each node through the given data provider.</summary>
      <remarks>
            Sort nodes by an integer key associated to each node through the given data provider.
            The nodes are sorted in ascending order.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.SpanningTrees">
      <summary>Provides (minimum) spanning tree algorithms for graphs.</summary>
      <remarks>
            Provides (minimum) spanning tree algorithms for graphs.
            A spanning tree of an undirected connected graph is a subset of its edges
            that form a tree connecting all edges of the graph.
            If the edges of a graph have a cost or a weight associated with
            them then it is possible to calculate a minimum spanning tree of that graph,
            i.e. a spanning tree whose edges have minimum overall cost of all spanning
            trees of that graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.SpanningTrees" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.Cost(yWorks.yFiles.Algorithms.EdgeList,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns the overall cost of a previously calculated minimum
            spanning tree.
            </summary>
      <param name="treeEdges">edges that make up a minimum spanning tree.</param>
      <param name="edgeCost">
            a data provider that returns the double valued
            cost of each of the tree edges.
            </param>
      <returns>the overall cost of the tree edges.</returns>
      <remarks>
            Returns the overall cost of a previously calculated minimum
            spanning tree.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.Kruskal(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Calculates a minimum spanning tree for the given graph.</summary>
      <param name="graph">the input graph</param>
      <param name="cost">
            a data provider that must return a double value  for each
            edge in the graph.
            </param>
      <returns>
            a list that contains the edges that make up the minimum spanning
            tree.
            </returns>
      <remarks>
            Calculates a minimum spanning tree for the given graph. The implementation
            is based on an algorithm originally published in
            <p />
            J.B. Kruskal. On the shortest spanning subtree of a graph and the
            traveling salesman problem. <i>Proceedings of the American Mathematical
            Society</i>, pages 48-50, 1956.
            <p />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.Minimum(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Calculates a minimum spanning tree for the given graph using our
            favorite algorithm for that problem.
            </summary>
      <param name="graph">the input graph</param>
      <param name="cost">
            a data provider that must return a double value  for each
            edge in the graph.
            </param>
      <returns>
            a list that contains the edges that make up the minimum spanning
            tree.
            </returns>
      <remarks>
            Calculates a minimum spanning tree for the given graph using our
            favorite algorithm for that problem.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.Prim(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Calculates a minimum spanning tree for the given graph.</summary>
      <param name="graph">the input graph</param>
      <param name="cost">
            a data provider that must return a double value  for each
            edge in the graph.
            </param>
      <returns>
            a list that contains the edges that make up the minimum spanning
            tree.
            </returns>
      <remarks>
            Calculates a minimum spanning tree for the given graph. The implementation
            is based on an algorithm originally published in
            <p />
            R.C. Prim. Shortest connection networks and some generalizations.
            <i>Bell System Technical Journal</i>, 36:1389-1401, 1957.
            <p />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.SpanningTrees.Uniform(yWorks.yFiles.Algorithms.Graph)">
      <summary>Calculates a spanning tree for the given graph.</summary>
      <param name="graph">the input graph</param>
      <returns>
            a list that contains the edges that make up the minimum spanning
            tree.
            </returns>
      <remarks>
            Calculates a spanning tree for the given graph. Each edge has
            assumed uniform cost of 1.0.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Transitivity">
      <summary>
            Provides algorithms to compute reachability information for directed, acyclic
            graphs.
            </summary>
      <remarks>
            Provides algorithms to compute reachability information for directed, acyclic
            graphs. The following algorithms are available:
            <ul>
            <li>transitive closure</li>
            <li>transitive reduction</li>
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Transitivity.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Transitivity" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveClosure(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Calculates the transitive closure for a directed acyclic graph.<br /><br />
            The reflexive, transitive closure is defined as follows:<br />
            Let <c>G = (V,E)</c> be an directed acyclic graph.<br />
            The directed acyclic graph <c>G* = (V,E*)</c> is the <em>reflexive,
            transitive closure</em> of <c>G</c>,<br />
            if <c>(v,w) in E*</c> iff there is a path from <c>v</c> to
            <c>w</c> in <c>G</c>.<br /><br /><b>REMARK:</b><br />
            Note, that this implementation produces the transitive closure and
            not the reflexive, transitive closure of the specified graph, since
            no self-loops are added to the specified graph.
            </summary>
      <param name="graph">input graph to which this method will add transitive edges if necessary.</param>
      <remarks>
            Calculates the transitive closure for a directed acyclic graph.<br />
            <br />
            The reflexive, transitive closure is defined as follows:<br />
            Let <c>G = (V,E)</c> be an directed acyclic graph.<br />
            The directed acyclic graph <c>G* = (V,E*)</c> is the <em>reflexive,
            transitive closure</em> of <c>G</c>,<br />
            if <c>(v,w) in E*</c> iff there is a path from <c>v</c> to
            <c>w</c> in <c>G</c>.<br />
            <br />
            <b>REMARK:</b><br />
            Note, that this implementation produces the transitive closure and
            not the reflexive, transitive closure of the specified graph, since
            no self-loops are added to the specified graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveClosure(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveClosure(yWorks.yFiles.Algorithms.Graph)" />
            , additionally this method returns the edges
            that have been added to the graph.
            </summary>
      <param name="graph">input graph to which this method will add transitive edges if necessary.</param>
      <param name="addedEdges">contains edges that have been added to the graph by this method.</param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveClosure(yWorks.yFiles.Algorithms.Graph)" />
            , additionally this method returns the edges
            that have been added to the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveReduction(yWorks.yFiles.Algorithms.Graph)">
      <summary>Calculates the transitive reduction for a directed acyclic graph.</summary>
      <remarks>
            Calculates the transitive reduction for a directed acyclic graph. The transitive edges
            in the graph will be removed by this method.<br />
            <br />
            The transitive reduction is defined as follows:<br />
            Let <c>G = (V,E)</c> be an directed acyclic graph.<br />
            The directed acyclic graph <c>G* = (V,E*)</c> is the <em>transitive
            reduction</em> of <c>G</c>,<br />
            if <c>(v,w) in E*</c> iff there is no path from <c>v</c> to
            <c>w</c> in <c>G</c> of length 2 or more.<br />
            <br />
            <b>WARNING:</b><br />
            This implementation is costly in terms of memory, since a
            (<c>n</c> x <c>n</c>)-Matrix is allocated to store reach
            data.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveReduction(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveReduction(yWorks.yFiles.Algorithms.Graph)" />
            this method calculates the transitive reduction
            of a graph.
            </summary>
      <param name="graph">the input graph</param>
      <param name="transitiveEdges">
            returns the result. It will contain all transitive
            edges of the given graph. Removal of these edges will yield the transitive
            reduction of the graph.
            </param>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Transitivity.TransitiveReduction(yWorks.yFiles.Algorithms.Graph)" />
            this method calculates the transitive reduction
            of a graph. The transitive edges will not be removed from the graph. Instead they will be returned
            in an EdgeList.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Trees">
      <summary>
            Provides diverse algorithms and services
            for tree-structured graphs or subgraphs.
            </summary>
      <remarks>
            Provides diverse algorithms and services
            for tree-structured graphs or subgraphs.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.DirectTree(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Reverses the edges of the given tree such that it is
            a directed rooted tree afterwards.
            </summary>
      <remarks>
            Reverses the edges of the given tree such that it is
            a directed rooted tree afterwards.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.DirectTree(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Reverses the edges of the given tree such that it is
            a directed rooted tree with the given node as root element.
            </summary>
      <remarks>
            Reverses the edges of the given tree such that it is
            a directed rooted tree with the given node as root element.
            A list of all reversed edges will be returned by this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetCenterRoot(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns the center node of an undirected unrooted tree.</summary>
      <remarks>
            Returns the center node of an undirected unrooted tree.
            the center node has the property of inducing a minimum depth
            tree when being used as the root of that tree.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetLeafNodes(yWorks.yFiles.Algorithms.Graph,System.Boolean)">
      <summary>Returns all leaf nodes of the given tree.</summary>
      <param name="rooted">
            whether or not to consider the tree
            as rooted.
            </param>
      <remarks>
            Returns all leaf nodes of the given tree.
            A leaf node is a node with <c>degree == 1</c>
            in an unrooted/undirected tree, and a node with
            <c>outdegree == 0</c> in a rooted/directed tree.
            a
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetNearestCommonAncestor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,System.Boolean,yWorks.yFiles.Algorithms.NodeList)">
      <summary>Returns the nearest common ancestor of a subset of nodes within a directed rooted tree.</summary>
      <remarks>Returns the nearest common ancestor of a subset of nodes within a directed rooted tree.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetRoot(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns the root node of a rooted tree (or reversed rooted tree) or
            a maximum weight center node as defined in
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetWeightedCenterNode(yWorks.yFiles.Algorithms.Graph)" />
            or another node if the graph is not a tree.
            </summary>
      <remarks>
            Returns the root node of a rooted tree (or reversed rooted tree) or
            a maximum weight center node as defined in
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetWeightedCenterNode(yWorks.yFiles.Algorithms.Graph)" />
            or another node if the graph is not a tree.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetSubTreeDepths(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns for a rooted directed tree the depths of each of its subtrees.</summary>
      <param name="tree">a rooted directed tree graph</param>
      <param name="subtreeDepthMap">
            node map that will hold for each node the depth of the subtree rooted at it. The resulting
            depth values can be retrieved using the
            map method
            <see cref="M:yWorks.yFiles.Algorithms.INodeMap.GetInt(System.Object)" />
            .
            </param>
      <remarks>Returns for a rooted directed tree the depths of each of its subtrees.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetSubTreeSizes(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns for a rooted directed tree the size (number of nodes) of each of its subtrees.</summary>
      <param name="tree">a rooted directed tree graph</param>
      <param name="subtreeSizeMap">
            node map that will hold for each node the size of the subtree rooted at it. The resulting
            size values can be retrieved using the
            map method
            <see cref="M:yWorks.yFiles.Algorithms.INodeMap.GetInt(System.Object)" />
            .
            </param>
      <remarks>Returns for a rooted directed tree the size (number of nodes) of each of its subtrees.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetTreeEdges(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns an array of EdgeList objects each containing edges
            of the given graph that belong to maximal tree leaves
            of the graph.
            </summary>
      <remarks>
            Returns an array of EdgeList objects each containing edges
            of the given graph that belong to maximal tree leaves
            of the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetTreeEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetTreeEdges(yWorks.yFiles.Algorithms.Graph)" />
            but more efficient if
            the treeNodes where calculated before by
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetTreeNodes(yWorks.yFiles.Algorithms.Graph)" />
            .
            </summary>
      <param name="treeNodes">
            An array of NodeLists formerly calculated by
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetTreeNodes(yWorks.yFiles.Algorithms.Graph)" />
            .
            </param>
      <remarks>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetTreeEdges(yWorks.yFiles.Algorithms.Graph)" />
            but more efficient if
            the treeNodes where calculated before by
            <see cref="M:yWorks.yFiles.Algorithms.Trees.GetTreeNodes(yWorks.yFiles.Algorithms.Graph)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetTreeNodes(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns a list of NodeList objects each containing nodes
            of the given graph that belong to a maximal subtree
            of the graph.
            </summary>
      <remarks>
            Returns a list of NodeList objects each containing nodes
            of the given graph that belong to a maximal subtree
            of the graph. For each list of tree nodes the first node
            element is the root of a tree. On each such root all
            outgoing edges connect to nodes in the subtree and each
            root's indegree is at least two.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetUndirectedTreeNodes(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns a list of NodeList objects each containing nodes
            of the given graph that belong to a maximal subtree
            of the graph.
            </summary>
      <remarks>
            Returns a list of NodeList objects each containing nodes
            of the given graph that belong to a maximal subtree
            of the graph. For each list of tree nodes the first node
            element is the root of a tree. On each such root all
            outgoing edges connect to nodes in the subtree and each
            root's indegree is at least two.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetWeightedCenterNode(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Finds a node which is used by the greatest number of all paths interconnecting
            all nodes with each other.
            </summary>
      <remarks>
            Finds a node which is used by the greatest number of all paths interconnecting
            all nodes with each other.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.GetWeightedCenterNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Finds a node which is used by the greatest number of all paths interconnecting
            all nodes with each other.
            </summary>
      <remarks>
            Finds a node which is used by the greatest number of all paths interconnecting
            all nodes with each other. The number of paths per node are stored in the given
            nodeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.IsForest(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether the given graph is a forest, i.e.</summary>
      <remarks>
            Checks whether the given graph is a forest, i.e.
            a graph whose connected components are rooted trees.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.IsNaryTree(yWorks.yFiles.Algorithms.Graph,System.Int32)">
      <summary>
            Checks whether the given graph is a rooted tree where each
            node has a maximum of <c>n</c> successors.
            </summary>
      <remarks>
            Checks whether the given graph is a rooted tree where each
            node has a maximum of <c>n</c> successors.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.IsRootedTree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether the given graph is a rooted tree.</summary>
      <remarks>Checks whether the given graph is a rooted tree.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Trees.IsTree(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether or not the given graph is an undirected tree.</summary>
      <remarks>Checks whether or not the given graph is an undirected tree.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.YList">
      <summary>
            An implementation of a doubly linked list that provides direct access to the
            cells that store the elements.
            </summary>
      <remarks>
            An implementation of a doubly linked list that provides direct access to the
            cells that store the elements.
            The cells are represented by class
            <see cref="T:yWorks.yFiles.Algorithms.ListCell" />
            .
            <p />
            This class supports fast access and removal operations, specifically, it is possible
            to remove an element in constant time (i.e. O(1)) given a reference to its list
            cell.
            <p />
            Class YList supports iteration over the elements either by using the list cells
            directly (methods
            <see cref="P:yWorks.yFiles.Algorithms.YList.FirstCell" />
            /
            <see cref="P:yWorks.yFiles.Algorithms.YList.LastCell" />
            together with
            <see cref="M:yWorks.yFiles.Algorithms.YList.SuccCell(yWorks.yFiles.Algorithms.ListCell)" />
            /
            <see cref="M:yWorks.yFiles.Algorithms.YList.PredCell(yWorks.yFiles.Algorithms.ListCell)" />
            , respectively) or by
            means of a cursor (
            <see cref="M:yWorks.yFiles.Algorithms.YList.Cursor" />
            ).
            <p />
            Furthermore, YList offers its own
            <see cref="M:yWorks.yFiles.Algorithms.YList.Sort" />
            method.
            Note that this class also provides all relevant methods to use the list like
            a stack data type.
            <p />
            This implementation permits <see langword="null" /> as values.
            It implements the
            <see cref="T:yWorks.yFiles.Util.IList" />
            interface but does not support the
            <see cref="M:yWorks.yFiles.Algorithms.YList.SubList(System.Int32,System.Int32)" />
            method. The implementation of this method will throw an
            <see cref="T:System.NotSupportedException" />
            if invoked.
            The
            <see cref="M:yWorks.yFiles.Algorithms.YList.Iterator" />
            s returned by instances of this class are fail fast, however
            the
            <see cref="M:yWorks.yFiles.Algorithms.YList.Cursor" />
            implementation is not.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor">
      <summary>Creates an empty doubly linked list.</summary>
      <remarks>Creates an empty doubly linked list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(System.Collections.IEnumerator)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            enumerator object.
            </summary>
      <remarks>
            Creates a list that is initialized with the elements provided by the given
            enumerator object.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(System.Object[])">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            array of objects.
            </summary>
      <remarks>
            Creates a list that is initialized with the elements provided by the given
            array of objects.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(yWorks.yFiles.Algorithms.ICursor)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            YCursor object.
            </summary>
      <remarks>
            Creates a list that is initialized with the elements provided by the given
            YCursor object.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(yWorks.yFiles.Algorithms.ICursor,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Creates a list that is initialized with those elements from the given YCursor
            object for which the given data provider returns <see langword="true" /> upon
            calling its
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method.
            </summary>
      <param name="c">
            
            A cursor providing objects that should be added to this list.
            </param>
      <param name="predicate">
            
            A data provider that acts as a inclusion predicate for each object accessible
            by the given cursor.
            </param>
      <remarks>
            Creates a list that is initialized with those elements from the given YCursor
            object for which the given data provider returns <see langword="true" /> upon
            calling its
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(yWorks.yFiles.Util.ICollection)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            Collection object.
            </summary>
      <remarks>
            Creates a list that is initialized with the elements provided by the given
            Collection object.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.#ctor(yWorks.yFiles.Util.IIterator)">
      <summary>
            Creates a list that is initialized with the elements provided by the given
            iterator object.
            </summary>
      <remarks>
            Creates a list that is initialized with the elements provided by the given
            iterator object.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Add(System.Int32,System.Object)">
      <summary>Adds the given object to the collection at the specified index.</summary>
      <param name="index">the index at which to insert the item</param>
      <param name="item">the item to insert</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Add(System.Object)">
      <summary>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.YList.AddLast(System.Object)" />
            .
            </summary>
      <returns>
        <see langword="true" />
      </returns>
      <remarks>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.YList.AddLast(System.Object)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddAll(System.Int32,yWorks.yFiles.Util.ICollection)">
      <summary>Adds all items of the given collection at the specified index.</summary>
      <param name="index">the index at which to insert the items.</param>
      <param name="c">the collection whose items will be added.</param>
      <returns>
        <see langword="true" /> if this list has been modified due to the call of this method.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddAll(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Appends all elements provided by the given cursor to this list.</summary>
      <remarks>
            Appends all elements provided by the given cursor to this list.
            The cursor will be moved from its given position to the end.
            <p />
            Be aware that a statement like <c>aList.append(aList.cursor())</c> results
            in an infinite recursion.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddAll(yWorks.yFiles.Util.ICollection)">
      <summary>Appends all elements provided by the given collection to this list.</summary>
      <returns>Whether there have been elements appended.</returns>
      <remarks>Appends all elements provided by the given collection to this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddFirst(System.Object)">
      <summary>Inserts the given object at the head of this list.</summary>
      <returns>
            
            The newly created ListCell object that stores the given object.
            </returns>
      <remarks>Inserts the given object at the head of this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddFirstCell(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Adds a formerly removed ListCell object at the head of this list.</summary>
      <param name="cell">
            
            A list cell which is not part of any list.
            </param>
      <remarks>
            Adds a formerly removed ListCell object at the head of this list.
            <p />
            <b>Attention:</b> If the ListCell object is still part of any list, then that
            list will be corrupted afterwards.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddLast(System.Object)">
      <summary>Inserts the given object at the tail of this list.</summary>
      <returns>
            
            The newly created ListCell object that stores the given object.
            </returns>
      <remarks>Inserts the given object at the tail of this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.AddLastCell(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Adds a formerly removed ListCell object at the tail of this list.</summary>
      <param name="cell">
            
            A list cell which is not part of any list.
            </param>
      <remarks>
            Adds a formerly removed ListCell object at the tail of this list.
            <p />
            <b>Attention:</b> If the ListCell object is still part of any list, then that
            list will be corrupted afterwards.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Clear">
      <summary>Removes all elements from this list.</summary>
      <remarks>Removes all elements from this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Contains(System.Object)">
      <summary>Whether or not this list contains the given element.</summary>
      <remarks>
            Whether or not this list contains the given element.
            Equality of elements is defined by the
            <see cref="M:System.Object.Equals(System.Object)" />
            method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ContainsAll(yWorks.yFiles.Util.ICollection)">
      <summary>Whether or not this list contains all the elements in the given collection.</summary>
      <remarks>
            Whether or not this list contains all the elements in the given collection.
            Equality of elements is defined by the
            <see cref="M:System.Object.Equals(System.Object)" />
            method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.CopyTo(System.Array,System.Int32)" />
    <member name="M:yWorks.yFiles.Algorithms.YList.CopyTo(System.Object[],System.Int32)" />
    <member name="P:yWorks.yFiles.Algorithms.YList.Count">
      <summary>The number of elements in this list.</summary>
      <remarks>Returns the number of elements in this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Cursor">
      <summary>Returns a cursor for this list.</summary>
      <remarks>
            Returns a cursor for this list. All cursor operations are supported.
            This cursor implementation is not fail-fast and continues to work
            if this list is modified during the traversal as long as the current
            ListCell the cursor points at is this in this list or has been removed
            from this list
            but has not been added to another instance since then.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.CyclicPred(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Returns the cyclic predecessor cell of the given list cell.</summary>
      <remarks>
            Returns the cyclic predecessor cell of the given list cell.
            <p />
            The last cell is returned as the cyclic predecessor of the first list cell.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.CyclicSucc(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Returns the cyclic successor cell of the given list cell.</summary>
      <remarks>
            Returns the cyclic successor cell of the given list cell.
            <p />
            The first cell is returned as the cyclic successor of the last list cell.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ElementAt(System.Int32)">
      <summary>Returns the i-th element of this list.</summary>
      <remarks>Returns the i-th element of this list.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.Empty">
      <summary>Checks whether this list contains elements.</summary>
      <remarks>Checks whether this list contains elements.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Equals(System.Object)">
      <summary>Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.</summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
      <returns>true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.FindCell(System.Object)">
      <summary>
            Returns the
            <see cref="T:yWorks.yFiles.Algorithms.ListCell" />
            where object <c>o</c> is stored.
            </summary>
      <returns>
            the ListCell that contains the element or <see langword="null" /> if no
            such ListCell was found
            </returns>
      <remarks>
            Returns the
            <see cref="T:yWorks.yFiles.Algorithms.ListCell" />
            where object <c>o</c> is stored.
            This operation returns <see langword="null" />, if no such cell exists.
            Equality of elements is defined by the
            <see cref="M:System.Object.Equals(System.Object)" />
            method.
            The first element in the list that matches that criteria is returned.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.First">
      <summary>The first element of this list.</summary>
      <remarks>Returns the first element of this list.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.FirstCell">
      <summary>The first cell of this list.</summary>
      <remarks>Returns the first cell of this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Get(System.Int32)">
      <summary>Returns the item at the specified index.</summary>
      <param name="index">the index of the item that is retrieved.</param>
      <returns>the item at the specified index.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.GetCell(System.Int32)">
      <summary>Gets the cell at the given index.</summary>
      <param name="index">the zero-based index of the cell in this list.</param>
      <returns>The cell.</returns>
      <exception cref="T:System.IndexOutOfRangeException">
            if the index is negative or greater or equal than the
            <see cref="P:yWorks.yFiles.Algorithms.YList.Count" /></exception>
      <remarks>Gets the cell at the given index.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.GetEnumerator" />
    <member name="M:yWorks.yFiles.Algorithms.YList.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.GetInfo(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Returns the element stored in the given list cell.</summary>
      <remarks>Returns the element stored in the given list cell.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.IndexOf(System.Object)">
      <summary>Returns the zero-based index of the given element in this list.</summary>
      <remarks>
            Returns the zero-based index of the given element in this list.
            If the given element is not in the list, -1 is returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Insert(System.Int32,System.Object)" />
    <member name="M:yWorks.yFiles.Algorithms.YList.InsertAfter(System.Object,yWorks.yFiles.Algorithms.ListCell)">
      <summary>
            Inserts the given object into this list with respect to a given reference list
            cell.
            </summary>
      <param name="o">
            
            The object to be inserted.
            </param>
      <param name="refCell">
            
            The list cell used to reference the position.
            </param>
      <returns>
            
            The newly created ListCell object that stores object <c>o</c>.
            </returns>
      <remarks>
            Inserts the given object into this list with respect to a given reference list
            cell.
            The (newly created) list cell that stores the object is inserted right after
            the reference list cell <c>refCell</c>.
            <p />
            If <c>refCell == null</c>, the given object is inserted at the head of
            the list.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.InsertBefore(System.Object,yWorks.yFiles.Algorithms.ListCell)">
      <summary>
            Inserts the given object into this list with respect to a given reference list
            cell.
            </summary>
      <param name="o">
            
            The object to be inserted.
            </param>
      <param name="refCell">
            
            The list cell used to reference the position.
            </param>
      <returns>
            
            The newly created ListCell object that stores object <c>o</c>.
            </returns>
      <remarks>
            Inserts the given object into this list with respect to a given reference list
            cell.
            The (newly created) list cell that stores the object is inserted right before
            the reference list cell <c>refCell</c>.
            <p />
            If <c>refCell == null</c>, the given object is appended to the list.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.InsertCellAfter(yWorks.yFiles.Algorithms.ListCell,yWorks.yFiles.Algorithms.ListCell)">
      <summary>
            Inserts a formerly removed ListCell object into this list with respect to a
            given reference list cell.
            </summary>
      <param name="cellToInsert">
            
            A list cell which is not part of any list.
            </param>
      <param name="refCell">
            
            The list cell used to reference the position.
            </param>
      <remarks>
            Inserts a formerly removed ListCell object into this list with respect to a
            given reference list cell.
            The ListCell object is inserted right after the reference list cell <c>refCell</c>.
            <p />
            <b>Attention:</b> If the ListCell object is still part of any list, then that
            list will be corrupted afterwards.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.InsertCellBefore(yWorks.yFiles.Algorithms.ListCell,yWorks.yFiles.Algorithms.ListCell)">
      <summary>
            Inserts a formerly removed ListCell object into this list with respect to a
            given reference list cell.
            </summary>
      <param name="cellToInsert">
            
            A list cell which is not part of any list.
            </param>
      <param name="refCell">
            
            The list cell used to reference the position.
            </param>
      <remarks>
            Inserts a formerly removed ListCell object into this list with respect to a
            given reference list cell.
            The ListCell object is inserted right before the reference list cell <c>refCell</c>.
            <p />
            <b>Attention:</b> If the ListCell object is still part of any list, then that
            list will be corrupted afterwards.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.IsFixedSize" />
    <member name="P:yWorks.yFiles.Algorithms.YList.IsSynchronized" />
    <member name="P:yWorks.yFiles.Algorithms.YList.Item(System.Int32)" />
    <member name="M:yWorks.yFiles.Algorithms.YList.Iterator">
      <summary>Returns an iterator for that list.</summary>
      <remarks>
            Returns an iterator for that list.
            The remove operation is supported on the iterator. This iterator instance
            is fail-fast.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.Last">
      <summary>The last element of this list.</summary>
      <remarks>Returns the last element of this list.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.LastCell">
      <summary>The last cell of this list.</summary>
      <remarks>Returns the last cell of this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.LastIndexOf(System.Object)">
      <summary>
            Returns the index of the last occurrence of the specified item in this list,
            or -1 if the list does not contain the object.
            </summary>
      <param name="o">the item whose last index is being returned.</param>
      <returns>the index of last occurrence of the specified item, or -1.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListIterator">
      <summary>
            Returns a list iterator that can be used to iterate over all items of this list
            in correct order.
            </summary>
      <returns>a list iterator that iterates over the items of this list.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListIterator(System.Int32)">
      <summary>
            Returns a list iterator that can be used to iterate over all items of this list
            in correct order.
            </summary>
      <param name="index">the index at which to start the iteration.</param>
      <returns>
            a list iterator that iterates over the items of this list, starting at the
            specified index.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.NewInstance``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Creates a list that is initialized with the elements stored in the given
            collection.
            </summary>
      <remarks>
            Creates a list that is initialized with the elements stored in the given
            collection.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.NewInstance(System.Collections.ICollection)">
      <summary>
            Creates a list that is initialized with the elements stored in the given
            collection.
            </summary>
      <remarks>
            Creates a list that is initialized with the elements stored in the given
            collection.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Peek">
      <summary>
            Equivalent to
            <see cref="P:yWorks.yFiles.Algorithms.YList.First" />
            .
            </summary>
      <remarks>
            Equivalent to
            <see cref="P:yWorks.yFiles.Algorithms.YList.First" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Pop">
      <summary>Removes the first element from this list and returns it.</summary>
      <remarks>Removes the first element from this list and returns it.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.PopLast">
      <summary>Removes the last element from this list and returns it.</summary>
      <remarks>Removes the last element from this list and returns it.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.PredCell(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Returns the predecessor cell of the given list cell.</summary>
      <remarks>Returns the predecessor cell of the given list cell.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Push(System.Object)">
      <summary>
            Equivalent to
            <see cref="M:yWorks.yFiles.Algorithms.YList.AddFirst(System.Object)" />
            .
            </summary>
      <remarks>
            Equivalent to
            <see cref="M:yWorks.yFiles.Algorithms.YList.AddFirst(System.Object)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Remove(System.Int32)">
      <summary>Removes the object at the specified index.</summary>
      <param name="index">the index of the item to be removed.</param>
      <returns>the object previously at the specified position</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Remove(System.Object)">
      <summary>Removes the given object from this list.</summary>
      <remarks>
            Removes the given object from this list.
            Only the first element for which equality to <c>o</c> holds gets removed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.RemoveAll(yWorks.yFiles.Util.ICollection)">
      <summary>Removes the given collection of objects from this list.</summary>
      <returns>
            
            Whether there have been elements removed.
            </returns>
      <remarks>Removes the given collection of objects from this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.RemoveAt(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Removes the element pointed to by the given YCursor object.</summary>
      <returns>
            
            The removed element.
            </returns>
      <remarks>Removes the element pointed to by the given YCursor object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.RemoveCell(yWorks.yFiles.Algorithms.ListCell)">
      <summary>
            Removes the given list cell, and hence the element stored in it, from this
            list.
            </summary>
      <returns>
            
            The element that is stored in the removed cell.
            </returns>
      <remarks>
            Removes the given list cell, and hence the element stored in it, from this
            list.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.RetainAll(yWorks.yFiles.Util.ICollection)">
      <summary>Retains only those elements in this list which are contained in the given collection.</summary>
      <returns>Whether there have been elements removed.</returns>
      <remarks>Retains only those elements in this list which are contained in the given collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Reverse">
      <summary>Reverses the sequence of elements in this list.</summary>
      <remarks>Reverses the sequence of elements in this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Set(System.Int32,System.Object)">
      <summary>Replaces the item at the specified index with the given item.</summary>
      <param name="index">the index at which to replace the item.</param>
      <param name="item">the item which should be set at the specified index.</param>
      <returns>the item that was previously at the specified index.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.SetInfo(yWorks.yFiles.Algorithms.ListCell,System.Object)">
      <summary>Updates the element stored in the given list cell with the given object.</summary>
      <remarks>Updates the element stored in the given list cell with the given object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Sort">
      <summary>
            Sorts the elements in this list into ascending order, according to their natural
            ordering.
            </summary>
      <remarks>
            Sorts the elements in this list into ascending order, according to their natural
            ordering.
            All elements must implement the
            <see cref="T:System.IComparable" />
            interface.
            Furthermore, all elements in this list must be mutually comparable (that is,
            <c>e1.compareTo(e2)</c> must not throw a ClassCastException for any elements
            <c>e1</c> and <c>e2</c> in this list).
            <p />
            NOTE: The elements will be assigned to different list cells by this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Sort(System.Collections.IComparer)">
      <summary>Sorts the elements in this list according to the given comparator.</summary>
      <remarks>
            Sorts the elements in this list according to the given comparator.
            <p />
            NOTE: The elements will be assigned to different list cells by this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.Splice(yWorks.yFiles.Algorithms.YList)">
      <summary>Transfers the contents of the given list to the end of this list.</summary>
      <remarks>
            Transfers the contents of the given list to the end of this list.
            The given list will be empty after this operation.
            <p />
            Note that this operation transfers the list cells of the given list to this
            list.
            No new list cells are created by this operation.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.SubList(System.Int32,System.Int32)">
      <summary>Returns a list that contains the specified range of items in this list.</summary>
      <param name="fromIndex">the index of the item that is the first element of the returned list.</param>
      <param name="toIndex">
            the end index the returned list. The item at this index is not included
            in the returned list.
            </param>
      <returns>a list that contains the items of this list in the specified range.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.SuccCell(yWorks.yFiles.Algorithms.ListCell)">
      <summary>Returns the successor cell of the given list cell.</summary>
      <remarks>Returns the successor cell of the given list cell.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.SyncRoot" />
    <member name="M:yWorks.yFiles.Algorithms.YList.ToArray">
      <summary>Returns an array representation of this list.</summary>
      <remarks>Returns an array representation of this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ToArray(System.Array)">
      <summary>Returns an array containing all list elements in the correct order.</summary>
      <param name="a">
            
            The array into which the elements of the list are to be stored, if it is big
            enough.
            Otherwise, a new array of the same runtime type is allocated for this purpose.
            </param>
      <returns>
            
            An array containing the elements of the list.
            </returns>
      <exception cref="T:System.ArrayTypeMismatchException">
            if the runtime type of the specified array <c>a</c>
            is not a supertype of the runtime type of every element in this list.
            </exception>
      <remarks>
            Returns an array containing all list elements in the correct order.
            The runtime type of the returned array is that of the given array.
            <p />
            If the list does not fit in the specified array, a new array is allocated with
            the runtime type of the specified array and the size of this list.
            <p />
            If the list fits in the specified array with room to spare (i.e., the array
            has more elements than the list), the element in the array immediately following
            the end of the collection is set to <see langword="null" />.
            This is useful in determining the length of the list <i>only</i> if the caller
            knows that the list does not contain any <see langword="null" /> elements.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ToString">
      <summary>Returns a string representation of this List.</summary>
      <remarks>Returns a string representation of this List.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.YList.ListCursorImpl">
      <summary>Cursor implementation for class YList.</summary>
      <remarks>Cursor implementation for class YList.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListCursorImpl.#ctor(yWorks.yFiles.Algorithms.YList)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.YList.ListCursorImpl" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.ListCursorImpl.Current">
      <summary>The object currently pointed on.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListCursorImpl.Next">
      <summary>Moves this cursor one position forward.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.ListCursorImpl.Ok">
      <summary>
        <see langword="true" /> if the current cursor position is valid.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListCursorImpl.Prev">
      <summary>Moves this cursor one position backward (optional).</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.YList.ListCursorImpl.Size">
      <summary>The number of elements that can be accessed with this cursor.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListCursorImpl.ToFirst">
      <summary>Moves this cursor to the first valid cursor position (optional).</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.YList.ListCursorImpl.ToLast">
      <summary>Moves this cursor to the last valid cursor position (optional).</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.AffineLine">
      <summary>This class represents a line in the 2D-dimensional affine space.</summary>
      <remarks>
            This class represents a line in the 2D-dimensional affine space.
            The line is defined by the equation ax + by + c = 0
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Creates an affine line which is defined by two points.</summary>
      <remarks>Creates an affine line which is defined by two points.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>
            Creates an affine line which is defined by a point
            and a vector.
            </summary>
      <remarks>
            Creates an affine line which is defined by a point
            and a vector.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.AffineLine.A">
      <summary>A from ax+by+c = 0</summary>
      <remarks>Returns a from ax+by+c = 0</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.AffineLine.B">
      <summary>B from ax+by+c = 0</summary>
      <remarks>Returns b from ax+by+c = 0</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.AffineLine.C">
      <summary>C from ax+by+c = 0</summary>
      <remarks>Returns c from ax+by+c = 0</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.GetCrossing(yWorks.yFiles.Algorithms.Geometry.AffineLine,yWorks.yFiles.Algorithms.Geometry.AffineLine)">
      <summary>Returns the crossing of two lines.</summary>
      <remarks>
            Returns the crossing of two lines.
            If the lines are parallel, <see langword="null" /> is returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.GetXProjection(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Projects an point on the line in direction of the X-axis.</summary>
      <remarks>Projects an point on the line in direction of the X-axis.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.GetYProjection(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Projects an point on the line in direction of the Y-axis.</summary>
      <remarks>Projects an point on the line in direction of the Y-axis.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.AffineLine.ToString">
      <summary>Returns the equation of the line as String</summary>
      <remarks>Returns the equation of the line as String</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.BorderLine">
      <summary>
            This class can be used to easily model an orthogonal
            border line or sky-line.
            </summary>
      <remarks>
            This class can be used to easily model an orthogonal
            border line or sky-line. It provides methods for measuring
            the distance between different BorderLine instances, merging
            multiple instances, modifying and efficiently moving them around.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.#ctor(System.Double)">
      <summary>
            Creates a new BorderLine with the given value
            from -Double.MAX_VALUE to Double.MAX_VALUE.
            </summary>
      <param name="value">the value of the segment</param>
      <remarks>
            Creates a new BorderLine with the given value
            from -Double.MAX_VALUE to Double.MAX_VALUE.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.#ctor(System.Double,System.Double,System.Double)">
      <summary>Creates a new BorderLine from a single segment.</summary>
      <param name="min">the beginning of this borderline</param>
      <param name="max">the ending of this borderline</param>
      <param name="value">the value of the segment</param>
      <remarks>Creates a new BorderLine from a single segment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.AddOffset(System.Double)">
      <summary>Adds the given offset to the segments' positions.</summary>
      <param name="delta">the delta to add to the positions</param>
      <remarks>Adds the given offset to the segments' positions. This method has complexity O(1).</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.AddValueOffset(System.Double)">
      <summary>
            Adds the given offset to the current values of
            the whole borderline.
            </summary>
      <param name="delta">the delta to add to the values</param>
      <remarks>
            Adds the given offset to the current values of
            the whole borderline. This method has complexity O(1).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.AdoptValues(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>
            Convenience method that copies the actual data from the given
            argument to this instance.
            </summary>
      <param name="other">the argument to retrieve the values from</param>
      <remarks>
            Convenience method that copies the actual data from the given
            argument to this instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.CreateCopy(System.Boolean,System.Boolean)">
      <summary>Creates a copy of this borderline.</summary>
      <param name="negateValues">whether the values are negated</param>
      <param name="negateOffsets">whether the offsets are negated</param>
      <returns>the copy of the borderline</returns>
      <remarks>
            Creates a copy of this borderline.
            Optionally negates the values or offsets.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.CreateMax(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>
            Merges this borderline with the given borderline
            using the "maximum" policy.
            </summary>
      <param name="other">the other borderline</param>
      <returns>a new borderline that is the result of the merge</returns>
      <remarks>
            Merges this borderline with the given borderline
            using the "maximum" policy.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.CreateMin(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>
            Merges this borderline with the given borderline
            using the "minimum" policy.
            </summary>
      <param name="other">the other borderline</param>
      <returns>a new borderline that is the result of the merge</returns>
      <remarks>
            Merges this borderline with the given borderline
            using the "minimum" policy.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.FirstSegment">
      <summary>
            Returns the first segment or <see langword="null" /> if there is
            no such segment.
            </summary>
      <remarks>
            Returns the first segment or <see langword="null" /> if there is
            no such segment.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetDistanceTo(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>Calculates the minimal distance between this borderline and the other one.</summary>
      <remarks>
            Calculates the minimal distance between this borderline and the other one.
            The other one is treated as if the values were all greater.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMax(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">
      <summary>Returns the maximum position of the given segment.</summary>
      <param name="s">the segment</param>
      <remarks>Returns the maximum position of the given segment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMaxValue(System.Double,System.Double)">
      <summary>Calculates the maximum value in the interval from-&gt;to.</summary>
      <remarks>Calculates the maximum value in the interval from-&gt;to.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMin(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">
      <summary>Returns the minimum position of the given segment.</summary>
      <param name="s">the segment</param>
      <remarks>Returns the minimum position of the given segment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMinValue(System.Double,System.Double)">
      <summary>Calculates the minimum value in the interval from-&gt;to.</summary>
      <remarks>Calculates the minimum value in the interval from-&gt;to.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetSegmentAt(System.Double)">
      <summary>Returns the segment at the given position.</summary>
      <param name="pos">the position</param>
      <remarks>Returns the segment at the given position.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetValue(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">
      <summary>Returns the value of the given segment.</summary>
      <param name="s">the segment</param>
      <remarks>Returns the value of the given segment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetValueAt(System.Double)">
      <summary>
            Returns the value that is set on this borderline
            at the specified position.
            </summary>
      <param name="pos">the position</param>
      <returns>the value</returns>
      <remarks>
            Returns the value that is set on this borderline
            at the specified position.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.Grow(System.Double,System.Double,System.Boolean)">
      <summary>
            Grows this BorderLine horizontally, so that the
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetValue(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">values</see>
            of the BorderLine stay the same however their
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMin(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">start</see>
            and
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMax(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">end</see>
            points are moved in the direction of <c>toMin</c>
            and <c>toMax</c>.
            </summary>
      <param name="toMin">the delta by which the border should be extended towards -Infinity</param>
      <param name="toMax">the delta by which the border should be extended towards +Infinity</param>
      <param name="positive">
            whether the BorderLine should be interpreted to point in positive direction. This influences the
            direction into which a segment's border is extended.
            </param>
      <remarks>
            Grows this BorderLine horizontally, so that the
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetValue(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">values</see>
            of the BorderLine stay the same however their
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMin(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">start</see>
            and
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.GetMax(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">end</see>
            points are moved in the direction of <c>toMin</c>
            and <c>toMax</c>.
            This is useful for scenarios where a BorderLine is needed that consists of an enlarged border.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.LastSegment">
      <summary>
            Returns the last segment or <see langword="null" /> if there is
            no such segment.
            </summary>
      <remarks>
            Returns the last segment or <see langword="null" /> if there is
            no such segment.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.BorderLine.Max">
      <summary>The greatest position of this borderline</summary>
      <remarks>Returns the greatest position of this borderline</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.BorderLine.MaxValue">
      <summary>The maximum value that is set on this borderline</summary>
      <remarks>Returns the maximum value that is set on this borderline</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.MergeWithMax(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>
            Merges this borderline with the given borderline
            using the "maximum" policy.
            </summary>
      <param name="other">the other borderline</param>
      <remarks>
            Merges this borderline with the given borderline
            using the "maximum" policy.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.MergeWithMin(yWorks.yFiles.Algorithms.Geometry.BorderLine)">
      <summary>
            Merges this borderline with the given borderline
            using the "minimum" policy.
            </summary>
      <param name="other">the other borderline</param>
      <remarks>
            Merges this borderline with the given borderline
            using the "minimum" policy.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.BorderLine.Min">
      <summary>The smallest position of this borderline</summary>
      <remarks>Returns the smallest position of this borderline</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.BorderLine.MinValue">
      <summary>The minimum value that is set on this borderline</summary>
      <remarks>Returns the minimum value that is set on this borderline</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.Next(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">
      <summary>
            Returns the next segment or <see langword="null" /> if there is
            no such segment.
            </summary>
      <remarks>
            Returns the next segment or <see langword="null" /> if there is
            no such segment.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.Prev(yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment)">
      <summary>
            Returns the previous segment or <see langword="null" /> if there is
            no such segment.
            </summary>
      <remarks>
            Returns the previous segment or <see langword="null" /> if there is
            no such segment.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.SetMaxValue(System.Double,System.Double,System.Double)">
      <summary>Assures that all values in the given interval are greater or equal than the given value.</summary>
      <param name="min">the lower end of the interval</param>
      <param name="max">the upper end of the interval</param>
      <param name="value">the smallest possible value for the interval</param>
      <remarks>Assures that all values in the given interval are greater or equal than the given value.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.SetMinValue(System.Double,System.Double,System.Double)">
      <summary>Assures that all values in the given interval are less or equal than the given value.</summary>
      <param name="min">the lower end of the interval</param>
      <param name="max">the upper end of the interval</param>
      <param name="value">the greatest possible value for the interval</param>
      <remarks>Assures that all values in the given interval are less or equal than the given value.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.SetValue(System.Double,System.Double,System.Double)">
      <summary>Sets a specific interval to a given value.</summary>
      <remarks>Sets a specific interval to a given value.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.ToString">
      <summary>Returns a lengthy String representation of this borderline.</summary>
      <remarks>Returns a lengthy String representation of this borderline.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment">
      <summary>The handle of a segment of a borderline.</summary>
      <remarks>The handle of a segment of a borderline.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment.Next">
      <summary>
            Returns the next segment or <see langword="null" /> if there is
            no such segment.
            </summary>
      <remarks>
            Returns the next segment or <see langword="null" /> if there is
            no such segment.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.BorderLine.Segment.Prev">
      <summary>
            Returns the previous segment or <see langword="null" /> if there is
            no such segment.
            </summary>
      <remarks>
            Returns the previous segment or <see langword="null" /> if there is
            no such segment.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.Geom">
      <summary>
            This class provides useful geometric primitives and advanced
            geometric algorithms.
            </summary>
      <remarks>
            This class provides useful geometric primitives and advanced
            geometric algorithms.
            <p />This class is intended to provide static methods for geometric
            calculations. It can be compared to the class <c>java.lang.Math</c>
            which provides methods for general mathematical calculations.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.CalcConvexHull(yWorks.yFiles.Algorithms.YList)">
      <summary>Calculates the convex hull for a set of points.</summary>
      <param name="points">a list of YPoint objects</param>
      <returns>
            a list of YPoint objects that constitute the convex hull of the given
            points. The list contains points in counterclockwise order around the hull.
            the first point is the one with the smallest <c>x</c> coordinate.
            If two such points exist then of these points the one with the smallest
            <c>y</c> coordinate is chosen as the first one.
            </returns>
      <remarks>Calculates the convex hull for a set of points.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.CalcIntersection(yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>
            Intersects the pair of specified source <c>Rectangle2D</c>
            objects and puts the result into the specified destination
            <c>Rectangle2D</c> object.
            </summary>
      <param name="r1">
            the first of a pair of <c>Rectangle2D</c>
            objects to be intersected with each other
            </param>
      <param name="r2">
            the second of a pair of <c>Rectangle2D</c>
            objects to be intersected with each other
            </param>
      <param name="dest">
            the <c>Rectangle2D</c> that holds the
            results of the intersection of <c>r1</c> and
            <c>r2</c></param>
      <remarks>
            Intersects the pair of specified source <c>Rectangle2D</c>
            objects and puts the result into the specified destination
            <c>Rectangle2D</c> object.
            If one or both of the source rectangles have negative width or height,
            the resulting rectangle will be located at (0,0) with a width and height
            of -1.
            One of the source rectangles can also be the destination to avoid
            creating a third Rectangle2D object, but in this case the original
            points of this source rectangle will be overwritten by this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.CalcUnion(yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>
            Unions the pair of source <c>Rectangle2D</c> objects
            and puts the result into the specified destination
            <c>Rectangle2D</c> object.
            </summary>
      <param name="r1">
            the first of a pair of <c>Rectangle2D</c>
            objects to be combined with each other
            </param>
      <param name="r2">
            the second of a pair of <c>Rectangle2D</c>
            objects to be combined with each other
            </param>
      <param name="dest">
            the <c>Rectangle2D</c> that holds the
            results of the union of <c>r1</c> and
            <c>r2</c></param>
      <remarks>
            Unions the pair of source <c>Rectangle2D</c> objects
            and puts the result into the specified destination
            <c>Rectangle2D</c> object.
            If one of the source rectangles has negative width or height,
            it is excluded from the union.
            If both source rectangles have negative width or height,
            the destination rectangle will become a copy of <c>r1</c>.
            One of the source rectangles can also be the destination to avoid creating
            a third Rectangle2D object, but in this case the original points of this
            source rectangle will be overwritten by this method.
            If the destination is <see langword="null" />, a new <c>Rectangle2D</c>
            is created.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.Collinear(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Returns <see langword="true" /> iff the given points are collinear, i.e.</summary>
      <remarks>
            Returns <see langword="true" /> iff the given points are collinear, i.e. all
            three points lie on a common line.
            <p />
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">orientation(p,q,r) == 0</see>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.DistanceToLineSegment(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Determines the distance of the point <c>p</c> to the line segment
            <c>[l1, l2]</c>.
            </summary>
      <param name="pointX">the x coordinate of p</param>
      <param name="pointY">the y coordinate of p</param>
      <param name="lineX1">the x coordinate of l1</param>
      <param name="lineY1">the y coordinate of l1</param>
      <param name="lineX2">the x coordinate of l2</param>
      <param name="lineY2">the y coordinate of l2</param>
      <remarks>
            Determines the distance of the point <c>p</c> to the line segment
            <c>[l1, l2]</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.LeftTurn(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">orientation(p,q,r) &gt; 0</see></summary>
      <remarks>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">orientation(p,q,r) &gt; 0</see>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.LinesIntersect(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Same as
            <see cref="!:yWorks.yFiles.Util.Geom.Line2D.LinesIntersect(double,double,double,double,double,double,double,double)" />
            .
            </summary>
      <remarks>
            Same as
            <see cref="!:yWorks.yFiles.Util.Geom.Line2D.LinesIntersect(double,double,double,double,double,double,double,double)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)" />
            with double values as arguments.
            </summary>
      <remarks>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)" />
            with double values as arguments.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Returns the orientation of point <c>r</c> relative to the directed
            line  from point <c>p</c> to point <c>q</c>.
            </summary>
      <returns>
        <b>+1</b> in the case of positive orientation, <b>-1</b> in the
            case of  negative orientation and <b>0</b> in the case of zero
            orientation.
            </returns>
      <remarks>
            Returns the orientation of point <c>r</c> relative to the directed
            line  from point <c>p</c> to point <c>q</c>.
            <p />
            The given tuple of points is said to have positive orientation if
            <c>p</c> and <c>q</c> are distinct and <c>r</c> lies
            to the left of the oriented line passing through <c>p</c>
            and <c>q</c> and oriented from <c>p</c> to <c>q</c>.
            <p />
            The tuple is said to have negative orientation if
            <c>p</c> and <c>q</c> are distinct and <c>r</c> lies
            to the right of the line, and the tuple is said to have orientation zero
            if the three points are collinear.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.Projection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Determines the projection of the point <c>p</c> onto the line
            segment <c>[l1, l2]</c>.
            </summary>
      <param name="pointX">the x coordinate of p</param>
      <param name="pointY">the y coordinate of p</param>
      <param name="lineX1">the x coordinate of l1</param>
      <param name="lineY1">the y coordinate of l1</param>
      <param name="lineX2">the x coordinate of l2</param>
      <param name="lineY2">the y coordinate of l2</param>
      <remarks>
            Determines the projection of the point <c>p</c> onto the line
            segment <c>[l1, l2]</c>.
            The resulting point is
            <ul>
            <li>the orthogonal projection of <c>p</c> onto the line through
            <c>l1</c> and <c>l2</c>, iff the projection lies on the
            line segment <c>[l1, l2]</c></li>
            <li>the end point of the line segment <c>[l1, l2]</c> that is closest
            to <c>p</c></li>, otherwise
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.RightTurn(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">orientation(p,q,r) &lt; 0</see></summary>
      <remarks>
            Same as
            <see cref="M:yWorks.yFiles.Algorithms.Geometry.Geom.Orientation(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">orientation(p,q,r) &lt; 0</see>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.SideOfCircle(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Returns +1 if point <c>d</c> lies left of the directed circle through
            points <c>a</c>, <c>b</c>, and <c>c</c>,
            0 if <c>a,b,c</c> and <c>d</c> are cocircular, and -1 otherwise.
            </summary>
      <remarks>
            Returns +1 if point <c>d</c> lies left of the directed circle through
            points <c>a</c>, <c>b</c>, and <c>c</c>,
            0 if <c>a,b,c</c> and <c>d</c> are cocircular, and -1 otherwise.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.ToDegrees(System.Double)">
      <summary>
            Same as
            <see cref="!:System.Math.ToDegrees(double)" />
            .
            </summary>
      <remarks>
            Same as
            <see cref="!:System.Math.ToDegrees(double)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Geom.ToRadians(System.Double)">
      <summary>
            Same as
            <see cref="!:System.Math.ToRadians(double)" />
            .
            </summary>
      <remarks>
            Same as
            <see cref="!:System.Math.ToRadians(double)" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.ILineSegmentCursor">
      <summary>This is an interface for a sequence of instances of LineSegment.</summary>
      <remarks>This is an interface for a sequence of instances of LineSegment.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.ILineSegmentCursor.LineSegment">
      <summary>The instance of LineSegment the cursor is currently pointing on.</summary>
      <remarks>Returns the instance of LineSegment the cursor is currently pointing on.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm">
      <summary>
            This class calculates the intersection of rectangles in the plane with
            the help of a sweep-line algorithm.
            </summary>
      <remarks>
            This class calculates the intersection of rectangles in the plane with
            the help of a sweep-line algorithm.
            <br />
            The complexity is <c>O(n log n + s)</c> where <c>n</c>
            is the number of rectangles and <c>s</c> the number of intersections.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.CreateXStruct(yWorks.yFiles.Algorithms.YList)">
      <summary>Initializes the sweep line data structures from a set of objects.</summary>
      <remarks>Initializes the sweep line data structures from a set of objects.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.Intersect(yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.IIntersectionHandler)">
      <summary>Calculates the intersections of rectangles in the plane.</summary>
      <param name="objects">a list of <c>PlaneObject</c> objects.</param>
      <param name="iHandler">intersections are reported to this class.</param>
      <remarks>
            Calculates the intersections of rectangles in the plane.
            Every found intersection is reported to an
            <c>IntersectionHandler</c>.
            Rectangles with negative size are completely ignored by this implementation (i.e.
            never generate intersections)
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.IIntersectionHandler">
      <summary>
            An instance of this interface handles intersections found by the
            <c>IntersectionAlgorithm</c>,
            </summary>
      <remarks>
            An instance of this interface handles intersections found by the
            <c>IntersectionAlgorithm</c>,
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.IntersectionAlgorithm.IIntersectionHandler.CheckIntersection(System.Object,System.Object)">
      <summary>This method is called at every intersection.</summary>
      <remarks>This method is called at every intersection.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.IPlaneObject">
      <summary>
            This interface describes a 2-dimensional object which has a finite
            bounding box.
            </summary>
      <remarks>
            This interface describes a 2-dimensional object which has a finite
            bounding box.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.IPlaneObject.BoundingBox">
      <summary>The smallest Rectangle which contains the object.</summary>
      <remarks>Returns the smallest Rectangle which contains the object.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.IPointCursor">
      <summary>This is an interface for a sequence of instances of YPoint.</summary>
      <remarks>This is an interface for a sequence of instances of YPoint.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.IPointCursor.Point">
      <summary>The instance of YPoint the cursor is currently pointing on.</summary>
      <remarks>Returns the instance of YPoint the cursor is currently pointing on.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.LineSegment">
      <summary>This class represents a line segment in the plane.</summary>
      <remarks>
            This class represents a line segment in the plane.
            A line segment is defined by its two end points.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Returns a new LineSegment.</summary>
      <param name="p1">the first end point of the line segment.</param>
      <param name="p2">the second end point of the line segment.</param>
      <remarks>Returns a new LineSegment.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.LineSegment.BoundingBox">
      <summary>The smallest Rectangle which contains the object.</summary>
      <remarks>Returns the smallest Rectangle which contains the object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.BoxIntersectsSegment(yWorks.yFiles.Algorithms.Geometry.YRectangle,System.Double,System.Double,System.Double,System.Double)">
      <summary>Checks whether a line segment intersects a box.</summary>
      <param name="box">A rectangle</param>
      <param name="x1">X-coordinate of start point of vector</param>
      <param name="y1">Y-coordinate of start point of vector</param>
      <param name="x2">X-coordinate of target point of vector</param>
      <param name="y2">Y-coordinate of target point of vector</param>
      <returns>
        <see langword="true" /> if the line segments intersects the box,
            <see langword="false" /> otherwise.
            </returns>
      <remarks>
            Checks whether a line segment intersects a box.
            Implemented using the Cohen-Sutherland algorithm.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.BoxIntersectsSegment(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Checks whether a line segment intersects a box.</summary>
      <param name="box">A rectangle.</param>
      <param name="s">first end point of the line segment.</param>
      <param name="t">second end point of the line segment.</param>
      <returns>
        <see langword="true" /> if the line segments intersects the box,
            <see langword="false" /> otherwise.
            </returns>
      <remarks>Checks whether a line segment intersects a box.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.Contains(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Checks whether a given point lies on  this line segment.</summary>
      <param name="point">an arbitrary point.</param>
      <returns>
        <see langword="true" /> if the line segments intersects the box,
            <see langword="false" /> otherwise.
            </returns>
      <remarks>Checks whether a given point lies on  this line segment.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.LineSegment.FirstEndPoint">
      <summary>The first end point of the line segment.</summary>
      <remarks>Returns the first end point of the line segment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.GetIntersection(yWorks.yFiles.Algorithms.Geometry.LineSegment,yWorks.yFiles.Algorithms.Geometry.LineSegment)">
      <summary>
            Returns intersection point between the two line segments, if there is
            one or <see langword="null" /> if the two line segments do not intersect.
            </summary>
      <param name="s1">first line segment</param>
      <param name="s2">second line segment</param>
      <remarks>
            Returns intersection point between the two line segments, if there is
            one or <see langword="null" /> if the two line segments do not intersect.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.Intersects(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Checks whether the line segment intersects a point.</summary>
      <param name="p">a point</param>
      <returns>
        <see langword="true" /> if the line segments intersects the box,
            <see langword="false" /> otherwise.
            </returns>
      <remarks>Checks whether the line segment intersects a point.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.Intersects(yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>Checks whether the line segment intersects a box.</summary>
      <param name="box">A rectangle.</param>
      <returns>
        <see langword="true" /> if the line segments intersects the box,
            <see langword="false" /> otherwise.
            </returns>
      <remarks>Checks whether the line segment intersects a box.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.IsInXIntervall(System.Double)">
      <summary>
            Returns if the projection on the X axis of the line segment
            covers a certain point on the X Axis.
            </summary>
      <remarks>
            Returns if the projection on the X axis of the line segment
            covers a certain point on the X Axis.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.IsInYIntervall(System.Double)">
      <summary>
            Returns if the projection on the Y axis of the line segment
            covers a certain point on the Y Axis.
            </summary>
      <remarks>
            Returns if the projection on the Y axis of the line segment
            covers a certain point on the Y Axis.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.Length">
      <summary>
            Returns the length of the line segment,
            this is the value of the Euclidean norm.
            </summary>
      <returns>an value &gt; 0.</returns>
      <remarks>
            Returns the length of the line segment,
            this is the value of the Euclidean norm.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.LineSegment.Scope">
      <summary>The scope of the line segment.</summary>
      <remarks>Returns the scope of the line segment.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.LineSegment.SecondEndPoint">
      <summary>The second end point of the line segment.</summary>
      <remarks>Returns the second end point of the line segment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.ToAffineLine">
      <summary>
            Returns the affine line defined by the end points of the
            line segment.
            </summary>
      <remarks>
            Returns the affine line defined by the end points of the
            line segment.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.ToString">
      <summary>String representation of the line.</summary>
      <remarks>String representation of the line.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.LineSegment.ToYVector">
      <summary>
            Returns the vector pointing from the first end point to the second
            end point of the line segment.
            </summary>
      <remarks>
            Returns the vector pointing from the first end point to the second
            end point of the line segment.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.LineSegment.XOffset">
      <summary>The y value of the line on x coordinate 0.</summary>
      <remarks>Returns the y value of the line on x coordinate 0.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.Triangulator">
      <summary>
            This class provides algorithms for the triangulation of point
            sets in the plane.
            </summary>
      <remarks>
            This class provides algorithms for the triangulation of point
            sets in the plane.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Triangulator.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Geometry.Triangulator" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Triangulator.CalcDelauneyTriangulation(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Computes a Delauney triangulation of the given points.</summary>
      <param name="result">
            a graph whose nodes represent the points that need
            to be triangulated.
            </param>
      <param name="pointData">must provide the location (YPoint) for each node in the given graph.</param>
      <param name="revMap">
            a node map that will contain for each edge its reverse
            edge. If this argument is <see langword="null" /> then no reverse edge information
            will be available.
            </param>
      <returns>an edge on the outer face of the result graph.</returns>
      <remarks>
            Computes a Delauney triangulation of the given points. A Delauney triangulation
            is a triangulation such that none of the given points is inside the circumcircle
            of any of the calculated triangles.
            <p>
            The calculated triangulation is represented by an embedded graph,
            i.e. to each edge there exists a reverse edge and the outedges
            around each node are in embedded order. The returned edge and
            the (optional) reverseEdgeMap can be used to construct all faces of the
            plane graph and to determine its outer face.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Triangulator.TriangulatePoints(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Computes a triangulation of the given points.</summary>
      <param name="result">
            a graph whose nodes represent the points that need
            to be triangulated.
            </param>
      <param name="pointData">must provide the location (YPoint) for each node in the given graph.</param>
      <param name="reverseEdgeMap">
            a node map that will contain for each edge its reverse
            edge. If this argument is <see langword="null" /> then no reverse edge information
            will be available.
            </param>
      <returns>an edge on the outer face of the result graph.</returns>
      <remarks>
            Computes a triangulation of the given points.
            The calculated triangulation is represented by an embedded graph,
            i.e. to each edge there exists a reverse edge and the outedges
            around each node are in embedded order. The returned edge and
            the (optional) reverseEdgeMap can be used to construct all faces of the
            plane graph and to determine its outer face.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.Triangulator.TriangulatePoints(yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Computes a triangulation of the given points.</summary>
      <param name="points">
            the point set to be triangulated. The points must be provided
            as a YList of YPoints.
            </param>
      <param name="result">the resulting triangulation</param>
      <param name="resultMap">the node map that forms the link between a point and a node.</param>
      <param name="reverseEdgeMap">
            a node map that will contain for each edge its reverse
            edge. If this argument is <see langword="null" /> then no reverse edge information
            will be available.
            </param>
      <returns>an edge on the outer face of the result graph.</returns>
      <remarks>
            Computes a triangulation of the given points.
            The calculated triangulation is represented by an embedded graph,
            i.e. to each edge there exists a reverse edge and the outedges
            around each node are in embedded order. The returned edge and
            the (optional) reverseEdgeMap can be used to construct all faces of the
            plane graph and to determine its outer face.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YDimension">
      <summary>This class represents the size of an object.</summary>
      <remarks>
            This class represents the size of an object.
            An instance of this class implements the immutable design pattern.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YDimension.#ctor(System.Double,System.Double)">
      <summary>Creates a new YDimension2D object for given size.</summary>
      <remarks>Creates a new YDimension2D object for given size.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YDimension.CompareTo(System.Object)">
      <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
      <param name="obj">An object to compare with this instance. </param>
      <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj" />. Zero This instance is equal to <paramref name="obj" />. Greater than zero This instance is greater than <paramref name="obj" />. </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance. </exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YDimension.Equals(System.Object)">
      <summary>Tests a dimension to equality to another dimension.</summary>
      <remarks>Tests a dimension to equality to another dimension.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YDimension.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YDimension.Height">
      <summary>The height of the dimension object.</summary>
      <remarks>Get the height of the dimension object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YDimension.ToString">
      <summary>Returns the size in the form: "W: width H: height"</summary>
      <remarks>Returns the size in the form: "W: width H: height"</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YDimension.Width">
      <summary>The width of the dimension object.</summary>
      <remarks>Get the width of the dimension object.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle">
      <summary>
            An oriented rectangle in 2D coordinate space with double precision
            coordinates.
            </summary>
      <remarks>
            An oriented rectangle in 2D coordinate space with double precision
            coordinates.
            The rectangle's <c>height</c> extends from its
            <em>
            <see cref="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Anchor">anchor point</see>
            </em> in the direction of its <em>up
            vector</em> <code>(
            <see cref="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.UpX">ux</see>
            ,
            <see cref="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.UpY">uy</see>
            )</code>.
            Its <c>width</c> extends from its
            <code>
            <see cref="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Anchor">anchor point</see>
            </code> in direction
            <c>(-uy, ux)</c> (i.e. perpendicular to the <em>up vector</em>).
            This means that an oriented rectangle with anchor point <c>(0, 0)</c>
            width <c>100</c>, height <c>10</c>, and up vector
            <c>(0, -1)</c> is a paraxial rectangle with upper left corner
            <c>(0, -10)</c> and lower right corner <c>(100, 0)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a new instance using the provided values to initialize anchor and
            size.
            </summary>
      <param name="anchorX">The x coordinate of the anchor of the oriented rectangle.</param>
      <param name="anchorY">The y coordinate of the anchor of the oriented rectangle.</param>
      <param name="width">The width of the rectangle.</param>
      <param name="height">The height of the rectangle.</param>
      <remarks>
            Creates a new instance using the provided values to initialize anchor and
            size.  The oriented rectangle's up vector will be
            <c>(0, -1)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a new instance using the provided values to initialize anchor,
            size, and up vector.
            </summary>
      <param name="anchorX">The x coordinate of the anchor of the oriented rectangle.</param>
      <param name="anchorY">The y coordinate of the anchor of the oriented rectangle.</param>
      <param name="width">The width of the rectangle.</param>
      <param name="height">The height of the rectangle.</param>
      <param name="upX">The x component of the up vector.</param>
      <param name="upY">The y component of the up vector.</param>
      <remarks>
            Creates a new instance using the provided values to initialize anchor,
            size, and up vector.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.#ctor(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle)">
      <summary>
            Creates a new instance using the provided rectangle's values to initialize
            anchor, size, and up vector.
            </summary>
      <param name="rect">the provided rectangle.</param>
      <remarks>
            Creates a new instance using the provided rectangle's values to initialize
            anchor, size, and up vector.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension)">
      <summary>Creates a new instance using the provided values to initialize the anchor and size.</summary>
      <param name="anchor">The provider for the dynamic anchor of this instance.</param>
      <param name="size">The provider for the dynamic size of this instance.</param>
      <remarks>
            Creates a new instance using the provided values to initialize the anchor and size.
            The oriented rectangle's up vector will be <c>(0, -1)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>
            Creates a new instance using the provided values to initialize anchor,
            size, and up vector.
            </summary>
      <param name="position">The provider for the dynamic anchor of this instance.</param>
      <param name="size">The provider for the dynamic size of this instance.</param>
      <param name="upVector">The up vector.</param>
      <remarks>
            Creates a new instance using the provided values to initialize anchor,
            size, and up vector.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.#ctor(yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>
            Creates a new instance using the provided rectangle's values to initialize
            anchor and size.
            </summary>
      <param name="rect">the provided rectangle.</param>
      <remarks>
            Creates a new instance using the provided rectangle's values to initialize
            anchor and size. The oriented rectangle's up vector will be
            <c>(0, -1)</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Anchor">
      <summary>The anchor of this oriented rectangle.</summary>
      <remarks>
            Getter:<br />
            Returns the anchor of this oriented rectangle.
            <para />
            Setter:<br />
            Sets the anchor of this rectangle.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.AnchorX">
      <summary>The x-coordinate of this rectangle's anchor point.</summary>
      <remarks>Returns the x-coordinate of this rectangle's anchor point.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.AnchorY">
      <summary>The y-coordinate of this rectangle's anchor point.</summary>
      <remarks>Returns the y-coordinate of this rectangle's anchor point.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Angle">
      <summary>The angle (measured in radians) of this rectangle.</summary>
      <remarks>
            Specifies the angle (measured in radians) of this rectangle.
            The angle of an oriented rectangle is the angle between the vector
            <c>(0, -1)</c> and the rectangle's up vector in counter clockwise
            order.
            An angle of 0 means the up vector points up in direction <c>(0, -1)</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.BoundingBox">
      <summary>Calculates the paraxial bounding box of this oriented rectangle.</summary>
      <remarks>Calculates the paraxial bounding box of this oriented rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.CalcPoints(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle)">
      <summary>Determines the four corner points of an oriented rectangle.</summary>
      <param name="rect">The rectangle to determine the bounds.</param>
      <returns>the array of corner points.</returns>
      <remarks>Determines the four corner points of an oriented rectangle.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Center">
      <summary>The current center of the oriented rectangle.</summary>
      <remarks>
            Getter:<br />
            Returns the current center of the oriented rectangle.
            <para />
            Setter:<br />
            Sets the anchor of the OrientedRectangle so that the center of the
            rectangle coincides with the given point.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Contains(System.Double,System.Double)">
      <summary>
            Determines whether or not the specified point lies inside this oriented
            rectangle.
            </summary>
      <param name="x">the x-coordinate of the point to check.</param>
      <param name="y">the y-coordinate of the point to check.</param>
      <returns>
        <see langword="true" /> iff the specified point lies inside;
            <see langword="false" /> otherwise.
            </returns>
      <remarks>
            Determines whether or not the specified point lies inside this oriented
            rectangle.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Contains(System.Double,System.Double,System.Boolean)">
      <summary>
            Determines whether or not the specified point lies inside this oriented
            rectangle.
            </summary>
      <param name="x">the x-coordinate of the point to check.</param>
      <param name="y">the y-coordinate of the point to check.</param>
      <param name="closed">
            if <see langword="true" />, all points on the border of the
            rectangle are considered to be <em>contained</em>.
            </param>
      <returns>
        <see langword="true" /> iff the specified point lies inside;
            <see langword="false" /> otherwise.
            </returns>
      <remarks>
            Determines whether or not the specified point lies inside this oriented
            rectangle.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Contains(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,System.Double,System.Double,System.Double)">
      <summary>
            Determines whether the given oriented rectangle contains the provided
            point, using an epsilon value.
            </summary>
      <param name="rect">The rectangle.</param>
      <param name="x">x-coordinate of the point to test.</param>
      <param name="y">y-coordinate of the point to test.</param>
      <param name="eps">
            fuzziness range. A positive value allows for fuzzy hit testing.
            If a point lies outside the given rectangle, but its distance is less than
            or equal to that value, it will be considered a hit.
            </param>
      <returns>
        <see langword="true" /> if the point lies inside the rectangle;
            <see langword="false" /> otherwise.
            </returns>
      <remarks>
            Determines whether the given oriented rectangle contains the provided
            point, using an epsilon value.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Contains(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,System.Double)">
      <summary>Determines whether the given rectangle r1 contains rectangle r2, using an epsilon value.</summary>
      <param name="r1">The first rectangle.</param>
      <param name="r2">The second rectangle.</param>
      <param name="eps">
            A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's
            distance is less than or equal to that value, it will be considered a hit.
            </param>
      <returns>true iff the r1 contains r2.</returns>
      <remarks>Determines whether the given rectangle r1 contains rectangle r2, using an epsilon value.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Contains(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Algorithms.Geometry.YPoint,System.Double)">
      <summary>
            Determines whether the given oriented rectangle contains the provided
            point, using an epsilon value.
            </summary>
      <param name="rect">The rectangle.</param>
      <param name="p">The point to test.</param>
      <param name="eps">
            fuzziness range. A positive value allows for fuzzy hit testing.
            If a point lies outside the given rectangle, but its distance is less than
            or equal to that value, it will be considered a hit.
            </param>
      <returns>
        <see langword="true" /> if the point lies inside the rectangle;
            <see langword="false" /> otherwise.
            </returns>
      <remarks>
            Determines whether the given oriented rectangle contains the provided
            point, using an epsilon value.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Empty">
      <summary>Specifies whether this instance has negative width or height.</summary>
      <remarks>Returns whether this instance has negative width or height.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Equals(System.Object)">
      <summary>Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.</summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
      <returns>true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.GetMovedInstance(System.Double,System.Double)">
      <summary>
            Creates a new <c>OrientedRectangle</c> instance whose anchor point
            is moved by the specified distance values, but has the same width, height,
            and up vector as this rectangle.
            </summary>
      <param name="dx">
            the distance to move the anchor point in x-direction. A positive
            value means "move" to the right, a negative value means "move" to the left.
            </param>
      <param name="dy">
            the distance to move the anchor point in y-direction. A positive
            value means "move" downwards, a negative value means "move" upwards.
            </param>
      <returns>
            a new <c>OrientedRectangle</c> instance whose anchor point
            is moved by the specified distance values.
            </returns>
      <remarks>
            Creates a new <c>OrientedRectangle</c> instance whose anchor point
            is moved by the specified distance values, but has the same width, height,
            and up vector as this rectangle.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.GetResizedInstance(System.Double,System.Double)">
      <summary>
            Creates a new <c>OrientedRectangle</c> instance that has the
            specified width and height, but has the same anchor point and up vector
            as this rectangle.
            </summary>
      <param name="width">the width of the new rectangle.</param>
      <param name="height">the height of the new rectangle.</param>
      <returns>
            a new <c>OrientedRectangle</c> instance that has the
            specified width and height.
            </returns>
      <remarks>
            Creates a new <c>OrientedRectangle</c> instance that has the
            specified width and height, but has the same anchor point and up vector
            as this rectangle.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Height">
      <summary>The height of this rectangle.</summary>
      <remarks>Returns the height of this rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.IntersectionPoint(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Algorithms.Geometry.LineSegment,System.Double)">
      <summary>
            Determines an intersection point of the specified oriented rectangle and
            the specified line segment.
            </summary>
      <returns>
            an intersection point of the specified oriented rectangle and
            the specified line segment or <see langword="null" /> if the rectangle and the
            segment do not intersect.
            </returns>
      <remarks>
            Determines an intersection point of the specified oriented rectangle and
            the specified line segment.
            Note: there might be more than one intersection point. However this method only returns one intersection point
            or <see langword="null" /> if there is no intersection.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Intersects(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Algorithms.Geometry.LineSegment,System.Double)">
      <summary>
            Determines whether or not the specified oriented rectangle and the
            specified line segment intersect.
            </summary>
      <returns>
        <see langword="true" /> if the rectangle and the segment intersect and
            <see langword="false" /> otherwise.
            </returns>
      <remarks>
            Determines whether or not the specified oriented rectangle and the
            specified line segment intersect.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Intersects(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Algorithms.Geometry.YRectangle,System.Double)">
      <summary>Determines whether a rectangle intersects an oriented rectangle, given an epsilon.</summary>
      <param name="orientedRectangle">The oriented rectangle to test.</param>
      <param name="rectangle">The rectangle to test.</param>
      <param name="eps">
            A positive value allows for fuzzy hit testing. If the point lies outside the given object
            but it's distance is less than or equal to that value, it will be considered a hit.
            </param>
      <returns>Whether they have a non-empty intersection.</returns>
      <remarks>Determines whether a rectangle intersects an oriented rectangle, given an epsilon.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.MoveBy(System.Double,System.Double)">
      <summary>Moves this rectangle by applying the offset to the anchor.</summary>
      <param name="dx">The x offset to move the rectangle's position by.</param>
      <param name="dy">The y offset to move the rectangle's position by.</param>
      <remarks>Moves this rectangle by applying the offset to the anchor.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.SetAnchor(System.Double,System.Double)">
      <summary>Sets the anchor of this rectangle.</summary>
      <param name="x">the new x-coordinate of the anchor point.</param>
      <param name="y">the new y-coordinate of the anchor point.</param>
      <remarks>Sets the anchor of this rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.SetCenter(System.Double,System.Double)">
      <summary>
            Sets the anchor of the OrientedRectangle so that the center of the
            rectangle coincides with the given coordinate pair.
            </summary>
      <param name="cx">The x coordinate of the center.</param>
      <param name="cy">The y coordinate of the center.</param>
      <remarks>
            Sets the anchor of the OrientedRectangle so that the center of the
            rectangle coincides with the given coordinate pair.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.SetSize(System.Double,System.Double)">
      <summary>Sets the size of this rectangle.</summary>
      <param name="width">the new width.</param>
      <param name="height">the new height.</param>
      <remarks>Sets the size of this rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.SetUpVector(System.Double,System.Double)">
      <summary>Sets the components of the up vector to the new values.</summary>
      <param name="upX">The x component of the normalized up vector.</param>
      <param name="upY">The y component of the normalized up vector.</param>
      <remarks>Sets the components of the up vector to the new values.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Size">
      <summary>The size of this rectangle.</summary>
      <remarks>Specifies the size of this rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.ToString">
      <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
      <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.UpX">
      <summary>The x-component of this rectangle's up vector.</summary>
      <remarks>Returns the x-component of this rectangle's up vector.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.UpY">
      <summary>The y-component of this rectangle's up vector.</summary>
      <remarks>Returns the y-component of this rectangle's up vector.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Width">
      <summary>The width of this rectangle.</summary>
      <remarks>Returns the width of this rectangle.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YPoint">
      <summary>This class represents a point in the plane with double coordinates.</summary>
      <remarks>
            This class represents a point in the plane with double coordinates.
            This class implements the immutable design pattern.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.#ctor">
      <summary>Creates a new YPoint at location (0,0)</summary>
      <remarks>Creates a new YPoint at location (0,0)</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.#ctor(System.Double,System.Double)">
      <summary>Creates a new YPoint object for a given position.</summary>
      <param name="x">the x coordinate of the point.</param>
      <param name="y">the y coordinate of the point.</param>
      <remarks>Creates a new YPoint object for a given position.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Add(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Adds two points and returns the result.</summary>
      <param name="p1">an arbitrary instance of YPoint.</param>
      <param name="p2">an arbitrary instance of YPoint.</param>
      <remarks>Adds two points and returns the result.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.CompareTo(System.Object)">
      <summary>Comparable implementation.</summary>
      <remarks>
            Comparable implementation. YPoints are ordered by ascending x-coordinates.
            If the x-coordinates of two points equal, then these points are ordered by
            ascending y-coordinates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Distance(System.Double,System.Double,System.Double,System.Double)">
      <summary>Returns the euclidean distance between two points.</summary>
      <param name="x1">x-coordinate of first point</param>
      <param name="y1">y-coordinate of first point</param>
      <param name="x2">x-coordinate of second point</param>
      <param name="y2">y-coordinate of second point</param>
      <returns>the euclidean distance between first and second point</returns>
      <remarks>Returns the euclidean distance between two points.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Distance(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Returns the euclidean distance between two points.</summary>
      <param name="p1">an arbitrary point</param>
      <param name="p2">an arbitrary point</param>
      <returns>the Euclidean distance between p1 and p2.</returns>
      <remarks>Returns the euclidean distance between two points.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.DistanceTo(System.Double,System.Double)">
      <summary>Returns the euclidean distance between this point and a given point.</summary>
      <param name="x">the x coordinate of an arbitrary point</param>
      <param name="y">the y coordinate of an arbitrary point</param>
      <returns>the Euclidean distance between this point and the point (x,y).</returns>
      <remarks>Returns the euclidean distance between this point and a given point.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.DistanceTo(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Returns the euclidean distance between this point and a given point.</summary>
      <param name="p">an arbitrary point</param>
      <returns>the Euclidean distance between this point and p.</returns>
      <remarks>Returns the euclidean distance between this point and a given point.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Equals(System.Object)">
      <summary>Tests a point to equality to another point.</summary>
      <param name="o">an arbitrary instance.</param>
      <remarks>
            Tests a point to equality to another point.
            This test returns true if the <c>o</c> is also an instance of
            YPoint and has the same coordinates as the instance on which equals is
            invoked.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.MidPoint(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Returns a point that geometrically lies in
            in the middle of the line formed by the given points.
            </summary>
      <param name="p1">an arbitrary instance of YPoint.</param>
      <param name="p2">an arbitrary instance of YPoint.</param>
      <remarks>
            Returns a point that geometrically lies in
            in the middle of the line formed by the given points.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.MoveBy(System.Double,System.Double)">
      <summary>Returns the point, got by moving this point to another position.</summary>
      <param name="x">the value which is added on the x-coordinate of the point.</param>
      <param name="y">the value which is added on the y-coordinate of the point.</param>
      <returns>
            a new instance of YPoint which is the result of the moving
            operation.
            </returns>
      <remarks>Returns the point, got by moving this point to another position.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Geometry.YPoint.Origin">
      <summary>A YPoint constant with coordinates (0,0).</summary>
      <remarks>A YPoint constant with coordinates (0,0).</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Subtract(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Subtracts two points (p1 - p2) and returns the result.</summary>
      <param name="p1">an arbitrary instance of YPoint.</param>
      <param name="p2">an arbitrary instance of YPoint.</param>
      <remarks>Subtracts two points (p1 - p2) and returns the result.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.Swap(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Returns a copy of the given point with exchanged
            x- and y-coordinates.
            </summary>
      <param name="p">an arbitrary instance of YPoint.</param>
      <remarks>
            Returns a copy of the given point with exchanged
            x- and y-coordinates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPoint.ToString">
      <summary>Returns the coordinates of the point as string.</summary>
      <remarks>Returns the coordinates of the point as string.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YPoint.X">
      <summary>The x-coordinate of the point object.</summary>
      <remarks>Returns the x-coordinate of the point object.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YPoint.Y">
      <summary>The y-coordinate of the point object.</summary>
      <remarks>Returns the y-coordinate of the point object.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YPointPath">
      <summary>This class represents an ordered list of points in the plane.</summary>
      <remarks>This class represents an ordered list of points in the plane.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.#ctor">
      <summary>Creates a new path from a vector.</summary>
      <remarks>Creates a new path from a vector.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint[])">
      <summary>Creates a new path from an array of points.</summary>
      <remarks>Creates a new path from an array of points.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.#ctor(yWorks.yFiles.Util.IList)">
      <summary>Creates a new path from a list of points.</summary>
      <param name="l">
            a list of
            <see cref="T:yWorks.yFiles.Algorithms.Geometry.YPoint" />
            instances.
            </param>
      <remarks>Creates a new path from a list of points.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.CalculateLength">
      <summary>Calculate the (geometric) length of the path.</summary>
      <returns>the (geometric) length of the path</returns>
      <remarks>
            Calculate the (geometric) length of the path.
            The length of the path is the sum of lengths of all line segments making
            up the path.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.CreateReverse">
      <summary>Create a point path with reverse ordering of the points.</summary>
      <remarks>Create a point path with reverse ordering of the points.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.Cursor">
      <summary>Get the points in the path.</summary>
      <remarks>Get the points in the path.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Geometry.YPointPath.EmptyPath">
      <summary>Defines a path with no points.</summary>
      <remarks>Defines a path with no points.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YPointPath.First">
      <summary>The first point in the path.</summary>
      <remarks>Get the first point in the path.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.GetLineSegment(System.Int32)">
      <summary>Returns a line segment in the path.</summary>
      <remarks>Returns a line segment in the path.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.Iterator">
      <summary>Get the points in the path.</summary>
      <remarks>Get the points in the path.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YPointPath.Last">
      <summary>The last point in the path.</summary>
      <remarks>Get the last point in the path.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.Length">
      <summary>Get the number of points in the path.</summary>
      <remarks>Get the number of points in the path.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.LineSegments">
      <summary>Get the points in the path.</summary>
      <remarks>Get the points in the path.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.Points">
      <summary>Get the points in the path.</summary>
      <remarks>Get the points in the path.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.ToArray">
      <summary>Get the points in the list as array.</summary>
      <remarks>Get the points in the list as array.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.ToList">
      <summary>Get the points in the path as list.</summary>
      <returns>
            a list of
            <see cref="T:yWorks.yFiles.Algorithms.Geometry.YPoint" />
            instances.
            </returns>
      <remarks>Get the points in the path as list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YPointPath.ToString">
      <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
      <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YRectangle">
      <summary>This class defines a rectangle and provides utility methods for it.</summary>
      <remarks>This class defines a rectangle and provides utility methods for it.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.#ctor">
      <summary>Creates a new rectangle with upper left corner (0,0) and size (0,0).</summary>
      <remarks>Creates a new rectangle with upper left corner (0,0) and size (0,0).</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>Creates a new rectangle with given upper left corner and size.</summary>
      <param name="x">x-coordinate of upper left corner of the rectangle.</param>
      <param name="y">y-coordinate of upper left corner of the rectangle.</param>
      <param name="width">width of the rectangle.</param>
      <param name="height">height of the rectangle.</param>
      <remarks>Creates a new rectangle with given upper left corner and size.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension)">
      <summary>Creates a new rectangle with given upper left corner and size.</summary>
      <param name="pos">upper left corner of the rectangle.</param>
      <param name="size">size of the rectangle.</param>
      <remarks>Creates a new rectangle with given upper left corner and size.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YRectangle.BoundingBox">
      <summary>This object.</summary>
      <remarks>Returns this object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.CompareTo(System.Object)">
      <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
      <param name="obj">An object to compare with this instance. </param>
      <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj" />. Zero This instance is equal to <paramref name="obj" />. Greater than zero This instance is greater than <paramref name="obj" />. </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance. </exception>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Contains(System.Double,System.Double)">
      <summary>
            Checks whether or not this <c>YRectangle</c> contains the
            given point.
            </summary>
      <param name="x">the x-coordinate of the point to check.</param>
      <param name="y">the x-coordinate of the point to check.</param>
      <returns>
        <see langword="true" /> if the point lies inside the rectangle;
            <see langword="false" /> otherwise.
            </returns>
      <remarks>
            Checks whether or not this <c>YRectangle</c> contains the
            given point.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Contains(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Checks whether or not this <c>YRectangle</c> contains the
            rectangle defined by the given frame.
            </summary>
      <remarks>
            Checks whether or not this <c>YRectangle</c> contains the
            rectangle defined by the given frame.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Contains(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>Determines whether the specified rectangle contains the specified point.</summary>
      <param name="rx">the x-coordinate of the upper left corner of the rectangle.</param>
      <param name="ry">the y-coordinate of the upper left corner of the rectangle.</param>
      <param name="rw">the width of the rectangle.</param>
      <param name="rh">the height of the rectangle.</param>
      <param name="x">the x-coordinate of the point to check.</param>
      <param name="y">the x-coordinate of the point to check.</param>
      <returns>
        <see langword="true" /> if the point lies inside the rectangle;
            <see langword="false" /> otherwise.
            </returns>
      <remarks>Determines whether the specified rectangle contains the specified point.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Contains(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>Determines whether the specified rectangle contains the specified point.</summary>
      <param name="rx">the x-coordinate of the upper left corner of the rectangle.</param>
      <param name="ry">the y-coordinate of the upper left corner of the rectangle.</param>
      <param name="rw">the width of the rectangle.</param>
      <param name="rh">the height of the rectangle.</param>
      <param name="x">the x-coordinate of the point to check.</param>
      <param name="y">the x-coordinate of the point to check.</param>
      <param name="closed">
            if <see langword="true" />, all points on the border of the
            rectangle are considered to be <em>contained</em>.
            </param>
      <returns>
        <see langword="true" /> if the point lies inside the rectangle;
            <see langword="false" /> otherwise.
            </returns>
      <remarks>Determines whether the specified rectangle contains the specified point.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Contains(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Checks whether or not this <c>YRectangle</c> contains the
            given point.
            </summary>
      <remarks>
            Checks whether or not this <c>YRectangle</c> contains the
            given point.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Contains(yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>
            Checks whether or not this <c>YRectangle</c> contains the
            given rectangle.
            </summary>
      <remarks>
            Checks whether or not this <c>YRectangle</c> contains the
            given rectangle.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Equals(System.Object)">
      <summary>Tests a dimension to equality to another dimension.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.Intersects(yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>Returns whether or not the given rectangles intersect.</summary>
      <remarks>Returns whether or not the given rectangles intersect.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YRectangle.Location">
      <summary>Coordinates of upper left corner.</summary>
      <remarks>Returns coordinates of upper left corner.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YRectangle.ToString">
      <summary>Returns a string representation of this rectangle</summary>
      <remarks>Returns a string representation of this rectangle</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YRectangle.X">
      <summary>X-coordinate of upper left corner.</summary>
      <remarks>Returns x-coordinate of upper left corner.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YRectangle.Y">
      <summary>Y-coordinate of upper left corner.</summary>
      <remarks>Returns y-coordinate of upper left corner.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Geometry.YVector">
      <summary>This class represents a vector in the 2-dimensional real vector space.</summary>
      <remarks>
            This class represents a vector in the 2-dimensional real vector space.
            This vector is an ordered 2 tuple and is defined by two doubles.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.#ctor(System.Double,System.Double)">
      <summary>Creates a new vector with given direction.</summary>
      <param name="dx">the first coordinate</param>
      <param name="dy">the second coordinate</param>
      <remarks>Creates a new vector with given direction.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>Creates a new vector, whose direction is given by two points.</summary>
      <param name="x1">the X-coordinate of the first point.</param>
      <param name="y1">the Y-coordinate of the first point.</param>
      <param name="x2">the X-coordinate of the second point.</param>
      <param name="y2">the Y-coordinate of the second point.</param>
      <remarks>
            Creates a new vector, whose direction is given by two points.
            The vector is defined by <c>(x1 - x2, y1 - y2)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Creates a new vector, whose direction is given by a point.</summary>
      <param name="p1">the point.</param>
      <remarks>
            Creates a new vector, whose direction is given by a point.
            The vector is defined by <c>p1</c> - (0,0).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Creates a new vector, whose direction is given by two points.</summary>
      <param name="p1">the first point.</param>
      <param name="p2">the second point.</param>
      <remarks>
            Creates a new vector, whose direction is given by two points.
            The vector is defined by <c>p1</c> - <c>p2</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.#ctor(yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Creates a new vector which is a copy of another vector.</summary>
      <param name="v">the vector, whose values are copied.</param>
      <remarks>Creates a new vector which is a copy of another vector.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Add(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Adds the vector to a point and returns the resulting point.</summary>
      <param name="p">a point.</param>
      <param name="v">the vector to add to the point.</param>
      <returns>p+v</returns>
      <remarks>Adds the vector to a point and returns the resulting point.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Add(yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Adds a vector to this vector.</summary>
      <param name="v">the vector to add.</param>
      <remarks>Adds a vector to this vector.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Add(yWorks.yFiles.Algorithms.Geometry.YVector,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Adds two vectors and returns the result.</summary>
      <param name="v">first vector to sum.</param>
      <param name="w">second vector to sum.</param>
      <returns>v+w</returns>
      <remarks>Adds two vectors and returns the result.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Angle(yWorks.yFiles.Algorithms.Geometry.YVector,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>
            Returns the angle (measured in radians) between two vectors in
            clockwise order (with regards to screen coordinates) from v1 to v2.
            </summary>
      <remarks>
            Returns the angle (measured in radians) between two vectors in
            clockwise order (with regards to screen coordinates) from v1 to v2.
            Screen coordinates mean positive x-direction is from left to right and
            positive y-direction is from top to bottom:
            <pre>
            0 --&gt; 1
            |
            v
            1
            </pre>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.GetNormal(yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Returns this vector with unit length.</summary>
      <remarks>Returns this vector with unit length.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Length">
      <summary>Returns the length of the vector, this is the value of the euclidean norm.</summary>
      <returns>a value &gt; 0.</returns>
      <remarks>Returns the length of the vector, this is the value of the euclidean norm.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Norm">
      <summary>Assigns unit length to the vector.<br /></summary>
      <remarks>Assigns unit length to the vector.<br /></remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.OrthoNormal(yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>
            Returns the vector which is orthogonal to the given one and has unit
            length.
            </summary>
      <param name="v">a vector.</param>
      <returns>a vector which is orthogonal to v with unit length.</returns>
      <remarks>
            Returns the vector which is orthogonal to the given one and has unit
            length.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.RightOf(yWorks.yFiles.Algorithms.Geometry.YVector,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Returns true if vector v1 is on the right side of v2.</summary>
      <remarks>Returns true if vector v1 is on the right side of v2.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Rotate(System.Double)">
      <summary>
            Returns a new <c>YVector</c> instance that is obtained by rotating
            this vector by the given angle (measured in radians) in clockwise
            direction (with regards to screen coordinates).
            </summary>
      <param name="angle">the angle of rotation in radians.</param>
      <returns>the rotated vector.</returns>
      <remarks>
            Returns a new <c>YVector</c> instance that is obtained by rotating
            this vector by the given angle (measured in radians) in clockwise
            direction (with regards to screen coordinates).
            Screen coordinates mean positive x-direction is from left to right and
            positive y-direction is from top to bottom:
            <pre>
            0 --&gt; 1
            |
            v
            1
            </pre>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.ScalarProduct(yWorks.yFiles.Algorithms.Geometry.YVector,yWorks.yFiles.Algorithms.Geometry.YVector)">
      <summary>Returns the value of the scalar product of two vectors.</summary>
      <param name="v1">the first vector.</param>
      <param name="v2">the second vector.</param>
      <returns>
        <c>v1.x * v2.x + v1.y * v2.y</c>
      </returns>
      <remarks>Returns the value of the scalar product of two vectors.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.Scale(System.Double)">
      <summary>Scales the vector by an factor.</summary>
      <param name="factor">the scale factor, with which the length is multiplied.</param>
      <remarks>Scales the vector by an factor.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Geometry.YVector.ToString">
      <summary>Returns a string representation of this vector.</summary>
      <remarks>Returns a string representation of this vector.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YVector.X">
      <summary>The first coordinate of the vector.</summary>
      <remarks>Returns the first coordinate of the vector.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Geometry.YVector.Y">
      <summary>The second coordinate of the vector.</summary>
      <remarks>Returns the second coordinate of the vector.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ">
      <summary>
            Implements a priority queue for nodes based on a
            array with bucket lists.
            </summary>
      <remarks>
            Implements a priority queue for nodes based on a
            array with bucket lists.
            The priority values must be less than a maximal-value
            which must be provided to the constructor.
            Certain operations have time-complexity dependent on this value.
            The priority values of the nodes must be non-negative.
            While the priority queue is used, the graph must not change.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,System.Int32)">
      <summary>Returns an empty Priority-Queue.</summary>
      <param name="_graph">the graph which contains the nodes</param>
      <param name="maxSize">the maximum value of a node in the priority queue</param>
      <remarks>Returns an empty Priority-Queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns a new Priority-Queue initialized with all nodes of the graph.</summary>
      <param name="_graph">the graph which contains the nodes</param>
      <param name="_initValues">the initial priority values of the nodes.</param>
      <remarks>Returns a new Priority-Queue initialized with all nodes of the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Returns an empty Priority-Queue.</summary>
      <param name="_graph">the graph which contains the nodes</param>
      <param name="_valueMap">here the priority values are stored</param>
      <param name="maxSize">the maximum value of a node in the priority queue</param>
      <remarks>
            Returns an empty Priority-Queue.
            This constructor takes a <c>NodeMap</c> as argument
            which is used to store the priority values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Inserts a node into the queue.</summary>
      <remarks>Inserts a node into the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.ChangePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Changes the value of a node in the queue to a certain value.</summary>
      <param name="n">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
      <remarks>Changes the value of a node in the queue to a certain value.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Clear">
      <summary>Removes all entries from the queue.</summary>
      <remarks>Removes all entries from the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is contained within this queue.</summary>
      <remarks>Returns whether or not the given node is contained within this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Decreases the value of a node in the queue to a certain value.<br /></summary>
      <param name="n">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
      <remarks>Decreases the value of a node in the queue to a certain value.<br /></remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Dispose">
      <summary>Disposes this queue.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
      <remarks>Returns whether or not this queue is empty.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.GetList(System.Int32)">
      <summary>Returns the list for a given slot.</summary>
      <remarks>
            Returns the list for a given slot.
            If there is no list yet, create one.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.IncreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Increases the value of a node in the queue to a certain value.<br /></summary>
      <param name="n">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
      <remarks>Increases the value of a node in the queue to a certain value.<br /></remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Min">
      <summary>The node with the minimal value in the queue.<br /></summary>
      <remarks>Returns the node with the minimal value in the queue.<br /></remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Removes a node from the priority queue.<br />
            Time complexity in worst-case O(maxSize).
            </summary>
      <remarks>
            Removes a node from the priority queue.<br />
            Time complexity in worst-case O(maxSize).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.RemoveMin">
      <summary>
            Removes the node with the minimal value from the queue.<br />
            Time complexity like
            <see cref="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)" />
            .
            </summary>
      <remarks>
            Removes the node with the minimal value from the queue.<br />
            Time complexity like
            <see cref="M:yWorks.yFiles.Algorithms.Util.ArrayIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ">
      <summary>
            This class implements a priority queue for nodes whose priority
            values are of type double.
            </summary>
      <remarks>
            This class implements a priority queue for nodes whose priority
            values are of type double.
            <p />
            The implementation is based on binary heaps.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Creates an empty NodePQ for nodes contained
            in the given graph.
            </summary>
      <remarks>
            Creates an empty NodePQ for nodes contained
            in the given graph.
            Neither the node set nor the indices of the nodes
            of the given graph may change while this queue is being used.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Adds the given node with with given priority to this queue.</summary>
      <remarks>Adds the given node with with given priority to this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.ChangePriority(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Changes the priority value of the given node.</summary>
      <remarks>Changes the priority value of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
      <remarks>
            Makes this queue the empty queue.
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
      <remarks>
            Returns whether or not the given node is contained
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Decreases the priority value of the given node.</summary>
      <remarks>Decreases the priority value of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Dispose">
      <summary>Does nothing.</summary>
      <remarks>Does nothing.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
      <remarks>Returns whether or not this queue is empty</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
      <remarks>Returns the current priority of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.IncreasePriority(yWorks.yFiles.Algorithms.Node,System.Double)" />
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
      <remarks>Returns he node with smallest priority in this queue.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.MinPriority">
      <summary>The minimum priority value in this queue.</summary>
      <remarks>Returns the minimum priority value in this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes the given node from this queue.</summary>
      <remarks>Removes the given node from this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue</summary>
      <returns>the removed node with smallest priority</returns>
      <remarks>Removes the node with smallest priority from this queue</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
      <remarks>Returns the number of nodes currently in this queue</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ">
      <summary>
            This class implements a priority queue for nodes whose priority
            values are of type int.
            </summary>
      <remarks>
            This class implements a priority queue for nodes whose priority
            values are of type int.
            <p>
            The implementation is based on binary heaps.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Creates an empty NodePQ for nodes contained
            in the given graph.
            </summary>
      <remarks>
            Creates an empty NodePQ for nodes contained
            in the given graph.
            Neither the node set nor the indices of the nodes
            of the given graph may change while this queue is being used.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Adds the given node with with given priority to this queue.</summary>
      <remarks>Adds the given node with with given priority to this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.ChangePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Changes the priority value of the given node.</summary>
      <remarks>Changes the priority value of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
      <remarks>
            Makes this queue the empty queue.
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
      <remarks>
            Returns whether or not the given node is contained
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Decreases the priority value of the given node.</summary>
      <remarks>Decreases the priority value of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Dispose">
      <summary>Does nothing.</summary>
      <remarks>Does nothing.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
      <remarks>Returns whether or not this queue is empty</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
      <remarks>Returns the current priority of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.IncreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Increases the priority value of the given node.</summary>
      <remarks>Increases the priority value of the given node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
      <remarks>Returns he node with smallest priority in this queue.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.MinPriority">
      <summary>The minimum priority value in this queue.</summary>
      <remarks>Returns the minimum priority value in this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes the given node from this queue.</summary>
      <remarks>Removes the given node from this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue</summary>
      <returns>the removed node with smallest priority</returns>
      <remarks>Removes the node with smallest priority from this queue</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapIntNodePQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
      <remarks>Returns the number of nodes currently in this queue</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.BHeapNodePQ">
      <summary>
            This class represents a priority queue for nodes where
            the priority values are of type Object
            The implementation is based on binary heaps.
            </summary>
      <remarks>
            This class represents a priority queue for nodes where
            the priority values are of type Object
            The implementation is based on binary heaps.
            <p />
            In case the priority values are of type double then using
            <see cref="T:yWorks.yFiles.Algorithms.Util.BHeapDoubleNodePQ" />
            is slightly more efficient than using this generic NodePQ.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,System.Collections.IComparer)">
      <summary>
            Creates an empty NodePQ for nodes contained
            in the given graph.
            </summary>
      <remarks>
            Creates an empty NodePQ for nodes contained
            in the given graph. The given comparator
            must be able to compare all nodes residing in this
            queue by their priority.
            Neither the node set nor the indices of the nodes
            of the given graph may change while this queue is being used.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,System.Collections.IComparer,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Creates an empty NodePQ for nodes contained
            in the given graph.
            </summary>
      <remarks>
            Creates an empty NodePQ for nodes contained
            in the given graph. The given comparator
            must be able to compare all nodes residing in this
            queue by their priority.
            By providing a NodeMap that can handle dynamic
            changes of its definition range this queue will
            be enabled to function even when the node set of
            the given graph changes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Adds the given node with with given priority to this queue.</summary>
      <remarks>Adds the given node with with given priority to this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.ChangePriority(yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Changes the priority value of the given node.</summary>
      <remarks>Changes the priority value of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
      <remarks>
            Makes this queue the empty queue.
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
      <remarks>
            Returns whether or not the given node is contained
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Decreases the priority value of the given node.</summary>
      <remarks>Decreases the priority value of the given node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
      <remarks>Returns whether or not this queue is empty</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
      <remarks>Returns the current priority of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.IncreasePriority(yWorks.yFiles.Algorithms.Node,System.Object)" />
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
      <remarks>Returns he node with smallest priority in this queue.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.MinPriority">
      <summary>The minimum priority value in this queue.</summary>
      <remarks>Returns the minimum priority value in this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes the given node from this queue.</summary>
      <remarks>Removes the given node from this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue</summary>
      <returns>the removed node with smallest priority</returns>
      <remarks>Removes the node with smallest priority from this queue</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.BHeapNodePQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
      <remarks>Returns the number of nodes currently in this queue</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Comparators">
      <summary>
            This class provides access to some Comparator instances
            that are commonly used in yFiles.
            </summary>
      <remarks>
            This class provides access to some Comparator instances
            that are commonly used in yFiles.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.Compare(System.Double,System.Double)">
      <summary>Compares the specified floating point numbers.</summary>
      <param name="d1">the first number to compare.</param>
      <param name="d2">the second number to compare.</param>
      <returns>
            a negative integer, zero, or a positive integer as the first
            argument is less than, equal to, or greater than the second.
            </returns>
      <remarks>
            Compares the specified floating point numbers.
            Returns a negative integer, zero, or a positive integer as the first
            argument is less than, equal to, or greater than the second.
            <p>
            <b>Warning:</b> This method does <b>not</b> handle <c>NaN</c>!
            If you need <c>NaN</c>-safe comparison, use
            <see cref="!:double.Compare(double,double)" />
            instead.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.Compare(System.Int32,System.Int32)">
      <summary>Compares the specified integral numbers.</summary>
      <param name="i1">the first number to compare.</param>
      <param name="i2">the second number to compare.</param>
      <returns>
            a negative integer, zero, or a positive integer as the first
            argument is less than, equal to, or greater than the second.
            </returns>
      <remarks>
            Compares the specified integral numbers.
            Returns a negative integer, zero, or a positive integer as the first
            argument is less than, equal to, or greater than the second.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.Compare(System.Int64,System.Int64)">
      <summary>Compares the specified integral numbers.</summary>
      <param name="l1">the first number to compare.</param>
      <param name="l2">the second number to compare.</param>
      <returns>
            a negative integer, zero, or a positive integer as the first
            argument is less than, equal to, or greater than the second.
            </returns>
      <remarks>
            Compares the specified integral numbers.
            Returns a negative integer, zero, or a positive integer as the first
            argument is less than, equal to, or greater than the second.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.Compare(System.Single,System.Single)">
      <summary>Compares the specified floating point numbers.</summary>
      <param name="f1">the first number to compare.</param>
      <param name="f2">the second number to compare.</param>
      <returns>
            a negative integer, zero, or a positive integer as the first
            argument is less than, equal to, or greater than the second.
            </returns>
      <remarks>
            Compares the specified floating point numbers.
            Returns a negative integer, zero, or a positive integer as the first
            argument is less than, equal to, or greater than the second.
            <p>
            <b>Warning:</b> This method does <b>not</b> handle <c>NaN</c>!
            If you need <c>NaN</c>-safe comparison, use
            <see cref="!:float.Compare(float,float)" />
            instead.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateComparableComparator">
      <summary>
            Returns a comparator that compares to Objects of type
            Comparable.
            </summary>
      <remarks>
            Returns a comparator that compares to Objects of type
            Comparable.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateComparableDataComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns a comparator that compares objects of arbitrary type.</summary>
      <param name="dp">
            a data provider that must return a Comparable for
            each object that is being compared by this comparator.
            </param>
      <returns>a comparator that compares arbitrary objects.</returns>
      <remarks>
            Returns a comparator that compares objects of arbitrary type.
            Two objects are compared by comparing the <c>Comparable</c> instances
            the given data provider returns for each of these objects.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateDoubleDataComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns a comparator that compares objects of arbitrary type.</summary>
      <param name="dp">
            a data provider that must return a double value for
            each object that is being compared by this comparator.
            </param>
      <returns>a comparator that compares arbitrary objects.</returns>
      <remarks>
            Returns a comparator that compares objects of arbitrary type.
            Two objects are compared by comparing the double value the given
            data provider returns for each of these objects.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateDoubleDataSourceComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            .
            </summary>
      <param name="dp">
            a data provider that must return a double value for
            the source node of each edge being compared.
            </param>
      <returns>a comparator that compares edges.</returns>
      <remarks>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            . Two edges are compared by comparing their
            source nodes. Each source node <c>e.source()</c> in turn
            is compared by the double value provided by the given data provider:
            <c>dp.getDouble(e.source())</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateDoubleDataTargetComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            .
            </summary>
      <param name="dp">
            a data provider that must return a double value for
            the target node of each edge being compared.
            </param>
      <returns>a comparator that compares edges.</returns>
      <remarks>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            . Two edges are compared by comparing their
            target nodes. Each target node <c>e.target()</c> in turn
            is compared by the double value provided by the given data provider:
            <c>dp.getDouble(e.target())</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateIntDataComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns a comparator that compares objects of arbitrary type.</summary>
      <param name="dp">
            a data provider that must return an int value for
            each object that is being compared by this comparator.
            </param>
      <returns>a comparator that compares arbitrary objects.</returns>
      <remarks>
            Returns a comparator that compares objects of arbitrary type.
            Two objects are compared by comparing the int value the given
            data provider returns for each of these objects.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateIntDataSourceComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            .
            </summary>
      <param name="dp">
            a data provider that must return an int value for
            the source node of each edge being compared.
            </param>
      <returns>a comparator that compares edges.</returns>
      <remarks>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            . Two edges are compared by comparing their
            source nodes. Each source node <c>e.source()</c> in turn
            is compared by the int value provided by the given data provider:
            <c>dp.getInt(e.source())</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.CreateIntDataTargetComparator(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            .
            </summary>
      <param name="dp">
            a data provider that must return an int value for
            the target node of each edge being compared.
            </param>
      <returns>a comparator that compares edges.</returns>
      <remarks>
            Returns a comparator that compares objects of type
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            . Two edges are compared by comparing their
            target nodes. Each target node <c>e.target()</c> in turn
            is compared by the int value provided by the given data provider:
            <c>dp.getInt(e.target())</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.Sort(System.Array,System.Collections.IComparer)">
      <summary>
            Sorts the specified array of objects according to the order induced by
            the specified comparator.
            </summary>
      <param name="data">the array to be sorted.</param>
      <param name="c">
            the comparator to determine the order of the array.
            A <see langword="null" /> value indicates that the elements'
            <see cref="T:System.IComparable">natural ordering</see>
            should be used.
            </param>
      <remarks>
            Sorts the specified array of objects according to the order induced by
            the specified comparator.
            <p>
            This sort is guaranteed to be <em>stable</em>:
            Equal elements will not be reordered as a result of the sort.
            </p><p>
            Implementation note:
            If the comparator is marked with the
            <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators.IPartialOrder" />
            interface,
            this implementation is behavior-compatible with the pre-Java-7 version of
            <see cref="!:yWorks.yFiles.Util.Arrays.Sort(object[],System.Collections.IComparer)" />
            in the sense
            that it does not throw <c>IllegalArgumentException</c> if the
            specified comparator used for sorting does not define a total order.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
      <summary>
            Sorts the specified array of objects according to the order induced by
            the specified comparator.
            </summary>
      <param name="data">the array to be sorted.</param>
      <param name="fromIndex">the index of the first element (inclusive) to be sorted.</param>
      <param name="toIndex">the index of the last element (exclusive) to be sorted.</param>
      <param name="c">
            the comparator to determine the order of the array.
            A <see langword="null" /> value indicates that the elements'
            <see cref="T:System.IComparable">natural ordering</see>
            should be used.
            </param>
      <exception cref="T:System.ArgumentException">if <c>fromIndex &gt; toIndex</c>.</exception>
      <exception cref="T:System.IndexOutOfRangeException">
            if <c>fromIndex &lt; 0</c> or
            <c>toIndex &gt; a.length</c>.
            </exception>
      <remarks>
            Sorts the specified array of objects according to the order induced by
            the specified comparator.
            <p>
            This sort is guaranteed to be <em>stable</em>:
            Equal elements will not be reordered as a result of the sort.
            </p><p>
            Implementation note:
            If the comparator is marked with the
            <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators.IPartialOrder" />
            interface,
            this implementation is behavior-compatible with the pre-Java-7 version of
            <see cref="!:yWorks.yFiles.Util.Arrays.Sort(object[],int,int,System.Collections.IComparer)" />
            in the sense that it does not throw <c>IllegalArgumentException</c>
            if the specified comparator used for sorting does not define a total order.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Comparators.Sort(yWorks.yFiles.Util.IList,System.Collections.IComparer)">
      <summary>
            Sorts the specified list of objects according to the order induced by
            the specified comparator.
            </summary>
      <param name="data">the list to be sorted.</param>
      <param name="c">
            the comparator to determine the order of the list.
            A <see langword="null" /> value indicates that the elements'
            <see cref="T:System.IComparable">natural ordering</see>
            should be used.
            </param>
      <remarks>
            Sorts the specified list of objects according to the order induced by
            the specified comparator.
            <p>
            This sort is guaranteed to be <em>stable</em>:
            Equal elements will not be reordered as a result of the sort.
            </p><p>
            Implementation note:
            If the comparator is marked with the
            <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators.IPartialOrder" />
            interface,
            this implementation is behavior-compatible with the pre-Java-7 version of
            <see cref="M:yWorks.yFiles.Util.Collections.Sort(yWorks.yFiles.Util.IList,System.Collections.IComparer)" />
            in the sense that it does not throw <c>IllegalArgumentException</c>
            if the specified comparator used for sorting does not define a total order.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Comparators.IPartialOrder">
      <summary>
            Tag interface to mark comparator or comparable implementations that do not
            define a total order but only a partial order.
            </summary>
      <remarks>
            Tag interface to mark comparator or comparable implementations that do not
            define a total order but only a partial order. Implementations tagged with this
            interface use a special sorting algorithm that is behavior-compatible with the
            pre-Java-7 sorting algorithms in the sense that it does not throw <c>IllegalArgumentException</c>
            if the specified comparator used for sorting does not define a total order.
            </remarks>
      <remarks>
            Tag interface to mark comparator or comparable implementations that do not
            define a total order but only a partial order. Implementations tagged with this
            interface use a special sorting algorithm that is behavior-compatible with the
            pre-Java-7 sorting algorithms in the sense that it does not throw <c>IllegalArgumentException</c>
            if the specified comparator used for sorting does not define a total order.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Cursors">
      <summary>
            This class contains only static methods, that can be used in conjunction with
            objects of type
            <see cref="T:yWorks.yFiles.Algorithms.ICursor" />
            and
            <see cref="T:yWorks.yFiles.Util.IIterator" />
            .
            </summary>
      <remarks>
            This class contains only static methods, that can be used in conjunction with
            objects of type
            <see cref="T:yWorks.yFiles.Algorithms.ICursor" />
            and
            <see cref="T:yWorks.yFiles.Util.IIterator" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.Concatenate(yWorks.yFiles.Algorithms.ICursor,yWorks.yFiles.Algorithms.ICursor)">
      <summary>
            Creates a new cursor that provides a logical view
            on the concatenation of the two given cursors.
            </summary>
      <param name="c1">- first concatenation argument</param>
      <param name="c2">- second concatenation argument</param>
      <remarks>
            Creates a new cursor that provides a logical view
            on the concatenation of the two given cursors.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.CreateCursor``1(System.Collections.Generic.ICollection{``0})">
      <summary>Creates a cursor view of the given collection.</summary>
      <param name="c">
            
            The collection.
            </param>
      <returns>
            
            The cursor view of the given collection.
            </returns>
      <remarks>
            Creates an ICursor view of the given collection.
            <p />
            Note that the returned cursor does not support the
            <see cref="M:yWorks.yFiles.Algorithms.ICursor.Prev">prev</see>
            and
            <see cref="M:yWorks.yFiles.Algorithms.ICursor.ToLast">toLast</see>
            
            operations.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.CreateCursor(yWorks.yFiles.Util.ICollection)">
      <summary>Creates a YCursor view of the given collection.</summary>
      <param name="c">
            
            The collection.
            </param>
      <returns>
            
            The cursor view of the given collection.
            </returns>
      <remarks>
            Creates a YCursor view of the given collection.
            <p />
            Note that the returned cursor does not support the
            <see cref="M:yWorks.yFiles.Algorithms.ICursor.Prev">prev</see>
            and
            <see cref="M:yWorks.yFiles.Algorithms.ICursor.ToLast">toLast</see>
            
            operations.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.CreateIterator(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Creates a first-to-last <c>Iterator</c> view of the given cursor.</summary>
      <param name="cursor">The cursor.</param>
      <returns>The iterator view of the given cursor.</returns>
      <remarks>
            Creates a first-to-last <c>Iterator</c> view of the given cursor.
            <p>
            Note that the returned iterator does not support the
            <see cref="M:yWorks.yFiles.Util.IIterator.Remove">remove</see>
            operation.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.CreateReverseIterator(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Creates a last-to-first <c>Iterator</c> view of the given cursor.</summary>
      <param name="cursor">The cursor.</param>
      <returns>The iterator view of the given cursor.</returns>
      <remarks>
            Creates a last-to-first <c>Iterator</c> view of the given cursor.
            <p>
            Note that the returned iterator does not support the
            <see cref="M:yWorks.yFiles.Util.IIterator.Remove">remove</see>
            operation.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Cursors.ToArray(yWorks.yFiles.Algorithms.ICursor,System.Object[])">
      <summary>Creates or fills an array with the values provided by the cursor</summary>
      <param name="cursor">the cursor</param>
      <param name="dest">
            the array to fill with the values or <see langword="null" /> if the
            method should create the array itself
            </param>
      <returns>dest or a newly created array filled with the values from cursor</returns>
      <remarks>Creates or fills an array with the values provided by the cursor</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter">
      <summary>An abstract adapter class for accepting data.</summary>
      <remarks>
            An abstract adapter class for accepting data. The data accepting methods
            in this class throw a
            <see cref="T:System.NotSupportedException" />
            and
            <see cref="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.Defined(System.Object)" />
            always returns <see langword="false" />.
            <p>
            This class exists as a convenience for creating data acceptor objects.
            </p><p>
            Extend this class to access either typed or untyped data for a
            certain lookup domain.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.Defined(System.Object)">
      <summary>Returns <see langword="false" /> for all data holders.</summary>
      <returns>
        <see langword="false" />.</returns>
      <remarks>
            Returns <see langword="false" /> for all data holders. Subclasses
            should override this method to make clear for which data holders
            there is a value accessible via this data provider.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.Set(System.Object,System.Object)">
      <summary>
            Subclasses may override this
            method to set object values associated with a data holder.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
      <remarks>
            Subclasses may override this
            method to set object values associated with a data holder.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.SetBool(System.Object,System.Boolean)">
      <summary>
            Subclasses may override this
            method to set boolean values associated with a data holder.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
      <remarks>
            Subclasses may override this
            method to set boolean values associated with a data holder.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.SetDouble(System.Object,System.Double)">
      <summary>
            Subclasses may override this
            method to set double values associated with a data holder.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
      <remarks>
            Subclasses may override this
            method to set double values associated with a data holder.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataAcceptorAdapter.SetInt(System.Object,System.Int32)">
      <summary>
            Subclasses may override this
            method to set integer values associated with a data holder.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
      <remarks>
            Subclasses may override this
            method to set integer values associated with a data holder.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.DataProviderAdapter">
      <summary>An abstract adapter class for providing data.</summary>
      <remarks>
            An abstract adapter class for providing data. The data provision methods
            in this class throw a
            <see cref="T:System.NotSupportedException" />
            and
            <see cref="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.Defined(System.Object)" />
            always returns <see langword="false" />.
            <p>
            This class exists as a convenience for creating data provider objects.
            </p><p>
            Extend this class to provide either typed or untyped data for a
            certain lookup domain.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.DataProviderAdapter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.Defined(System.Object)">
      <summary>Returns <see langword="false" /> for all data holders.</summary>
      <returns>
        <see langword="false" />.</returns>
      <remarks>
            Returns <see langword="false" /> for all data holders. Subclasses
            should override this method to make clear for which data holders
            there is a value accessible via this data provider.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.Get(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to object values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
      <remarks>
            Subclasses may override this
            method to provide access to object values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.GetBool(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to boolean values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
      <remarks>
            Subclasses may override this
            method to provide access to boolean values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.GetDouble(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to double values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
      <remarks>
            Subclasses may override this
            method to provide access to double values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviderAdapter.GetInt(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to integer values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
      <remarks>
            Subclasses may override this
            method to provide access to integer values.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.DataProviders">
      <summary>This class provides convenience and transformation services for DataProviders.</summary>
      <remarks>This class provides convenience and transformation services for DataProviders.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.DataProviders" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateConstantDataProvider(System.Object)">
      <summary>
            Returns a DataProvider that returns the given value for each
            key.
            </summary>
      <param name="data">constant Object data returned by the created data provider.</param>
      <returns>a data provider view of a single value.</returns>
      <remarks>
            Returns a DataProvider that returns the given value for each
            key.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Boolean[])">
      <summary>Returns a DataProvider view  of a boolean array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a data provider view of the given array</returns>
      <remarks>
            Returns a DataProvider view  of a boolean array defined for edges.
            The boolean value <c>data[edge.index()]</c> will be returned
            by the data provider upon the method call <c>getBool(edge)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Double[])">
      <summary>Returns a DataProvider view  of a double array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a data provider view of the given array</returns>
      <remarks>
            Returns a DataProvider view  of a double array defined for edges.
            The double value <c>data[edge.index()]</c> will be returned
            by the data provider upon the method call <c>getDouble(edge)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
            Returns a DataProvider view  of a double, int, boolean and Object
            array defined for edges.
            </summary>
      <param name="doubleData">double data for each edge of a static graph</param>
      <param name="intData">int data for each edge of a static graph</param>
      <param name="boolData">boolean data for each edge of a static graph</param>
      <param name="objectData">Object data for each edge of a static graph</param>
      <returns>a data provider view of the given arrays</returns>
      <remarks>
            Returns a DataProvider view  of a double, int, boolean and Object
            array defined for edges.
            <p />
            The double value <c>doubleData[edge.index()]</c> will be returned
            by the data provider upon the method call <c>getDouble(edge)</c>.
            <p />
            The int value <c>intData[edge.index()]</c> will be returned
            by the data provider upon the method call <c>getInt(edge)</c>.
            <p />
            The boolean value <c>boolData[edge.index()]</c> will be returned
            by the data provider upon the method call <c>getBool(edge)</c>.
            <p />
            The Object value <c>objectData[edge.index()]</c> will be returned
            by the data provider upon the method call <c>get(edge)</c>.
            <p />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Int32[])">
      <summary>Returns a DataProvider view  of an int array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a data provider view of the given array</returns>
      <remarks>
            Returns a DataProvider view  of an int array defined for edges.
            The int value <c>data[edge.index()]</c> will be returned
            by the data provider upon the method call <c>getInt(edge)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Object[])">
      <summary>Returns a DataProvider view  of an Object array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a data provider view of the given array</returns>
      <remarks>
            Returns a DataProvider view  of an Object array defined for edges.
            The Object value <c>data[edge.index()]</c> will be returned
            by the data provider upon the method call <c>get(edge)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNegatedDataProvider(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a DataProvider that returns the negated boolean values
            provided by another data provider.
            </summary>
      <remarks>
            Returns a DataProvider that returns the negated boolean values
            provided by another data provider.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Boolean[])">
      <summary>Returns a DataProvider view  of a boolean array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a data provider view of the given array</returns>
      <remarks>
            Returns a DataProvider view  of a boolean array defined for nodes.
            The boolean value <c>data[node.index()]</c> will be returned
            by the data provider upon the method call <c>getBool(node)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Double[])">
      <summary>Returns a DataProvider view  of a double array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a data provider view of the given array</returns>
      <remarks>
            Returns a DataProvider view  of a double array defined for nodes.
            The double value <c>data[node.index()]</c> will be returned
            by the data provider upon the method call <c>getDouble(node)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
            Returns a DataProvider view  of a double, int, boolean and Object
            array defined for nodes.
            </summary>
      <param name="doubleData">double data for each node of a static graph</param>
      <param name="intData">int data for each node of a static graph</param>
      <param name="boolData">boolean data for each node of a static graph</param>
      <param name="objectData">Object data for each node of a static graph</param>
      <returns>a data provider view of the given arrays</returns>
      <remarks>
            Returns a DataProvider view  of a double, int, boolean and Object
            array defined for nodes.
            <p />
            The double value <c>doubleData[node.index()]</c> will be returned
            by the data provider upon the method call <c>getDouble(node)</c>.
            <p />
            The int value <c>intData[node.index()]</c> will be returned
            by the data provider upon the method call <c>getInt(node)</c>.
            <p />
            The boolean value <c>boolData[node.index()]</c> will be returned
            by the data provider upon the method call <c>getBool(node)</c>.
            <p />
            The Object value <c>objectData[node.index()]</c> will be returned
            by the data provider upon the method call <c>get(node)</c>.
            <p />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Int32[])">
      <summary>Returns a DataProvider view  of an int array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a data provider view of the given array</returns>
      <remarks>
            Returns a DataProvider view  of an int array defined for nodes.
            The int value <c>data[node.index()]</c> will be returned
            by the data provider upon the method call <c>getInt(node)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Object[])">
      <summary>Returns a DataProvider view  of an Object array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a data provider view of the given array</returns>
      <remarks>
            Returns a DataProvider view  of an Object array defined for nodes.
            The Object value <c>data[node.index()]</c> will be returned
            by the data provider upon the method call <c>get(node)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateSourceDataProvider(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a DataProvider for edges that return the data provider values
            bound to their source nodes.
            </summary>
      <remarks>
            Returns a DataProvider for edges that return the data provider values
            bound to their source nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.CreateTargetDataProvider(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Returns a DataProvider for edges that return the data provider values
            bound to their target nodes.
            </summary>
      <remarks>
            Returns a DataProvider for edges that return the data provider values
            bound to their target nodes.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.DataProviders.DataProviderOverlayManager">
      <summary>
            This helper class can be used to overlay DataProviders registered at a graph
            with another DataProvider.
            </summary>
      <remarks>
            This helper class can be used to overlay DataProviders registered at a graph
            with another DataProvider.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.DataProviderOverlayManager.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Creates a data provider overlay for the given graph instance.</summary>
      <remarks>Creates a data provider overlay for the given graph instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.DataProviderOverlayManager.AddDataProvider(System.Object,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Adds the given DataProvider under the given key to the graph.</summary>
      <remarks>
            Adds the given DataProvider under the given key to the graph. Stores the previously set
            DataProvider instance so it can be restored at a later time using method {
            <see cref="M:yWorks.yFiles.Algorithms.Util.DataProviders.DataProviderOverlayManager.RestoreOriginalDataProviders" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DataProviders.DataProviderOverlayManager.RestoreOriginalDataProviders">
      <summary>
            Restores all DataProvider bindings that have been changed using {
            <see cref="M:yWorks.yFiles.Algorithms.Util.DataProviders.DataProviderOverlayManager.AddDataProvider(System.Object,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            </summary>
      <remarks>
            Restores all DataProvider bindings that have been changed using {
            <see cref="M:yWorks.yFiles.Algorithms.Util.DataProviders.DataProviderOverlayManager.AddDataProvider(System.Object,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            Calling this method resets the state its state.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ">
      <summary>
            This class implements a priority queue for objects whose priority
            values are of type double.
            </summary>
      <remarks>
            This class implements a priority queue for objects whose priority
            values are of type double.
            <p />
            The implementation is based on binary heaps.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.#ctor(System.Int32,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>
            Creates an empty ObjectPQ using the given
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            and
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            to store and retrieve Object support information.
            </summary>
      <remarks>
            Creates an empty ObjectPQ using the given
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            and
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            to store and retrieve Object support information.
            The contents of the provider should be modified through the use of the
            acceptor, i.e. they should be based on the same initially empty backing store.
            Additionally this backing store should not be modified externally as long as
            this PQ is still in use.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Add(System.Object,System.Double)">
      <summary>Adds the given object with given priority to this queue.</summary>
      <remarks>Adds the given object with given priority to this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.ChangePriority(System.Object,System.Double)">
      <summary>Changes the priority value of the given object.</summary>
      <remarks>Changes the priority value of the given object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
      <remarks>Makes this queue the empty queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Contains(System.Object)">
      <summary>Returns whether or not the given object is contained.</summary>
      <remarks>
            Returns whether or not the given object is contained.
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.DecreasePriority(System.Object,System.Double)">
      <summary>Decreases the priority value of the given object.</summary>
      <remarks>Decreases the priority value of the given object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Dispose">
      <summary>Does nothing.</summary>
      <remarks>Does nothing.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
      <remarks>Returns whether or not this queue is empty.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.GetPriority(System.Object)">
      <summary>Returns the current priority of the given object.</summary>
      <remarks>Returns the current priority of the given object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.IncreasePriority(System.Object,System.Double)">
      <summary>Increases the priority value of the given object.</summary>
      <remarks>Increases the priority value of the given object.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Min">
      <summary>The object with smallest priority in this queue.</summary>
      <remarks>Returns the object with smallest priority in this queue.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.MinPriority">
      <summary>The minimum priority value in this queue.</summary>
      <remarks>Returns the minimum priority value in this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Remove(System.Object)">
      <summary>Removes the given object from this queue.</summary>
      <remarks>Removes the given object from this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.RemoveMin">
      <summary>Removes the object with smallest priority from this queue.</summary>
      <returns>the removed object with smallest priority</returns>
      <remarks>Removes the object with smallest priority from this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.DoubleObjectPQ.Size">
      <summary>Returns the number of nodes currently in this queue.</summary>
      <remarks>Returns the number of nodes currently in this queue.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter">
      <summary>This class is an empty abstract implementation of the EdgeMap interface.</summary>
      <remarks>This class is an empty abstract implementation of the EdgeMap interface.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.Get(System.Object)">
      <summary>Returns the value bound to the given edge.</summary>
      <returns>
        <see langword="null" />
      </returns>
      <remarks>Returns the value bound to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given edge.</summary>
      <returns>
        <see langword="false" />
      </returns>
      <remarks>Returns the boolean value bound to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given edge.</summary>
      <returns>
        <c>0.0d</c>
      </returns>
      <remarks>Returns the double value bound to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given edge.</summary>
      <returns>
        <c>0</c>
      </returns>
      <remarks>Returns the integer value bound to the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.Set(System.Object,System.Object)">
      <summary>Associates the given value to with the given edge.</summary>
      <remarks>Associates the given value to with the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to with the given edge.</summary>
      <remarks>Associates the given boolean value to with the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to with the given edge.</summary>
      <remarks>Associates the given double value to with the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.EdgeMapAdapter.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to with the given edge.</summary>
      <remarks>Associates the given integer value to with the given edge.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier">
      <summary>A utility class that can be used to copy a graph's structure and possibly associated data to another instance.</summary>
      <remarks>
            A utility class that can be used to copy a graph's structure and possibly associated data to another instance. This
            class relies on implementations of
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            that can either be any of the default
            implementations or any other implementation that can be associated with a
            <see cref="T:yWorks.yFiles.Algorithms.Graph" />
            's
            <see cref="P:yWorks.yFiles.Algorithms.Graph.GraphCopyFactory">copy factory property</see>
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.#ctor">
      <summary>
            Creates a new instance that uses a
            <see cref="T:yWorks.yFiles.Algorithms.GraphCopyFactory" />
            as the default factory.
            </summary>
      <remarks>
            Creates a new instance that uses a
            <see cref="T:yWorks.yFiles.Algorithms.GraphCopyFactory" />
            as the default factory.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory)">
      <summary>Creates a new instance that uses the specified factory to perform the actual copy operations.</summary>
      <param name="copyFactory">the factory to use, must be non-<see langword="null" />.</param>
      <exception cref="T:System.ArgumentNullException">if <c>copyFactory</c> is <see langword="null" /></exception>
      <remarks>Creates a new instance that uses the specified factory to perform the actual copy operations.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.Copy(yWorks.yFiles.Algorithms.Graph)">
      <summary>Copies the contents of the source graph to a newly created target graph and returns the new graph.</summary>
      <param name="sourceGraph">the graph to copy the contents from</param>
      <returns>the newly created graph</returns>
      <remarks>Copies the contents of the source graph to a newly created target graph and returns the new graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.Copy(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Copies the contents of the source graph to the target graph and returns the newly created nodes in the target
            graph.
            </summary>
      <param name="sourceGraph">the graph to copy the contents from</param>
      <param name="targetGraph">the target graph to copy the contents to, it will not be cleared prior to the copying</param>
      <returns>the list of Nodes that have been copied to the target graph.</returns>
      <remarks>
            Copies the contents of the source graph to the target graph and returns the newly created nodes in the target
            graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.Copy(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeCursor)">
      <summary>Copies the subgraph contained in graph induced by the source nodes to a newly created graph.</summary>
      <param name="sourceGraph">the graph to copy</param>
      <param name="sourceNodes">the nodes in the sourceGraph to copy to the new graph</param>
      <returns>the newly created graph</returns>
      <remarks>Copies the subgraph contained in graph induced by the source nodes to a newly created graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.Copy(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeCursor,yWorks.yFiles.Algorithms.Graph)">
      <summary>Copies the subgraph contained in sourceGraph induced by the source nodes to the targetGraph.</summary>
      <param name="sourceGraph">the graph to copy</param>
      <param name="sourceNodes">the nodes in the sourceGraph to copy to the new graph</param>
      <param name="targetGraph">the graph to copy the sourceGraph's contents to</param>
      <returns>the list of the new nodes in targetGraph</returns>
      <remarks>
            Copies the subgraph contained in sourceGraph induced by the source nodes to the targetGraph. targetGraph is not
            cleared prior to the copy operation.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.Copy(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeCursor,yWorks.yFiles.Algorithms.IEdgeCursor,yWorks.yFiles.Algorithms.Graph)">
      <summary>Copies the subgraph contained in sourceGraph induced by the source nodes and the provided source edges to the targetGraph.</summary>
      <param name="sourceGraph">the graph to copy</param>
      <param name="sourceNodes">the nodes in the sourceGraph to copy to the new graph</param>
      <param name="targetGraph">the graph to copy the sourceGraph's contents to</param>
      <param name="sourceEdges">the edges in the sourceGraph to copy to the new graph</param>
      <returns>the list of the new nodes in targetGraph</returns>
      <remarks>
            Copies the subgraph contained in sourceGraph induced by the source nodes and the provided source edges to the targetGraph.
            targetGraph is not cleared prior to the copy operation.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.CopyEdge(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>Callback that uses the given factory to perform the copy operation.</summary>
      <param name="copyFactory">the factory delegate the operation to</param>
      <remarks>
            Callback that uses the given factory to perform the copy operation. This method simply delegates to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.CopyEdge(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)" />
            and can be
            overwritten to change the behavior.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphCopier.CopyFactory">
      <summary>The currently used copy factory.</summary>
      <remarks>Returns the currently used copy factory.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.CopyNode(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>Callback that uses the given factory to perform the copy operation.</summary>
      <param name="copyFactory">the factory delegate the operation to</param>
      <remarks>
            Callback that uses the given factory to perform the copy operation.
            This method simply delegates to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.CopyNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)" />
            and can be overwritten to change the behavior.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.CreateEdgeMap">
      <summary>
            Callback that creates the Map that will hold the mapping from the edges in the old source graph to the newly
            created edges in the target graph.
            </summary>
      <returns>A map that can be used to store the mapping.</returns>
      <remarks>
            Callback that creates the Map that will hold the mapping from the edges in the old source graph to the newly
            created edges in the target graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.CreateGraph(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,yWorks.yFiles.Algorithms.Graph)">
      <summary>Callback that uses the given factory to create a new graph.</summary>
      <param name="factory">the factory to use for the creation</param>
      <param name="sourceGraph">the graph that will be</param>
      <returns>the newly created graph</returns>
      <remarks>
            Callback that uses the given factory to create a new graph. This method simply delegates to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.CreateGraph" />
            and can be overwritten to change the behavior.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.CreateNodeMap">
      <summary>
            Callback that creates the Map that will hold the mapping from the nodes in the old source graph to the newly
            created nodes in the target graph.
            </summary>
      <returns>A map that can be used to store the mapping.</returns>
      <remarks>
            Callback that creates the Map that will hold the mapping from the nodes in the old source graph to the newly
            created nodes in the target graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderContentCopying">
      <summary>Determines whether automatic copying of edge map contents should be performed.</summary>
      <remarks>
            Determines whether automatic copying of edge map contents should be performed. The default is <see langword="false" />.
            Copying will be done by reference on Object basis. The backing store for the content will be HashMap based.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopying">
      <summary>Determines whether automatic copying of edge map contents is enabled.</summary>
      <remarks>
            Getter:<br />
            Determines whether automatic copying of edge map contents is enabled. The default is <see langword="false" />.
            <para />
            Setter:<br />
            Sets whether automatic copying of edge map contents should be performed. The default is <see langword="false" />. Copying
            will be done by reference on Object basis. To store these objects, new
            <see cref="T:yWorks.yFiles.Algorithms.IEdgeMap" />
            s are created for the target
            graph.
            <p />In order to access these <c>EdgeMap</c>s it is necessary to store the number of <c>NodeMap</c>s in
            the target graph before creating the <c>EdgeMap</c>s as they will be appended. After copying the graph a
            <c>EdgeMap</c> can be found using this number as offset and add the index of the map in the original graph.
            <p />Note: To be able to control and access <c>EdgeMap</c>s more easily, it is recommended to use
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            s instead and have them copied.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GetSourceEdges(yWorks.yFiles.Algorithms.Graph)">
      <summary>Determines the set of edge candidates from the source graph that should be copied.</summary>
      <param name="sourceGraph">the graph to determine the edges to copy</param>
      <returns>the edges to copy</returns>
      <remarks>
            Determines the set of edge candidates from the source graph that should be copied. Note that if any of the source
            or target node is not present in the target graph the edge will not be copied. This implementation simply returns
            <see cref="M:yWorks.yFiles.Algorithms.Graph.GetEdgeCursor" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GetSourceNodes(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Determines the set of node candidates from the source graph that should be copied if
            no other nodes are specified by the user.
            </summary>
      <param name="sourceGraph">the graph to determine the nodes to copy</param>
      <returns>the nodes to copy</returns>
      <remarks>
            Determines the set of node candidates from the source graph that should be copied if
            no other nodes are specified by the user. This implementation simply returns
            <see cref="M:yWorks.yFiles.Algorithms.Graph.GetNodeCursor" />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopying">
      <summary>Determines whether automatic copying of node map contents is enabled.</summary>
      <remarks>
            Getter:<br />
            Determines whether automatic copying of node map contents is enabled. The default is <see langword="false" />.
            <para />
            Setter:<br />
            Sets whether automatic copying of node map contents should be performed. The default is <see langword="false" />. Copying
            will be done by reference on Object basis. To store these objects, new
            <see cref="T:yWorks.yFiles.Algorithms.INodeMap" />
            s are created for the target
            graph.
            <p />In order to access these <c>NodeMap</c>s it is necessary to store the number of <c>NodeMap</c>s in
            the target graph before creating the <c>NodeMap</c>s as they will be appended. After copying the graph a
            <c>NodeMap</c> can be found using this number as offset and add the index of the map in the original graph.
            <p />Note: To be able to control and access <c>NodeMap</c>s more easily, it is recommended to use
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            s instead and have them copied.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.PostCopyGraphData(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>Callback that uses the given factory to perform the copy operation.</summary>
      <param name="copyFactory">the factory delegate the operation to</param>
      <remarks>
            Callback that uses the given factory to perform the copy operation. This method simply delegates to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.PostCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)" />
            and can
            be overwritten to change the behavior.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.PreCopyGraphData(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Callback that uses the given factory to perform the copy operation.</summary>
      <param name="copyFactory">the factory delegate the operation to</param>
      <remarks>
            Callback that uses the given factory to perform the copy operation. This method simply delegates to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.PreCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)" />
            ()} and can be overwritten to change
            the behavior.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory">
      <summary>Abstract helper class that provides helper methods to copy DataProvider contents.</summary>
      <remarks>Abstract helper class that provides helper methods to copy DataProvider contents.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,System.Object)">
      <summary>Creates a new delegating instance that copies the data for the given data provider key.</summary>
      <param name="delegatingFactory">the factory to delegate to.</param>
      <param name="dpKey">the data provider key</param>
      <remarks>Creates a new delegating instance that copies the data for the given data provider key.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Factory callback to create the backing storage.</summary>
      <remarks>Factory callback to create the backing storage.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.dpKey">
      <summary>The DataProvider key.</summary>
      <remarks>The DataProvider key.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.GetMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Helper method that retrieves the map for the given graph instance.</summary>
      <param name="graph">Graph instance for which the map is retrieved</param>
      <returns>the map for the given graph instance</returns>
      <remarks>Helper method that retrieves the map for the given graph instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Calls
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)" />
            and registers that map on the target graph if there is no
            <see cref="T:yWorks.yFiles.Algorithms.IDataMap" />
            registered on the target graph yet.
            </summary>
      <remarks>
            Calls
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.DataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)" />
            and registers that map on the target graph if there is no
            <see cref="T:yWorks.yFiles.Algorithms.IDataMap" />
            registered on the target graph yet.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeDataProviderCopyFactory">
      <summary>
            Helper class implementation of
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            that can be used to copy the contents of a
            DataProvider registered with the source graph onto the target graph storing the values in newly a created
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateEdgeMap" />
            edge map}.
            </summary>
      <remarks>
            Helper class implementation of
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            that can be used to copy the contents of a
            DataProvider registered with the source graph onto the target graph storing the values in newly a created
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateEdgeMap" />
            edge map}.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeDataProviderCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,System.Object)">
      <summary>Creates a new instance using the delegate for the given data provider key.</summary>
      <remarks>Creates a new instance using the delegate for the given data provider key.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeDataProviderCopyFactory.Copy(System.Object,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,System.Object)" />
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeDataProviderCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeDataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Factory callback to create the backing storage.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopyFactory">
      <summary>
            A helper wrapping implementation of the
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            interface that copies the contents
            of the edge maps from the source to the target graph.
            </summary>
      <remarks>
            A helper wrapping implementation of the
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            interface that copies the contents
            of the edge maps from the source to the target graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory)">
      <summary>Creates a new instance that copies the node map contents.</summary>
      <param name="delegatingFactory">the factory to delegate the copying of the entities to.</param>
      <remarks>Creates a new instance that copies the node map contents.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopyFactory.Copy(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,System.Object)">
      <summary>Callback method that performs the actual copying of the data.</summary>
      <remarks>Callback method that performs the actual copying of the data. This implementation simply returns the reference.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.EdgeMapCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory">
      <summary>An abstract base implementation of a delegating CopyFactory that copies data for items being copied.</summary>
      <remarks>
            An abstract base implementation of a delegating CopyFactory that copies data for items being copied. The actual
            copying will be performed by the wrapped delegate. Instances of this class should be used to wrap existing copy
            factories. Subclasses should override any or all of the
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)" />
            ,
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)" />
            ,
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)" />
            , and
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PostCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)" />
            methods.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory)">
      <summary>Creates a new instance that delegates the actual copying process of the elements to the provided factory.</summary>
      <param name="delegatingFactory" />
      <remarks>Creates a new instance that delegates the actual copying process of the elements to the provided factory.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
      <remarks>Empty stub to be overwritten by subclass implementations.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
      <remarks>Empty stub to be overwritten by subclass implementations.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyEdge(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Delegates the copying of the data to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)" /></summary>
      <remarks>
            Delegates the copying of the data to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)" />
            
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Delegates the copying of the data to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)" /></summary>
      <remarks>
            Delegates the copying of the data to
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)" />
            
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.CreateGraph">
      <summary>Creates a new graph instance that will be the target graph of the copy operation.</summary>
      <returns>the graph to use as the target graph</returns>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PostCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="nodeMap">a Map that maps old node instances to their new copies</param>
      <param name="edgeMap">a Map that maps old edge instances to their new copies</param>
      <remarks>Empty stub to be overwritten by subclass implementations.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PostCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>
            Calls the delegate and then
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PostCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)" />
            .
            </summary>
      <remarks>
            Calls the delegate and then
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PostCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <remarks>Empty stub to be overwritten by subclass implementations.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PreCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Calls
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)" />
            and then the delegate.
            </summary>
      <remarks>
            Calls
            <see cref="M:yWorks.yFiles.Algorithms.Util.GraphCopier.GraphDataCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)" />
            and then the delegate.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory">
      <summary>
            The copy factory interface used by
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier" />
            to delegate the actual work to.
            </summary>
      <remarks>
            The copy factory interface used by
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier" />
            to delegate the actual work to.
            </remarks>
      <remarks>
            The copy factory interface used by
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier" />
            to delegate the actual work to.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.CopyEdge(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Copies the <c>originalEdge</c> from the source graph to the new <c>targetGraph</c>
            using the specified new source and target node in the target graph.
            </summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="newSource">the source node in the target graph to use for the newly created edge</param>
      <param name="newTarget">the target node in the target graph to use for the newly created edge</param>
      <param name="originalEdge">the original edge from the source graph</param>
      <returns>the newly created edge</returns>
      <remarks>
            Copies the <c>originalEdge</c> from the source graph to the new <c>targetGraph</c>
            using the specified new source and target node in the target graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.CopyNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>Copies the <c>originalNode</c> from the source graph to the new <c>targetGraph</c></summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="originalNode">the original node from the source graph</param>
      <returns>the newly created node</returns>
      <remarks>Copies the <c>originalNode</c> from the source graph to the new <c>targetGraph</c></remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.CreateGraph">
      <summary>Creates a new graph instance that will be the target graph of the copy operation.</summary>
      <returns>the graph to use as the target graph</returns>
      <remarks>
            Creates a new graph instance that will be the target graph of the copy operation.
            This method is called if no target graph is specified by the user.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.PostCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>Callback that will be called after the copy operation has completed.</summary>
      <param name="sourceGraph">the graph that was used to copy the entities from.</param>
      <param name="targetGraph">the graph that was used to copy the entities to.</param>
      <param name="nodeMap">
            a map that contains a mapping between the nodes in the source graph
            to their corresponding nodes in the new graph.
            </param>
      <param name="edgeMap">
            a map that contains a mapping between the edges in the source graph
            to their corresponding edges in the new graph.
            </param>
      <remarks>
            Callback that will be called after the copy operation has completed.
            At that point in time all entities have been copied to the new graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory.PreCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Callback that will be called before the copy operation takes place.</summary>
      <param name="sourceGraph">the graph that will be used to copy the entities from.</param>
      <param name="targetGraph">the graph that will be used to copy the entities to.</param>
      <remarks>
            Callback that will be called before the copy operation takes place.
            At that point in time no entities have been copied to the new graph.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory">
      <summary>
            Helper class implementation of
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            that can be used to copy the contents of a
            DataProvider registered with the source graph onto the target graph storing the values in newly created
            <see cref="T:yWorks.yFiles.Util.HashMap" />
            based
            <see cref="T:yWorks.yFiles.Algorithms.IDataMap" />
            s.
            </summary>
      <remarks>
            Helper class implementation of
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            that can be used to copy the contents of a
            DataProvider registered with the source graph onto the target graph storing the values in newly created
            <see cref="T:yWorks.yFiles.Util.HashMap" />
            based
            <see cref="T:yWorks.yFiles.Algorithms.IDataMap" />
            s.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,System.Object)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.Copy(System.Object,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,System.Object)">
      <summary>Callback method that performs the actual copying of the data.</summary>
      <remarks>Callback method that performs the actual copying of the data. This implementation simply returns the reference.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.Copy(System.Object,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Callback method that performs the actual copying of the data.</summary>
      <remarks>Callback method that performs the actual copying of the data. This implementation simply returns the reference.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.CopyData(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.ItemDataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Factory callback to create the backing storage.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeDataProviderCopyFactory">
      <summary>
            Helper class implementation of
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            that can be used to copy the contents of a
            DataProvider registered with the source graph onto the target graph storing the values in newly created
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateNodeMap">node map</see>
            .
            </summary>
      <remarks>
            Helper class implementation of
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            that can be used to copy the contents of a
            DataProvider registered with the source graph onto the target graph storing the values in newly created
            <see cref="M:yWorks.yFiles.Algorithms.Graph.CreateNodeMap">node map</see>
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeDataProviderCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory,System.Object)">
      <summary>Creates a new instance using the delegate for the given data provider key.</summary>
      <remarks>Creates a new instance using the delegate for the given data provider key.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeDataProviderCopyFactory.Copy(System.Object,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Callback method that performs the actual copying of the data.</summary>
      <remarks>Callback method that performs the actual copying of the data. This implementation simply returns the reference.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeDataProviderCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeDataProviderCopyFactory.CreateMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Factory callback to create the backing storage.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopyFactory">
      <summary>
            A helper wrapping implementation of the
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            interface that copies the contents
            of the node maps from the source to the target graph.
            </summary>
      <remarks>
            A helper wrapping implementation of the
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory" />
            interface that copies the contents
            of the node maps from the source to the target graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory)">
      <summary>Creates a new instance that copies the node map contents.</summary>
      <param name="delegatingFactory">the factory to delegate the copying of the entities to.</param>
      <remarks>Creates a new instance that copies the node map contents.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopyFactory.Copy(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Callback method that performs the actual copying of the data.</summary>
      <remarks>Callback method that performs the actual copying of the data. This implementation simply returns the reference.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphCopier.NodeMapCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphHider">
      <summary>Provides functionality to hide and unhide nodes and edges of a graph temporarily for algorithmic operations.</summary>
      <remarks>
            Provides functionality to hide and unhide nodes and edges of a graph temporarily for algorithmic operations.
            <p>
            This class can be used to temporarily hide away certain elements
            of a graph and to unhide that parts at a later time again.
            Instances of this class keep track of graph elements that were
            hidden from a graph in order to make them visible again
            at a later time.
            </p>
            <p>
            Note that this class should not be used to hide elements from a Graph2D for pure hiding purposes.
            Since this class will by default prevent the graph instance from firing events, other code
            might cease to work correctly. Use this class for short term removal of nodes and edges, only.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Instantiates a new GraphHider for the given graph.</summary>
      <remarks>
            Instantiates a new GraphHider for the given graph.
            All non-static hiding and unhiding methods will refer
            to the given graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphHider.FireGraphEvents">
      <summary>Specifies whether or not this hider should fire graph events.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not this hider should fire graph events when adding
            or removing items from the graph.
            By default the hider does not fire graph events.
            <para />
            Getter:<br />
            Returns whether or not this hider should fire graph events.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphHider.Graph">
      <summary>
            The <c>Graph</c> for which this <c>GraphHider</c> was
            created.
            </summary>
      <remarks>
            Returns the <c>Graph</c> for which this <c>GraphHider</c> was
            created.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.GraphHider.hiddenEdges">
      <summary>holds the list of the hidden edges in stack order</summary>
      <remarks>holds the list of the hidden edges in stack order</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HiddenEdges">
      <summary>The edges that are currently hidden</summary>
      <returns>an EdgeList containing the currently hidden edges</returns>
      <remarks>The edges that are currently hidden</remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.GraphHider.hiddenNodes">
      <summary>holds the list of the hidden nodes in stack order</summary>
      <remarks>holds the list of the hidden nodes in stack order</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HiddenNodes">
      <summary>The nodes that are currently hidden</summary>
      <returns>a NodeList containing the currently hidden nodes</returns>
      <remarks>The nodes that are currently hidden</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.Edge)">
      <summary>Hides the given edge from the graph.</summary>
      <remarks>
            Hides the given edge from the graph.
            The hidden edge will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Hides the given list of edges from the graph.</summary>
      <remarks>
            Hides the given list of edges from the graph.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Hides the given elements from the graph.</summary>
      <remarks>
            Hides the given elements from the graph.
            The hidden nodes and adjacent edges will be stored
            so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Hides the given edges from the graph.</summary>
      <remarks>
            Hides the given edges from the graph.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.INodeCursor)">
      <summary>Hides the given nodes from the graph.</summary>
      <remarks>
            Hides the given nodes from the graph.
            The hidden nodes and adjacent edges will be stored
            so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.Node)">
      <summary>Hides the given node and all it's adjacent edges from the graph.</summary>
      <remarks>
            Hides the given node and all it's adjacent edges from the graph.
            The hidden elements will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Hide(yWorks.yFiles.Algorithms.NodeList)">
      <summary>Hides the given list of nodes from the graph.</summary>
      <remarks>
            Hides the given list of nodes from the graph.
            The hidden nodes and adjacent edges will be stored
            so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HideAll">
      <summary>Hides all nodes and edges from this graph.</summary>
      <remarks>
            Hides all nodes and edges from this graph.
            The hidden elements will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HideEdges">
      <summary>Hides all edges from this graph.</summary>
      <remarks>
            Hides all edges from this graph.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HideMultipleEdges">
      <summary>Hides multiple edges from the graph.</summary>
      <remarks>
            Hides multiple edges from the graph.
            If there are multiple edges connecting two nodes then
            all but one (representative) of these edges will be hidden.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HideSelfLoops">
      <summary>Hides all self-loop edges from this graph.</summary>
      <remarks>
            Hides all self-loop edges from this graph.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.HideSubgraph(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Hides the subgraph induced by the given edges from the given graph.</summary>
      <remarks>
            Hides the subgraph induced by the given edges from the given graph.
            The induced subgraph defined by the given edges consists
            of the given edges and all nodes that are solely connected
            to the rest of the graph by the given edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.SimplifyGraph">
      <summary>Hides all self-loops and multiple edges from the graph.</summary>
      <remarks>
            Hides all self-loops and multiple edges from the graph.
            <p />
            The overall effect of this method is that the minimum number of
            edges are hidden from the graph such that it contains no
            self-loops and no multiple edges anymore.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Unhide(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This method will be called whenever
            the hider is requested to unhide the given edge
            from the graph.
            </summary>
      <remarks>
            This method will be called whenever
            the hider is requested to unhide the given edge
            from the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.Unhide(yWorks.yFiles.Algorithms.Node)">
      <summary>
            This method will be called whenever
            the hider is requested to unhide the given node
            from the graph.
            </summary>
      <remarks>
            This method will be called whenever
            the hider is requested to unhide the given node
            from the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideAll">
      <summary>Unhides all formerly hidden elements in the graph.</summary>
      <remarks>Unhides all formerly hidden elements in the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>Unhides the given edge.</summary>
      <param name="e">the edge that will be unhidden</param>
      <remarks>
            Unhides the given edge. Also updates
            <see cref="F:yWorks.yFiles.Algorithms.Util.GraphHider.hiddenEdges" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideEdges">
      <summary>Unhides all formerly hidden edges in the graph.</summary>
      <remarks>Unhides all formerly hidden edges in the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideEdges(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Unhides the given edges.</summary>
      <param name="edges">the edges that will be unhidden</param>
      <remarks>
            Unhides the given edges. Also updates
            <see cref="F:yWorks.yFiles.Algorithms.Util.GraphHider.hiddenEdges" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideNode(yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>Unhides the given node and if requested its adjacent edges.</summary>
      <param name="v">the node that will be unhidden</param>
      <param name="unhideAdjacentEdges">
            whether of not to unhide previously hidden edges connected at <c>v</c> whose other end point
            is not hidden, i.e. it is part of the graph.
            </param>
      <remarks>
            Unhides the given node and if requested its adjacent edges. Also updates
            <see cref="F:yWorks.yFiles.Algorithms.Util.GraphHider.hiddenNodes" />
            and
            <see cref="F:yWorks.yFiles.Algorithms.Util.GraphHider.hiddenEdges" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideNodes">
      <summary>Unhides all formerly hidden nodes in the graph.</summary>
      <remarks>
            Unhides all formerly hidden nodes in the graph. Note that this
            method does not unhide hidden edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideNodes(yWorks.yFiles.Algorithms.NodeList,System.Boolean)">
      <summary>Unhides the given nodes and if requested its adjacent edges.</summary>
      <param name="nodes">the nodes that will be unhidden</param>
      <param name="unhideAdjacentEdges">
            whether of not to unhide previously hidden edges connected at the given nodes whose other end point
            is not hidden, i.e. it is part of the graph.
            </param>
      <remarks>
            Unhides the given nodes and if requested its adjacent edges. Also updates
            <see cref="F:yWorks.yFiles.Algorithms.Util.GraphHider.hiddenNodes" />
            and
            <see cref="F:yWorks.yFiles.Algorithms.Util.GraphHider.hiddenEdges" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphHider.UnhideSubgraph(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Unhides the subgraph induced by the given edges in the given graph.</summary>
      <remarks>
            Unhides the subgraph induced by the given edges in the given graph.
            The induced subgraph defined by the given edges consists
            of the given edges and all nodes that are either source
            or target of at least one of the given edges.
            <p />
            Parts of the subgraph that are already contained in the given
            graph will not be unhidden and pose no problem to this method.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.GraphPartitionManager">
      <summary>Provides functionality to hide and unhide partitions of nodes and their adjacent edges of a graph temporarily for algorithmic operations.</summary>
      <remarks>
            Provides functionality to hide and unhide partitions of nodes and their adjacent edges of a graph temporarily for algorithmic operations.
            <p>
            This class can be used to temporarily hide away certain elements
            of a graph and to unhide that parts at a later time again.
            Instances of this class keep track of graph elements that were
            hidden from a graph in order to make them visible again
            at a later time.
            </p>
            <p>
            Note that this class should not be used to hide elements from a Graph2D for pure hiding purposes.
            Since this class will by default prevent the graph instance from firing events, other code
            might cease to work correctly. Use this class for short term removal of nodes and edges, only.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Instantiates a new GraphPartitionManager for the given graph.</summary>
      <remarks>
            Instantiates a new GraphPartitionManager for the given graph.
            All non-static hiding and unhiding methods will refer
            to the given graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.DisplayPartition(System.Object)">
      <summary>
            Assures that only nodes are visible in the graph that are associated with
            the given partitionId.
            </summary>
      <param name="partitionId">the partitionId for the nodes that will be made visible</param>
      <remarks>
            Assures that only nodes are visible in the graph that are associated with
            the given partitionId.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.FireGraphEventsEnabled">
      <summary>Specifies whether or not this partition manager should fire graph events.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not this partition manager should fire graph events
            when adding or removing items from the graph.
            By default the partition manager does not fire graph events.
            <para />
            Getter:<br />
            Returns whether or not this partition manager should fire graph events.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Graph">
      <summary>
            The <c>Graph</c> for which this partition manager was
            created.
            </summary>
      <remarks>
            Returns the <c>Graph</c> for which this partition manager was
            created.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.Edge)">
      <summary>Hides the given edge from the graph.</summary>
      <remarks>
            Hides the given edge from the graph.
            The hidden edge will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Hides the given list of edges from the graph.</summary>
      <remarks>
            Hides the given list of edges from the graph.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.ICursor)">
      <summary>Hides the given elements from the graph.</summary>
      <remarks>
            Hides the given elements from the graph.
            The hidden nodes and adjacent edges will be stored
            so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Hides the given edges from the graph.</summary>
      <remarks>
            Hides the given edges from the graph.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.INodeCursor)">
      <summary>Hides the given nodes from the graph.</summary>
      <remarks>
            Hides the given nodes from the graph.
            The hidden nodes and adjacent edges will be stored
            so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.Node)">
      <summary>Hides the given node and all it's adjacent edges from the graph.</summary>
      <remarks>
            Hides the given node and all it's adjacent edges from the graph.
            The hidden elements will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Hide(yWorks.yFiles.Algorithms.NodeList)">
      <summary>Hides the given list of nodes from the graph.</summary>
      <remarks>
            Hides the given list of nodes from the graph.
            The hidden nodes and adjacent edges will be stored
            so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.HideAll">
      <summary>Hides all nodes and edges from this graph.</summary>
      <remarks>
            Hides all nodes and edges from this graph.
            The hidden elements will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.HideEdges">
      <summary>Hides all edges from this graph.</summary>
      <remarks>
            Hides all edges from this graph.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.HideMultipleEdges">
      <summary>Hides multiple edges from the graph.</summary>
      <remarks>
            Hides multiple edges from the graph.
            If there are multiple edges connecting two nodes then
            all but one (representative) of these edges will be hidden.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.HidePartition(System.Object)">
      <summary>Hides nodes and adjacent edges that have the given partitionId associated.</summary>
      <param name="partitionId">the id</param>
      <remarks>Hides nodes and adjacent edges that have the given partitionId associated.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.HideSelfLoops">
      <summary>Hides all self-loop edges from this graph.</summary>
      <remarks>
            Hides all self-loop edges from this graph.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.InitPartitions(yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Initializes internal data structures using the new DataProvider.</summary>
      <param name="partitionId">
            the data provider that holds the partitionIds for all
            elements.
            </param>
      <remarks>
            Initializes internal data structures using the new DataProvider.
            This method must also be called whenever the content of the given
            DataProvider changes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.SimplifyGraph">
      <summary>Hides all self-loops and multiple edges from the graph.</summary>
      <remarks>
            Hides all self-loops and multiple edges from the graph.
            <p />
            The overall effect of this method is that the minimum number of
            edges are hidden from the graph such that it contains no
            self-loops and no multiple edges anymore.
            The hidden edges will be stored so that they can be unhidden
            again at a later time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Unhide(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This method will be called whenever the partition manager is requested to
            unhide the given edge from the graph.
            </summary>
      <remarks>
            This method will be called whenever the partition manager is requested to
            unhide the given edge from the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.Unhide(yWorks.yFiles.Algorithms.Node)">
      <summary>
            This method will be called whenever the partition manager is requested to
            unhide the given node from the graph.
            </summary>
      <remarks>
            This method will be called whenever the partition manager is requested to
            unhide the given node from the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.UnhideAll">
      <summary>Unhides all formerly hidden elements in the graph.</summary>
      <remarks>Unhides all formerly hidden elements in the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.UnhideEdges">
      <summary>Unhides all formerly hidden edges in the graph.</summary>
      <remarks>Unhides all formerly hidden edges in the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.UnhideNodes">
      <summary>Unhides all formerly hidden nodes in the graph.</summary>
      <remarks>
            Unhides all formerly hidden nodes in the graph. Note that this
            method does not unhide hidden edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.GraphPartitionManager.UnhidePartition(System.Object)">
      <summary>Unhides nodes that have the given partitionId associated.</summary>
      <param name="partitionId">the id</param>
      <remarks>Unhides nodes that have the given partitionId associated.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ">
      <summary>
            Defines an interface for specialized priority queues that contains
            nodes which are prioritized by associated double values.
            </summary>
      <remarks>
            Defines an interface for specialized priority queues that contains
            nodes which are prioritized by associated double values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Adds a node with the given priority to the queue.</summary>
      <remarks>Adds a node with the given priority to the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Clear">
      <summary>Removes all entries from the queue.</summary>
      <remarks>Removes all entries from the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is contained within this queue.</summary>
      <remarks>Returns whether or not the given node is contained within this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Decreases the priority of a node in the queue to a given value.</summary>
      <param name="n">a node in the priority queue.</param>
      <param name="priority">the new priority of the node.</param>
      <remarks>Decreases the priority of a node in the queue to a given value.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Dispose">
      <summary>Disposes this queue.</summary>
      <remarks>
            Disposes this queue. It is important to call this method after the queue
            is not needed anymore, to free bound resources.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
      <remarks>Returns whether or not this queue is empty.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
      <remarks>Returns the current priority of the given node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
      <remarks>Returns he node with smallest priority in this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IDoubleNodePQ.RemoveMin">
      <summary>Removes the node with the minimal priority from the queue.</summary>
      <remarks>Removes the node with the minimal priority from the queue.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.IIntNodePQ">
      <summary>
            Defines an interface for specialized priority queues that contains
            nodes which are prioritized by associated int values.
            </summary>
      <remarks>
            Defines an interface for specialized priority queues that contains
            nodes which are prioritized by associated int values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Adds a node with the given priority to the queue.</summary>
      <remarks>Adds a node with the given priority to the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Clear">
      <summary>Removes all entries from the queue.</summary>
      <remarks>Removes all entries from the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is contained within this queue.</summary>
      <remarks>Returns whether or not the given node is contained within this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Decreases the priority of a node in the queue to a given value.</summary>
      <param name="n">a node in the priority queue.</param>
      <param name="priority">the new priority value of the node.</param>
      <remarks>Decreases the priority of a node in the queue to a given value.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Dispose">
      <summary>Disposes this queue.</summary>
      <remarks>
            Disposes this queue. It is important to call this method after the queue
            is not needed anymore, to free bound resources.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
      <remarks>Returns whether or not this queue is empty.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
      <remarks>Returns the current priority of the given node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IIntNodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
      <remarks>Returns he node with smallest priority in this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IIntNodePQ.RemoveMin">
      <summary>Removes the node with the minimal priority from the queue.</summary>
      <remarks>Removes the node with the minimal priority from the queue.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.IIntValueSettable">
      <summary>Specifies the contract of modifiable integer value objects.</summary>
      <remarks>Specifies the contract of modifiable integer value objects.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IIntValueSettable.Value">
      <summary>The object's data.</summary>
      <remarks>Sets the object's data.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.INodePQ">
      <summary>
            Defines an interface for specialized priority queues that contains
            nodes which are prioritized by a comparable values.
            </summary>
      <remarks>
            Defines an interface for specialized priority queues that contains
            nodes which are prioritized by a comparable values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Adds the given node with the given priority to the queue.</summary>
      <remarks>Adds the given node with the given priority to the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
      <remarks>
            Makes this queue the empty queue.
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
      <remarks>
            Returns whether or not the given node is contained
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>Decreased the priority value of the given node.</summary>
      <remarks>Decreased the priority value of the given node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.INodePQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
      <remarks>Returns whether or not this queue is empty</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
      <remarks>Returns the current priority of the given node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.INodePQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
      <remarks>Returns he node with smallest priority in this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue.</summary>
      <returns>the removed node with smallest priority</returns>
      <remarks>Removes the node with smallest priority from this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.INodePQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
      <remarks>Returns the number of nodes currently in this queue</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.IntObjectPQ">
      <summary>
            This class implements a priority queue for objects whose priority
            values are of type int.
            </summary>
      <remarks>
            This class implements a priority queue for objects whose priority
            values are of type int.
            <p />
            The implementation is based on binary heaps.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.#ctor(System.Int32,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>
            Creates an empty ObjectPQ using the given
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            and
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            to store and retrieve Object support information.
            </summary>
      <remarks>
            Creates an empty ObjectPQ using the given
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            and
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            to store and retrieve Object support information.
            The contents of the provider should be modified through the use of the
            acceptor, i.e. they should be based on the same initially empty backing store.
            Additionally this backing store should not be modified externally as long as
            this PQ is still in use.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Add(System.Object,System.Int32)">
      <summary>Adds the given node with with given priority to this queue.</summary>
      <remarks>Adds the given node with with given priority to this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.ChangePriority(System.Object,System.Int32)">
      <summary>Changes the priority value of the given node.</summary>
      <remarks>Changes the priority value of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Clear">
      <summary>Makes this queue the empty queue.</summary>
      <remarks>
            Makes this queue the empty queue.
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Contains(System.Object)">
      <summary>
            Returns whether or not the given node is contained
            in this queue.
            </summary>
      <remarks>
            Returns whether or not the given node is contained
            in this queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.DecreasePriority(System.Object,System.Int32)">
      <summary>Decreases the priority value of the given node.</summary>
      <remarks>Decreases the priority value of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Dispose">
      <summary>Does nothing.</summary>
      <remarks>Does nothing.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Empty">
      <summary>Specifies whether or not this queue is empty</summary>
      <remarks>Returns whether or not this queue is empty</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.GetPriority(System.Object)">
      <summary>Returns the current priority of the given node.</summary>
      <remarks>Returns the current priority of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.IncreasePriority(System.Object,System.Int32)">
      <summary>Increases the priority value of the given node.</summary>
      <remarks>Increases the priority value of the given node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Min">
      <summary>He node with smallest priority in this queue.</summary>
      <remarks>Returns he node with smallest priority in this queue.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.IntObjectPQ.MinPriority">
      <summary>The minimum priority value in this queue.</summary>
      <remarks>Returns the minimum priority value in this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Remove(System.Object)">
      <summary>Removes the given node from this queue.</summary>
      <remarks>Removes the given node from this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.RemoveMin">
      <summary>Removes the node with smallest priority from this queue</summary>
      <returns>the removed node with smallest priority</returns>
      <remarks>Removes the node with smallest priority from this queue</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.IntObjectPQ.Size">
      <summary>Returns the number of nodes currently in this queue</summary>
      <remarks>Returns the number of nodes currently in this queue</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.ListIntNodePQ">
      <summary>
            A specialized priority queue that contains nodes which are
            prioritized by associated int values.
            </summary>
      <remarks>
            A specialized priority queue that contains nodes which are
            prioritized by associated int values.
            <p />
            This queue is designed for efficiency in scenario's where the
            set of possible integral priority keys is small and
            tight (i.e their values are not far apart).
            Typical int values chosen are the degree of a node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Constructs an initially empty PQ.</summary>
      <remarks>Constructs an initially empty PQ.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,System.Int32,System.Int32)">
      <summary>Constructs a PQ that holds all nodes of the given graph.</summary>
      <remarks>
            Constructs a PQ that holds all nodes of the given graph.
            <p />
            the given data provider has to provide for each defined node
            an int value that is not bigger than <c>minValue</c> and
            not smaller than <c>maxValue</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,System.Int32,System.Int32,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,System.Int32,System.Int32)" />
            .
            </summary>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,System.Int32,System.Int32)" />
            .
            Additionally a data provider
            can be specified, that holds boolean values for each node in the
            graph. Only nodes for which the data provider returns <see langword="true" />
            will be entered in the queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Adds a node to this queue with the given priority</summary>
      <remarks>Adds a node to this queue with the given priority</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Clear">
      <summary>Removes all entries from the queue.</summary>
      <remarks>Removes all entries from the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Whether or not the given node is contained within this queue.</summary>
      <remarks>Whether or not the given node is contained within this queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Decreases the priority of a node in the queue to a certain value.</summary>
      <param name="v">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
      <remarks>Decreases the priority of a node in the queue to a certain value.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.DecrementPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Decrements the associated priority value for the given node by 1
            and updates it's position within the queue accordingly.
            </summary>
      <remarks>
            Decrements the associated priority value for the given node by 1
            and updates it's position within the queue accordingly.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Dispose">
      <summary>Disposes this queue.</summary>
      <remarks>
            Disposes this queue. It is important to call this method after the queue
            is not needed anymore, since it allocates node maps from the graph
            that owns the nodes within the queue.
            Calling this method frees these node maps again.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
      <remarks>Returns whether or not this queue is empty.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.IncreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Increases the priority of a node in the queue to a certain value.</summary>
      <param name="v">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
      <remarks>Increases the priority of a node in the queue to a certain value.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.IncrementPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Increments the associated priority value for the given node by 1
            and updates it's position within the queue accordingly.
            </summary>
      <remarks>
            Increments the associated priority value for the given node by 1
            and updates it's position within the queue accordingly.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Min">
      <summary>The node with the minimal value in the queue.</summary>
      <remarks>Returns the node with the minimal value in the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.PopMaxNode">
      <summary>
            Returns a node with highest associated int key within this
            queue.
            </summary>
      <remarks>
            Returns a node with highest associated int key within this
            queue. the returned node will be removed from the queue by
            this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.PopMinNode">
      <summary>
            Returns a node with smallest associated int key within this
            queue.
            </summary>
      <remarks>
            Returns a node with smallest associated int key within this
            queue. the returned node will be removed from the queue by
            this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes a node from the queue.</summary>
      <remarks>Removes a node from the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.RemoveMin">
      <summary>Same as popMinNode.</summary>
      <remarks>Same as popMinNode.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.ListIntNodePQ.Size">
      <summary>Returns the number of nodes still in the queue.</summary>
      <remarks>Returns the number of nodes still in the queue.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.LoggingUtil">
      <summary>
            Provides some convenience methods for code debugging
            and exception handling.
            </summary>
      <remarks>
            Provides some convenience methods for code debugging
            and exception handling.
            <p>
            The behavior of this class can be adapted by starting
            the Java Virtual Machine with a set system property
            <c>y.debug</c> and <c>y.debug.level</c>.
            The default debug level is 2. It can be changed by
            setting the system property <c>y.debug.level</c>
            appropriately.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.LoggingUtil" /> class</summary>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.LoggingUtil.DebugLevel">
      <summary>The debug level threshold.</summary>
      <remarks>
            The debug level threshold. Its default value is
            2 but may be changed by setting the system property
            <c>y.debug.level</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Fatal(System.Object)">
      <summary>Called on a fatal error.</summary>
      <remarks>
            Called on a fatal error. Mostly used in a catch statement to
            signal a definite bug.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Fatal(System.Object,System.Object)">
      <summary>Outputs the class of the given object and the given message.</summary>
      <remarks>
            Outputs the class of the given object and the given message.
            Then throws a RuntimeException using the same message.
            <p />
            Mostly used in a catch statement to
            signal a definite bug.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)">
      <summary>
            Prints the given string to <c>System.out</c> if
            the given debug level if bigger than
            <c>DEBUG_LEVEL</c>.
            </summary>
      <remarks>
            Prints the given string to <c>System.out</c> if
            the given debug level if bigger than
            <c>DEBUG_LEVEL</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Object)">
      <summary>Prints the given object to <c>System.err</c> unconditionally.</summary>
      <remarks>Prints the given object to <c>System.err</c> unconditionally.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Object,System.Int32,System.Object)">
      <summary>
            Print the given message to <c>System.err</c> if the fully qualified
            class name of the given source object is encoded
            in the system property <c>y.debug</c>.
            </summary>
      <remarks>
            Print the given message to <c>System.err</c> if the fully qualified
            class name of the given source object is encoded
            in the system property <c>y.debug</c>.
            <p>
            The value of the <c>y.debug</c> property is a colon separated
            list of fully qualified class name prefixes. If the name of the given
            class starts with one of the specified prefixes the debug message will
            be printed to <c>System.err</c>.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Object,System.Object)">
      <summary>
            Print the given message to <c>System.err</c> if the fully qualified
            class name of the given source object is encoded
            in the system property <c>y.debug</c> and
            if the given debug level if bigger than
            <c>DEBUG_LEVEL</c>.
            </summary>
      <remarks>
            Print the given message to <c>System.err</c> if the fully qualified
            class name of the given source object is encoded
            in the system property <c>y.debug</c> and
            if the given debug level if bigger than
            <c>DEBUG_LEVEL</c>.
            <p>
            The value of the <c>y.debug</c> property is a colon separated
            list of fully qualified class name prefixes. If the name of the given
            class starts with one of the specified prefixes the debug message will
            be printed to <c>System.err</c>.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.ShortLog(System.Int32,System.String)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)" />
            , but uses no line-feed.
            </summary>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)" />
            , but uses no line-feed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.ShortLog(System.Object)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)" />
            , but omits newline.
            </summary>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)" />
            , but omits newline.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.ShortLog(System.Object,System.Object)">
      <summary>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)" />
            , but does not append a newline to the
            output.
            </summary>
      <remarks>
            Like
            <see cref="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Log(System.Int32,System.String)" />
            , but does not append a newline to the
            output.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Trace">
      <summary>Outputs a stack trace on <c>System.err.</c></summary>
      <remarks>Outputs a stack trace on <c>System.err.</c></remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Trace(System.Exception)">
      <summary>Outputs a stack trace on <c>System.err</c>.</summary>
      <remarks>Outputs a stack trace on <c>System.err</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.Watch(System.String)">
      <summary>
            Returns true if the given object type is under observation
            due to the <c>-Dy.debug</c> mechanism.
            </summary>
      <remarks>
            Returns true if the given object type is under observation
            due to the <c>-Dy.debug</c> mechanism.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.LoggingUtil.WatchSource(System.Object)">
      <summary>
            Returns true if the given object type is under observation
            due to the <c>-Dy.debug</c> mechanism.
            </summary>
      <remarks>
            Returns true if the given object type is under observation
            due to the <c>-Dy.debug</c> mechanism.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Maps">
      <summary>This class provides convenience and transformation services for Node- and EdgeMaps.</summary>
      <remarks>This class provides convenience and transformation services for Node- and EdgeMaps.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateDataMap(yWorks.yFiles.Util.IMap)">
      <summary>Create a DataMap view of the given map.</summary>
      <remarks>
            Create a DataMap view of the given map.
            Accessing basic value types is solved by
            storing the corresponding wrapper types
            Double, Integer and Boolean within the given Map.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateEdgeMap(yWorks.yFiles.Util.IMap)">
      <summary>Create an EdgeMap view of the given map.</summary>
      <remarks>
            Create an EdgeMap view of the given map.
            Accessing basic value types is solved by
            storing the corresponding wrapper types
            Double, Integer and Boolean within the given Map.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateHashedDataMap">
      <summary>Creates a DataMap that is based on hashing.</summary>
      <remarks>
            Creates a DataMap that is based on hashing.
            The preconditions specified in java.util.HashMap
            apply for the keys and values of this map.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateHashedEdgeMap">
      <summary>Creates an EdgeMap that is based on hashing.</summary>
      <remarks>
            Creates an EdgeMap that is based on hashing.
            The preconditions specified in java.util.HashMap
            apply for the keys and values of this map.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateHashedNodeMap">
      <summary>Creates a NodeMap that is based on hashing.</summary>
      <remarks>
            Creates a NodeMap that is based on hashing.
            The preconditions specified in java.util.HashMap
            apply for the keys and values of this map.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Boolean[])">
      <summary>Returns a EdgeMap view  of a boolean array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a EdgeMap view of the given array</returns>
      <remarks>
            Returns a EdgeMap view  of a boolean array defined for edges.
            The boolean value <c>data[edge.index()]</c> will be accessed
            by the EdgeMap upon the method calls <c>getBool(edge)</c>
            and <c>setBool(edge,value)</c>.
            <p />
            <b>Warning!</b> The indices of the accessed edges must not change during
            the use of this EdgeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Double[])">
      <summary>Returns a EdgeMap view  of a double array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a EdgeMap view of the given array</returns>
      <remarks>
            Returns a EdgeMap view  of a double array defined for edges.
            The double value <c>data[edge.index()]</c> will be accessed
            by the EdgeMap upon the method calls <c>getDouble(edge)</c>
            and <c>setDouble(edge,value)</c>.
            <p />
            <b>Warning!</b> The indices of the accessed edges must not change during
            the use of this EdgeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
            Returns a EdgeMap view  of a double, int, boolean and Object
            array defined for edges.
            </summary>
      <param name="doubleData">double data for each edge of a static graph</param>
      <param name="intData">int data for each edge of a static graph</param>
      <param name="boolData">boolean data for each edge of a static graph</param>
      <param name="objectData">Object data for each edge of a static graph</param>
      <returns>a EdgeMap view of the given arrays</returns>
      <remarks>
            Returns a EdgeMap view  of a double, int, boolean and Object
            array defined for edges.
            <p />
            The double value <c>doubleData[edge.index()]</c> will be accessed
            by the EdgeMap upon the method calls <c>getDouble(edge)</c> and
            <c>setDouble(edge,value)</c>.
            <p />
            The int value <c>intData[edge.index()]</c> will be accessed
            by the EdgeMap upon the method calls <c>getInt(edge)</c> and
            <c>setInt(edge,value)</c>.
            <p />
            The boolean value <c>boolData[edge.index()]</c> will be accessed
            by the EdgeMap upon the method calls <c>getBool(edge)</c> and
            <c>setBool(edge,value)</c>.
            <p />
            The Object value <c>objectData[edge.index()]</c> will be accessed
            by the EdgeMap upon the method calls <c>get(edge)</c> and
            <c>set(edge,value)</c>.
            <p />
            <b>Warning!</b> The indices of the accessed edges must not change during
            the use of this EdgeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Int32[])">
      <summary>Returns a EdgeMap view  of an int array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a EdgeMap view of the given array</returns>
      <remarks>
            Returns a EdgeMap view  of an int array defined for edges.
            The int value <c>data[edge.index()]</c> will be accessed
            by the EdgeMap upon the method calls <c>getInt(edge)</c>
            and <c>setInt(edge,value)</c>.
            <p />
            <b>Warning!</b> The indices of the accessed edges must not change during
            the use of this EdgeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Object[])">
      <summary>Returns a EdgeMap view  of an Object array defined for edges.</summary>
      <param name="data">array data for each edge of a static graph</param>
      <returns>a EdgeMap view of the given array</returns>
      <remarks>
            Returns a EdgeMap view  of an Object array defined for edges.
            The Object value <c>data[edge.index()]</c> will be accessed
            by the EdgeMap upon the method calls <c>get(edge)</c>
            and <c>set(edge,value)</c>.
            <p />
            <b>Warning!</b> The indices of the accessed edges must not change during
            the use of this EdgeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexNodeMap(System.Boolean[])">
      <summary>Returns a NodeMap view  of a boolean array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a NodeMap view of the given array</returns>
      <remarks>
            Returns a NodeMap view  of a boolean array defined for nodes.
            The boolean value <c>data[node.index()]</c> will be accessed
            by the NodeMap upon the method calls <c>getBool(node)</c>
            and <c>setBool(node,value)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexNodeMap(System.Double[])">
      <summary>Returns a NodeMap view  of a double array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a NodeMap view of the given array</returns>
      <remarks>
            Returns a NodeMap view  of a double array defined for nodes.
            The double value <c>data[node.index()]</c> will be accessed
            by the NodeMap upon the method calls <c>getDouble(node)</c>
            and <c>setDouble(node,value)</c>.
            <p />
            <b>Warning!</b> The indices of the accessed nodes must not change during
            the use of this NodeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexNodeMap(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
            Returns a NodeMap view  of a double, int, boolean and Object
            array defined for nodes.
            </summary>
      <param name="doubleData">double data for each node of a static graph</param>
      <param name="intData">int data for each node of a static graph</param>
      <param name="boolData">boolean data for each node of a static graph</param>
      <param name="objectData">Object data for each node of a static graph</param>
      <returns>a NodeMap view of the given arrays</returns>
      <remarks>
            Returns a NodeMap view  of a double, int, boolean and Object
            array defined for nodes.
            <p />
            The double value <c>doubleData[node.index()]</c> will be accessed
            by the NodeMap upon the method calls <c>getDouble(node)</c> and
            <c>setDouble(node,value)</c>.
            <p />
            The int value <c>intData[node.index()]</c> will be accessed
            by the NodeMap upon the method calls <c>getInt(node)</c> and
            <c>setInt(node,value)</c>.
            <p />
            The boolean value <c>boolData[node.index()]</c> will be accessed
            by the NodeMap upon the method calls <c>getBool(node)</c> and
            <c>setBool(node,value)</c>.
            <p />
            The Object value <c>objectData[node.index()]</c> will be accessed
            by the NodeMap upon the method calls <c>get(node)</c> and
            <c>set(node,value)</c>.
            <p />
            <b>Warning!</b> The indices of the accessed nodes must not change during
            the use of this NodeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexNodeMap(System.Int32[])">
      <summary>Returns a NodeMap view  of an int array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a NodeMap view of the given array</returns>
      <remarks>
            Returns a NodeMap view  of an int array defined for nodes.
            The int value <c>data[node.index()]</c> will be accessed
            by the NodeMap upon the method calls <c>getInt(node)</c>
            and <c>setInt(node,value)</c>.
            <b>Warning!</b> The indices of the accessed nodes must not change during
            the use of this NodeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateIndexNodeMap(System.Object[])">
      <summary>Returns a NodeMap view  of an Object array defined for nodes.</summary>
      <param name="data">array data for each node of a static graph</param>
      <returns>a NodeMap view of the given array</returns>
      <remarks>
            Returns a NodeMap view  of an Object array defined for nodes.
            The Object value <c>data[node.index()]</c> will be accessed
            by the NodeMap upon the method calls <c>get(node)</c>
            and <c>set(node,value)</c>.
            <b>Warning!</b> The indices of the accessed nodes must not change during
            the use of this NodeMap.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.CreateNodeMap(yWorks.yFiles.Util.IMap)">
      <summary>Create a NodeMap view of the given map.</summary>
      <remarks>
            Create a NodeMap view of the given map.
            Accessing basic value types is solved by
            storing the corresponding wrapper types
            Double, Integer and Boolean within the given Map.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap">
      <summary>Implementation of a resettable high performance map for values of simple type <c>boolean</c>.</summary>
      <remarks>
            Implementation of a resettable high performance map for values of simple type <c>boolean</c>.
            A high performance map is a facade to another map which will allow to reset
            all bound values to a default value in constant time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.#ctor(yWorks.yFiles.Algorithms.IDataMap,System.Boolean)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor,System.Boolean)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.ResetAll(System.Boolean)">
      <summary>Resets all values to the given default value in constant time.</summary>
      <param name="defaultValue">the new default value</param>
      <remarks>Resets all values to the given default value in constant time.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceBoolMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap">
      <summary>Implementation of a resettable high performance map for values of simple type <c>double</c>.</summary>
      <remarks>
            Implementation of a resettable high performance map for values of simple type <c>double</c>.
            A high performance map is a facade to another map which will allow to reset
            all bound values to a default value in constant time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.#ctor(yWorks.yFiles.Algorithms.IDataMap,System.Double)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor,System.Double)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.ResetAll(System.Double)">
      <summary>Resets all values to the given default value in constant time.</summary>
      <param name="defaultValue">the new default value</param>
      <remarks>Resets all values to the given default value in constant time.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceDoubleMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap">
      <summary>Implementation of a resettable high performance map for values of simple type <c>int</c>.</summary>
      <remarks>
            Implementation of a resettable high performance map for values of simple type <c>int</c>.
            A high performance map is a facade to another map which will allow to reset
            all bound values to a default value in constant time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.#ctor(yWorks.yFiles.Algorithms.IDataMap,System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor,System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.ResetAll(System.Int32)">
      <summary>Resets all values to the given default value in constant time.</summary>
      <param name="defaultValue">the new default value</param>
      <remarks>Resets all values to the given default value in constant time.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceIntMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap">
      <summary>Implementation of a resettable high performance map for values of type <c>Object</c>.</summary>
      <remarks>
            Implementation of a resettable high performance map for values of type <c>Object</c>.
            A high performance map is a facade to another map which will allow to reset
            all bound values to a default value in constant time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.#ctor(yWorks.yFiles.Algorithms.IDataMap,System.Object)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor,System.Object)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.ResetAll(System.Object)">
      <summary>Resets all values to the given default value in constant time.</summary>
      <param name="defaultValue">the new default value</param>
      <remarks>Resets all values to the given default value in constant time.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.Set(System.Object,System.Object)">
      <summary>Associates the given value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to the given node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Maps.HighPerformanceObjectMap.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to the given node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.NodeMapAdapter">
      <summary>This class is an abstract empty implementation of the NodeMap interface.</summary>
      <remarks>
            This class is an abstract empty implementation of the NodeMap interface.
            Subclasses
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Algorithms.Util.NodeMapAdapter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.Get(System.Object)">
      <summary>Returns the value bound to the given node.</summary>
      <param name="key" />
      <returns>
        <see langword="null" />
      </returns>
      <remarks>Returns the value bound to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.GetBool(System.Object)">
      <summary>Returns the boolean value bound to the given node.</summary>
      <param name="key" />
      <returns>
        <see langword="false" />
      </returns>
      <remarks>Returns the boolean value bound to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.GetDouble(System.Object)">
      <summary>Returns the double value bound to the given node.</summary>
      <returns>
        <c>0.0d</c>
      </returns>
      <remarks>Returns the double value bound to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.GetInt(System.Object)">
      <summary>Returns the integer value bound to the given node.</summary>
      <returns>
        <c>0</c>
      </returns>
      <remarks>Returns the integer value bound to the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.Set(System.Object,System.Object)">
      <summary>Associates the given value to with the given node.</summary>
      <remarks>Associates the given value to with the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.SetBool(System.Object,System.Boolean)">
      <summary>Associates the given boolean value to with the given node.</summary>
      <remarks>Associates the given boolean value to with the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.SetDouble(System.Object,System.Double)">
      <summary>Associates the given double value to with the given node.</summary>
      <remarks>Associates the given double value to with the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.NodeMapAdapter.SetInt(System.Object,System.Int32)">
      <summary>Associates the given integer value to with the given node.</summary>
      <remarks>Associates the given integer value to with the given node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ">
      <summary>Implements a priority queue for nodes based on AVL Trees.</summary>
      <remarks>
            Implements a priority queue for nodes based on AVL Trees.
            The priority values may be non-negative.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns an empty Priority-Queue.</summary>
      <param name="_graph">the graph which contains the nodes</param>
      <remarks>Returns an empty Priority-Queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.#ctor(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns a new Priority-Queue initialized with all nodes of the graph.</summary>
      <param name="_graph">the graph which contains the nodes</param>
      <param name="_initValues">the initial priority-values of the nodes.</param>
      <remarks>Returns a new Priority-Queue initialized with all nodes of the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.#ctor(yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns an empty Priority-Queue.</summary>
      <param name="_valueMap">here the priority values are stored</param>
      <remarks>
            Returns an empty Priority-Queue.
            This constructor takes a <c>NodeMap</c> as argument
            which is used to store the priority values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Add(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Inserts a node into the queue.</summary>
      <remarks>Inserts a node into the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Clear">
      <summary>Removes all entities from the queue.<br /></summary>
      <remarks>Removes all entities from the queue.<br /></remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Contains(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is contained within this queue.<br /></summary>
      <remarks>Returns whether or not the given node is contained within this queue.<br /></remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.DecreasePriority(yWorks.yFiles.Algorithms.Node,System.Int32)">
      <summary>Decreases the value of a node in the queue to a certain value.<br /></summary>
      <param name="n">a node in the priority queue.</param>
      <param name="value">the new priority value of the node.</param>
      <remarks>Decreases the value of a node in the queue to a certain value.<br /></remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Dispose">
      <summary>Disposes this queue.</summary>
      <remarks>
            Disposes this queue. It is important to call this method after the queue
            is not needed anymore, to free hold resources.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Empty">
      <summary>Specifies whether or not this queue is empty.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.GetPriority(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the current priority of the given node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Min">
      <summary>The node with the minimal value in the queue.<br /></summary>
      <remarks>Returns the node with the minimal value in the queue.<br /></remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes a node from the queue.</summary>
      <remarks>Removes a node from the queue.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.TreeIntNodePQ.RemoveMin">
      <summary>Removes the node with the minimal value from the queue.<br /></summary>
      <remarks>Removes the node with the minimal value from the queue.<br /></remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.Tuple">
      <summary>
            This class represents an ordered 2-Tuple that is consistent with
            <c>equals()</c> and <c>hashCode()</c>.
            </summary>
      <remarks>
            This class represents an ordered 2-Tuple that is consistent with
            <c>equals()</c> and <c>hashCode()</c>. Therefore it can
            safely be used within HashTables, HashSets, HashMaps and the like.
            Using the static <c>create</c> methods, it is possible to
            build 3,4,5-Tuples recursively out of multiple 2-Tuples.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.#ctor(System.Object,System.Object)">
      <summary>Constructs a 2-Tuple using the two given Objects</summary>
      <param name="o1">The first element (may be <see langword="null" />)</param>
      <param name="o2">The second element (may be <see langword="null" />)</param>
      <remarks>Constructs a 2-Tuple using the two given Objects</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.Create(System.Object,System.Object)">
      <summary>Factory method to create a 2-Tuple</summary>
      <remarks>Factory method to create a 2-Tuple</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.Create(System.Object,System.Object,System.Object)">
      <summary>Factory method to create a 3-Tuple</summary>
      <remarks>Factory method to create a 3-Tuple</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.Create(System.Object,System.Object,System.Object,System.Object)">
      <summary>Factory method to create a 4-Tuple</summary>
      <remarks>Factory method to create a 4-Tuple</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.Create(System.Object,System.Object,System.Object,System.Object,System.Object)">
      <summary>Factory method to create a 5-Tuple</summary>
      <remarks>Factory method to create a 5-Tuple</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.Equals(System.Object)">
      <summary>Determines if the given Tuple equals another Tuple.</summary>
      <param name="o">the element to compare this tuple with</param>
      <returns>true iff o equals this</returns>
      <remarks>
            Determines if the given Tuple equals another Tuple.
            Returns true iff both elements are equal
            (both null or equals() returns <see langword="true" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.GetHashCode">
      <summary>Generates a hashCode using the two tuple elements.</summary>
      <returns>a hashCode built using the hashCodes of the two elements.</returns>
      <remarks>Generates a hashCode using the two tuple elements.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.Tuple.o1">
      <summary>The first element of the Tuple</summary>
      <remarks>The first element of the Tuple</remarks>
    </member>
    <member name="F:yWorks.yFiles.Algorithms.Util.Tuple.o2">
      <summary>The second element of the Tuple</summary>
      <remarks>The second element of the Tuple</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.Tuple.ToString">
      <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
      <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider">
      <summary>This class can be used to wrap a given DataProvider with another one.</summary>
      <remarks>
            This class can be used to wrap a given DataProvider with another one.
            It is intended to work with DataProviders providing Objects only.
            Whenever data is not found in the decorating DataProvider (known as the wrapper).
            The underlying data provider will be queried.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.Graph,System.Object)">
      <summary>Creates a new instance of WrappedDataProvider.</summary>
      <param name="wrapper">the wrapping data provider</param>
      <param name="graph">the graph which will be registered with the data providers</param>
      <param name="dataProviderKey">the key used for registering</param>
      <remarks>
            Creates a new instance of WrappedDataProvider. This instance
            will delegate queries to the wrapper first. Unsatisfied requests
            will be delegated to the original provider. This method wraps the
            currently registered DataProvider with <c>this</c>. This can be undone
            by calling <c>unwrap()</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.#ctor(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Creates a new instance of WrappedDataProvider.</summary>
      <param name="wrapper">The DataProvider instance which will be queried first</param>
      <param name="provider">the data provider which will be wrapped by the first one</param>
      <remarks>
            Creates a new instance of WrappedDataProvider. This instance
            will delegate queries to the wrapper first. Unsatisfied requests
            will be delegated to the original second provider.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.DataMapView">
      <summary>A DataMap that can be used to read and write values.</summary>
      <remarks>Returns a DataMap that can be used to read and write values.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.Dispose">
      <summary>Disposes previously allocated data structures.</summary>
      <remarks>
            Disposes previously allocated data structures. First a call to
            <c>unwrap()</c> is made. Then the wrappers are disposed from the
            graph if they are instances of NodeMaps or EdgeMaps respectively.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.Get(System.Object)">
      <summary>Returns an object value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.GetBool(System.Object)">
      <summary>Returns a boolean value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.GetDouble(System.Object)">
      <summary>Returns a double value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.GetInt(System.Object)">
      <summary>Returns an integer value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.Unwrap">
      <summary>Undoes a previous wrap() operation.</summary>
      <remarks>Undoes a previous wrap() operation.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.Wrap(yWorks.yFiles.Algorithms.Graph,System.Object)">
      <summary>
            Performs the wrapping, the given DataProvider will be unregistered
            from the graph and replaced with this instance.
            </summary>
      <param name="g">the graph which will be registered with the data providers</param>
      <param name="dataProviderKey">the key used for registering</param>
      <remarks>
            Performs the wrapping, the given DataProvider will be unregistered
            from the graph and replaced with this instance.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.WrappedProvider">
      <summary>The underlying wrapped DataProvider.</summary>
      <remarks>Gets the underlying wrapped DataProvider.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.WrappingProvider">
      <summary>The wrapping DataProvider instance.</summary>
      <remarks>
            Gets the wrapping DataProvider instance. This can safely be cast to
            a NodeMap or an EdgeMap respectively if the appropriate static factory
            methods have been used for the construction of <c>this</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.WrapUsingEdgeMap(yWorks.yFiles.Algorithms.Graph,System.Object)">
      <summary>Creates a new instance of WrappedDataProvider.</summary>
      <param name="graph">the graph which will be registered with the data providers</param>
      <param name="dataProviderKey">the key used for registering and wrapping</param>
      <remarks>
            Creates a new instance of WrappedDataProvider. This instance
            will delegate queries to a newly created EdgeMap wrapper first. Unsatisfied requests
            will be delegated to the original provider. This method wraps the
            currently registered DataProvider with the returned DataProvider instance.
            This can be undone
            by calling <c>unwrap()</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.WrappedObjectDataProvider.WrapUsingNodeMap(yWorks.yFiles.Algorithms.Graph,System.Object)">
      <summary>Creates a new instance of WrappedDataProvider.</summary>
      <param name="graph">the graph which will be registered with the data providers</param>
      <param name="dataProviderKey">the key used for registering and wrapping</param>
      <remarks>
            Creates a new instance of WrappedDataProvider. This instance
            will delegate queries to a newly created NodeMap wrapper first. Unsatisfied requests
            will be delegated to the original provider. This method wraps the
            currently registered DataProvider with the returned DataProvider instance.
            This can be undone
            by calling <c>unwrap()</c>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Algorithms.Util.YRandom">
      <summary>Generates pseudo-random numbers and the such.</summary>
      <remarks>Generates pseudo-random numbers and the such.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.#ctor">
      <summary>Creates a new instance of this class.</summary>
      <remarks>Creates a new instance of this class.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.#ctor(System.Int64)">
      <summary>
            Creates a new instance of this class with a given
            initial random seed.
            </summary>
      <remarks>
            Creates a new instance of this class with a given
            initial random seed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.GetBoolArray(System.Int32,System.Int32)">
      <summary>
            Returns an array of <c>n</c> randomly chosen boolean values
            of which <c>trueCount</c> of them are <see langword="true" />.
            </summary>
      <remarks>
            Returns an array of <c>n</c> randomly chosen boolean values
            of which <c>trueCount</c> of them are <see langword="true" />.
            If the requested numbers of true values is bigger than the number
            of requested boolean values, an Exception is raised.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.GetIntArray(System.Int32,System.Int32)">
      <summary>
            Returns an int array of length <c>bucketCount</c> for
            which the values of all fields are non-negative and sum up
            to <c>ballCount</c>.
            </summary>
      <remarks>
            Returns an int array of length <c>bucketCount</c> for
            which the values of all fields are non-negative and sum up
            to <c>ballCount</c>. The values are put
            in the array randomly.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.GetUniqueArray(System.Int32,System.Int32,System.Int32)">
      <summary>
            Returns an array of <c>n</c> unique random integers that
            lie within the range <c>min</c> (inclusive) and
            <c>max</c> (exclusive).
            </summary>
      <remarks>
            Returns an array of <c>n</c> unique random integers that
            lie within the range <c>min</c> (inclusive) and
            <c>max</c> (exclusive). If <c>max - min &lt; n</c>
            then <see langword="null" /> is returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.NextDouble(System.Double,System.Double)">
      <summary>
            Returns a double with a random value between <c>minValue</c>
            (inclusive) and <c>maxValue</c> (exclusive).
            </summary>
      <remarks>
            Returns a double with a random value between <c>minValue</c>
            (inclusive) and <c>maxValue</c> (exclusive).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.NextInt(System.Int32)">
      <summary>
            Returns a pseudo-random, uniformly distributed <tt>int</tt> value
            between 0 (inclusive) and the specified value (exclusive), drawn from
            this random number generator's sequence.
            </summary>
      <remarks>
            Returns a pseudo-random, uniformly distributed <tt>int</tt> value
            between 0 (inclusive) and the specified value (exclusive), drawn from
            this random number generator's sequence.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.NextInt(System.Int32,System.Int32)">
      <summary>
            Returns an int with a random value between <c>minValue</c>
            (inclusive) and <c>maxValue</c> (exclusive).
            </summary>
      <remarks>
            Returns an int with a random value between <c>minValue</c>
            (inclusive) and <c>maxValue</c> (exclusive).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Algorithms.Util.YRandom.Permutate(System.Object[])">
      <summary>Permutes the positions of the elements within the given array.</summary>
      <remarks>Permutes the positions of the elements within the given array.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.AbstractLayoutStage">
      <summary>
            Partial LayoutStage implementation that handles
            the management of the core layouter part.
            </summary>
      <remarks>
            Partial LayoutStage implementation that handles
            the management of the core layouter part.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.#ctor">
      <summary>Default constructor.</summary>
      <remarks>Default constructor.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes this AbstractLayoutStage with the given core Layouter.</summary>
      <remarks>Initializes this AbstractLayoutStage with the given core Layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Queries the core layouter whether or not the given graph
            can be laid out.
            </summary>
      <remarks>
            Queries the core layouter whether or not the given graph
            can be laid out.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.AbstractLayoutStage.CoreLayouter">
      <summary>The core layouter.</summary>
      <remarks>Specifies the core layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.AbstractLayoutStage.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Invokes the layout routine of the core layouter.</summary>
      <remarks>Invokes the layout routine of the core layouter.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.BendConverter">
      <summary>
            This layout stage replaces bends with dummy nodes, calls the core layout
            algorithm and recreates the bends.
            </summary>
      <remarks>
            This layout stage replaces bends with dummy nodes, calls the core layout
            algorithm and recreates the bends. Note that not all data provider values
            bound to the edges will be automatically adopted be the replacement edges.
            The adopted values must be provided by data providers registered with one of
            the following known keys:
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.#ctor">
      <summary>Creates a new instance of BendConverter</summary>
      <remarks>Creates a new instance of BendConverter</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.#ctor(System.Double)">
      <summary>
            Creates a new instance of BendConverter using the given size as
            the width and height for the dummy nodes.
            </summary>
      <remarks>
            Creates a new instance of BendConverter using the given size as
            the width and height for the dummy nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.AddedPathForEdge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.NodeList)">
      <summary>
            Callback method that will be invoked after new elements for the given edge
            have been added to the given graph.
            </summary>
      <remarks>
            Callback method that will be invoked after new elements for the given edge
            have been added to the given graph. At this point the original edge is still
            in the graph./
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.BendConverter.AdoptEdgeGroups">
      <summary>
            Specifies whether or not the edge group values of the original edge
            should be adopted by its replacement edges.
            </summary>
      <remarks>
            Specifies whether or not the edge group values of the original edge
            should be adopted by its replacement edges. The group node values
            are looked up in DataProviders registered with the keys
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.BendConverter.AdoptPortConstraints">
      <summary>
            Specifies whether or not the port constraint values of the original edge
            should be adopted by its replacement edges.
            </summary>
      <remarks>
            Specifies whether or not the port constraint values of the original edge
            should be adopted by its replacement edges. The group node values
            are looked up in DataProviders registered with the keys
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.BendConverter.AdoptSelection">
      <summary>
            Specifies whether or not the selection state of the original edge
            should be adopted by its replacement edges.
            </summary>
      <remarks>
            Specifies whether or not the selection state of the original edge
            should be adopted by its replacement edges. The selection state
            is looked up in DataProviders registered with the key
            returned by
            <see cref="P:yWorks.yFiles.Layout.BendConverter.SelectedEdgesDpKey" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.BendConverter.CoreLayouter">
      <summary>The core layouter.</summary>
      <remarks>Specifies the core layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.BendConverter.Prepare(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Prepares the graph before calling the core layouter</summary>
      <remarks>Prepares the graph before calling the core layouter</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.BendConverter.ScopeDpKey">
      <summary>
            DataProvider key used to specify the set of edges for which
            this stage will replace bends by nodes.
            </summary>
      <remarks>
            DataProvider key used to specify the set of edges for which
            this stage will replace bends by nodes. If this
            data provider key is being used, then it
            must return for each edge in the input graph a boolean value indicating whether
            or not it should be handled by this layouter.
            If there is no data provider registered with this key, all edges will be handled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.BendConverter.SelectedEdgesDpKey">
      <summary>
            The <c>DataProvider</c> key to identify edges as
            <em>selected</em>.
            </summary>
      <exception cref="T:System.ArgumentException">if the specified key is <see langword="null" />.</exception>
      <remarks>
            Specifies the <c>DataProvider</c> key to identify edges as
            <em>selected</em>.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedEdgesDpKey" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BendConverter.Unprepare(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Undoes the graph changes performed by
            <see cref="M:yWorks.yFiles.Layout.BendConverter.Prepare(yWorks.yFiles.Layout.LayoutGraph)" />
            after the
            core layouter has finished.
            </summary>
      <remarks>
            Undoes the graph changes performed by
            <see cref="M:yWorks.yFiles.Layout.BendConverter.Prepare(yWorks.yFiles.Layout.LayoutGraph)" />
            after the
            core layouter has finished.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.BufferedLayouter">
      <summary>
            A hull layouter that invokes another layout algorithm on a copy of its input
            graph.
            </summary>
      <remarks>
            A hull layouter that invokes another layout algorithm on a copy of its input
            graph.
            <p />
            After the layout process has finished the calculated layout
            will be either written back to the original graph or
            will be provided as a separate graph layout information
            in terms of the original input graph.
            <p />
            This class also provides the possibility to perform arbitrary
            layout algorithms merely on a graph interface plus associated
            graph layout. This comes in handy if an application has its own
            graph and merely provides an graph interface adapter to the yFiles
            graph layout machinery.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.#ctor">
      <summary>Instantiates a new BufferedLayouter.</summary>
      <remarks>
            Instantiates a new BufferedLayouter.
            No core layouter will be bound this layouter yet.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Instantiates a new BufferedLayouter that wraps
            the given core layouter.
            </summary>
      <remarks>
            Instantiates a new BufferedLayouter that wraps
            the given core layouter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.CalcLayout(yWorks.yFiles.Algorithms.IGraphInterface,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>Invokes the core Layouter on a copy of the given graph.</summary>
      <returns>the calculated graph layout for the given graph</returns>
      <remarks>Invokes the core Layouter on a copy of the given graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.CalcLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Invokes the core Layouter on a copy of the given graph.</summary>
      <returns>the calculated graph layout for the given graph</returns>
      <remarks>Invokes the core Layouter on a copy of the given graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Whether or not this layouter can layout the given graph.</summary>
      <remarks>
            Whether or not this layouter can layout the given graph.
            The result of this method will be provided by the associated
            core layouter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.DoLayout(yWorks.yFiles.Algorithms.IGraphInterface,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>Invokes the core Layouter on a copy of the given graph.</summary>
      <remarks>
            Invokes the core Layouter on a copy of the given graph.
            The calculated layout will be written back to the given graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.BufferedLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Invokes the core Layouter on a copy of the given graph.</summary>
      <remarks>
            Invokes the core Layouter on a copy of the given graph.
            The calculated layout will be written back to the given graph.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.CanonicMultiStageLayouter">
      <summary>
            An abstract base class for layout algorithms that
            provides services to simplify and decompose the input graph
            before it is passed to the core layout routine itself.
            </summary>
      <remarks>
            An abstract base class for layout algorithms that
            provides services to simplify and decompose the input graph
            before it is passed to the core layout routine itself.
            <p />
            Subclass layout algorithms have to provide implementations
            for the abstract methods
            <br />
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            <br />and
            <br />
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            The maximal number of steps involved before and after the core layout
            will be invoked are summarized below.
            <ol>
            <li>Copy the input graph</li>
            <li>Hide all but the induced subgraph</li>
            <li>Decompose the graph into it's connected components. On each component
            perform the steps 3-11</li>
            <li>Prepare for an orientation change</li>
            <li>Hide parallel edges</li>
            <li>Hide self-loops</li>
            <li>Invoke core layouter on simplified graph</li>
            <li>Unhide and route self-loops</li>
            <li>Unhide and route parallel edges</li>
            <li>Complete orientation change of layout</li>
            <li>Arrange connected components of the graph</li>
            <li>Unhide non-induced subgraph</li>
            <li>Assign label positions</li>
            <li>Copy layout information back to original input graph or pass out
            layout information separately</li>
            </ol>
            Each of the phases above can be subdued if necessary.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.#ctor">
      <summary>Constructs a new AbstractLayouter</summary>
      <remarks>Constructs a new AbstractLayouter</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.AppendStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Appends a stage to the layout pipeline.</summary>
      <remarks>
            Appends a stage to the layout pipeline. Stages added with this method will be
            invoked just before the core layouter will be invoked.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CalcLayout(yWorks.yFiles.Algorithms.IGraphInterface,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>Returns a layout for the given graph interface and layout.</summary>
      <remarks>
            Returns a layout for the given graph interface and layout.
            The given graph and layout will not be modified by the layout process.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CalcLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns a layout for the given layout graph.</summary>
      <remarks>
            Returns a layout for the given layout graph.
            The given graph will not be modified by the layout process.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Tests whether or not the given graph can be laid out
            by this layouter.
            </summary>
      <remarks>
            Tests whether or not the given graph can be laid out
            by this layouter. All stage layouters and the core layouter must
            be able to calculate the layout to make this test successful.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
      <remarks>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            It is called by the
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method for each group node object in the input graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            It is called by the
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method for each node object in the input graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">
      <summary>
            The LayoutStage responsible for laying out the
            connected components of the graph.
            </summary>
      <remarks>
            Specifies the LayoutStage responsible for laying out the
            connected components of the graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouterEnabled">
      <summary>
            Specifies whether or not ComponentLayouter
            is enabled.
            </summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to enable the ComponentLayouter.
            By default it is enabled.
            <para />
            Getter:<br />
            Returns whether or not ComponentLayouter
            is enabled.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.DoLayout(yWorks.yFiles.Algorithms.IGraphInterface,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>
            Calculates a layout for the given graph interface
            and layout.
            </summary>
      <remarks>
            Calculates a layout for the given graph interface
            and layout. The calculated layout will be written
            back to the given layout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
      <remarks>
            Calculates a layout for the given graph.
            The given graph will not be copied during the
            layout process and the layout will be
            immediately applied to the given graph.
            This method is not side effect free in the sense that
            the order of edges or nodes in the input graph
            may change during the layout process.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
      <remarks>Subclasses have to provide core layout code in this method.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.EnableOnlyCore">
      <summary>Disables all layout stages and performs only the core layouter.</summary>
      <remarks>Disables all layout stages and performs only the core layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.GroupNodeHider">
      <summary>
            The <c>LayoutStage</c> that is responsible for
            hiding away grouping information for the layout algorithm.
            </summary>
      <remarks>
            Specifies the <c>LayoutStage</c> that is responsible for
            hiding away grouping information for the layout algorithm.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.HideGroupNodes">
      <summary>Specifies whether or not to hide away group nodes before the layout begins.</summary>
      <remarks>
            Specifies whether or not to hide away group nodes before the layout begins.
            By default this is enabled for instances that cannot deal with node
            groupings.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">
      <summary>The algorithm used for placing labels.</summary>
      <remarks>
            Getter:<br />
            Returns the algorithm used for placing labels.
            By default an instance of class
            <see cref="T:yWorks.yFiles.Layout.Labeling.GreedyMISLabeling" />
            will be returned.
            <para />
            Setter:<br />
            Sets the algorithm used for placing labels. Note that
            assigning a new layout stage will not automatically activate it.
            To activate this stage use
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouterEnabled" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouterEnabled">
      <summary>
            Specifies whether or not LabelLayouter
            is enabled.
            </summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to enable the labeling algorithm.
            By default it is disabled.
            <para />
            Getter:<br />
            Returns whether or not LabelLayouter
            is enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LayoutOrientation">
      <summary>The main layout orientation.</summary>
      <remarks>
            Specifies the main layout orientation. The layouter tries to arrange nodes
            in such a way that all edges point in the main layout direction.
            <p>
            Note, the documentation for the other layout options assumes that the
            default layout orientation
            <see cref="F:yWorks.yFiles.Layout.LayoutOrientation.TopToBottom" />
            is
            being used.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.OrientationLayouter">
      <summary>
            The LayoutStage that is responsible for
            changing the orientation of the computed layout.
            </summary>
      <remarks>
            Specifies the LayoutStage that is responsible for
            changing the orientation of the computed layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.OrientationLayouterEnabled">
      <summary>
            Specifies whether or not the OrientationLayouter
            is enabled.
            </summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to enable the OrientationLayouter.
            By default it is activated but does not change
            orientation of the layout.
            <para />
            Getter:<br />
            Returns whether or not the OrientationLayouter
            is enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ParallelEdgeLayouter">
      <summary>
            The LayoutStage responsible for routing
            parallel edges.
            </summary>
      <remarks>
            Getter:<br />
            Returns the LayoutStage responsible for routing
            parallel edges. By default an instance of class
            <see cref="T:yWorks.yFiles.Layout.ParallelEdgeLayouter" />
            will be returned.
            <para />
            Setter:<br />
            Sets the ParallelEdgeLayouter responsible for routing
            parallel edges.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ParallelEdgeLayouterEnabled">
      <summary>
            Specifies whether or not the ParallelEdgeLayouter
            is enabled.
            </summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to enable the ParallelEdgeLayouter.
            By default it is enabled.
            <para />
            Getter:<br />
            Returns whether or not the ParallelEdgeLayouter
            is enabled.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.PrependStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Prepends a stage to the layout pipeline.</summary>
      <remarks>
            Prepends a stage to the layout pipeline. Stage added with this method
            will be invoked before any other stages will be invoked.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.RemoveStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>
            Removes a LayoutStage that has been previously added by the methods
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.AppendStage(yWorks.yFiles.Layout.ILayoutStage)" />
            or
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.PrependStage(yWorks.yFiles.Layout.ILayoutStage)" />
            .
            </summary>
      <remarks>
            Removes a LayoutStage that has been previously added by the methods
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.AppendStage(yWorks.yFiles.Layout.ILayoutStage)" />
            or
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.PrependStage(yWorks.yFiles.Layout.ILayoutStage)" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.SelfLoopLayouter">
      <summary>
            The LayoutStage used for routing
            Self-loops.
            </summary>
      <remarks>
            Getter:<br />
            Returns the LayoutStage used for routing
            Self-loops. By default an instance of class
            <see cref="T:yWorks.yFiles.Layout.SelfLoopLayouter" />
            will be returned.
            <para />
            Setter:<br />
            Sets the LayoutStage responsible for routing
            Self-loops.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.SelfLoopLayouterEnabled">
      <summary>
            Specifies whether or not the SelfLoopLayouter
            is enabled.
            </summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to enable the SelfLoopLayouter.
            By default it is enabled.
            <para />
            Getter:<br />
            Returns whether or not the SelfLoopLayouter
            is enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.SubgraphLayouter">
      <summary>
            The LayoutStage that is responsible for
            constraining the layout process to a subgraph
            of the target graph.
            </summary>
      <remarks>
            Specifies the LayoutStage that is responsible for
            constraining the layout process to a subgraph
            of the target graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.SubgraphLayouterEnabled">
      <summary>
            Specifies whether or not the SubgraphLayouter
            is enabled.
            </summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to enable the SubgraphLayouter.
            By default it is disabled.
            <para />
            Getter:<br />
            Returns whether or not the SubgraphLayouter
            is enabled.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.ComponentArrangementStyles" />
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.None">
      <summary>
            Style specification constant describing no special component arrangement at all.
            Components will be centered at the same position they resided at before the layout
            started. If combined with the style modifier
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.ModifierNoOverlap" />
            components might get moved so that they don't overlap after the layout.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.Rows">
      <summary>
            Style specification constant describing a component arrangement strategy that
            tries to place components in multiple rows so that the overall aspect ratio of all
            components gets as close to the aspect ratio of the preferred layout size as possible.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.SingleRow">
      <summary>
            Style specification constant describing a component arrangement strategy that
            places components next to each other in a single row. If combined with the
            style modifier
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.ModifierAsIs" />
            components will be placed in the same order as they were placed before the layout.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.SingleColumn">
      <summary>
            Style specification constant describing a component arrangement strategy that
            places components above each other in a single column. If combined with the
            style modifier
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.ModifierAsIs" />
            components will be placed in the same order as they were placed before the layout.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedRectangle">
      <summary>
            Style specification constant describing a component arrangement strategy that
            tries to place components like in a rectangular cloud around the biggest component. Entities
            of different components will not overlap, however the bounding boxes of the components
            may overlap.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactRectangle">
      <summary>
            Style specification constant describing a component arrangement strategy that
            tries to place components like in a rectangular cloud around the biggest component. Entities
            of different components will not overlap, however the bounding boxes of the components
            may overlap. In contrast to
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedRectangle" />
            components might even be placed in empty spaces inside other components.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCircle">
      <summary>
            Style specification constant describing a component arrangement strategy that
            tries to place components like in a cloud around the biggest component. Entities
            of different components will not overlap, however the bounding boxes of the components
            may overlap.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactCircle">
      <summary>
            Style specification constant describing a component arrangement strategy that
            tries to place components like in a cloud around the biggest component. Entities
            of different components will not overlap, however the bounding boxes of the components
            may overlap. In contrast to
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCircle" />
            components might even be placed in empty spaces inside other components.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.Mask">
      <summary>Use this constant for masking actual styles constants from style modifiers.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.ModifierAsIs">
      <summary>
            Modifier constant that can be added to normal style constants to indicate that
            the arrangement strategy should take the initial positions of the components
            into account.
            <br />
            Combining this modifier is supported with the following styles:
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.SingleRow" />
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.SingleColumn" />
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedRectangle" />
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactRectangle" />
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCircle" />
            , and
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactCircle" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentArrangementStyles.ModifierNoOverlap">
      <summary>
            Modifier constant that can be added to normal style constants to indicate that
            the arrangement strategy should produce a non-overlapping component layout.
            <br />
            Combining this modifier is supported with
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.None" />
            .
            <p>
            Note that non-overlapping component layout (in the sense that no elements from
            adjacent components overlap) is inherently supported by the following styles:
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedRectangle" />
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactRectangle" />
            ,
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCircle" />
            ,
            and
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.PackedCompactCircle" />
            .
            </p></summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.ComponentLayouter">
      <summary>This layout stage arranges the connected components of a graph.</summary>
      <remarks>
            This layout stage arranges the connected components of a graph.
            <p>
            It is possible to specify a core layout algorithm that will
            be invoked on all connected components of the graph
            before this layouter arranges the components themselves.
            </p>
            <p>
            ComponentLayouter will handle hierarchically grouped graphs in a special way.
            The contents of a group node will always belong to the same component
            as the group node itself.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.#ctor">
      <summary>Initializes a new <c>ComponentLayouter</c> instance.</summary>
      <remarks>Initializes a new <c>ComponentLayouter</c> instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new <c>ComponentLayouter</c> instance.</summary>
      <param name="coreLayouter">
            the layout algorithm that is invoked for connected
            components of the input graph.
            </param>
      <remarks>Initializes a new <c>ComponentLayouter</c> instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.ArrangeComponents(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.EdgeList[],yWorks.yFiles.Algorithms.Geometry.YRectangle[],yWorks.yFiles.Util.Geom.Rectangle2D[])">
      <summary>Produces a non-overlapping component graph layout.</summary>
      <param name="graph">the layout graph.</param>
      <param name="nodes">array of type NodeList. The i-th NodeList contains all nodes of the i-th graph component.</param>
      <param name="edges">array of type EdgeList. The i-th NodeList contains all edges of the i-th graph component.</param>
      <param name="bbox">array of type YRectangle. The i-th YRectangle contains the current bounding box of the i-th graph component.</param>
      <param name="boxes">
            array of type Rectangle2D. The i-th Rectangle2D contains the extended bounding box of the i-th graph component.
            The method arrange these boxes in such a way that they do not overlap. Then the i-th graph component must be placed
            inside the i-th box.
            </param>
      <remarks>
            Produces a non-overlapping component graph layout.
            This method moves the graph components in such a
            fashion that their bounding boxes do not
            overlap. The arrangement strategy used is takes
            the ratio of the overall layout area into account.
            <p />
            Subclasses may want to overwrite this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.ArrangeFields(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.EdgeList[],yWorks.yFiles.Algorithms.Geometry.YRectangle[],yWorks.yFiles.Util.Geom.Rectangle2D[],System.Boolean,System.Boolean,System.Boolean)" />
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.CalcBoundingBox(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates and returns the bounding box of a graph component.</summary>
      <remarks>
            Calculates and returns the bounding box of a graph component. This method will be
            invoked for each component of the graph. Depending on the state of
            property <c>labelAwarenessEnabled</c> the returned bounding box will
            also take node and edge labels into account.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Determines if the preconditions for the graph layout algorithm
            are fulfilled, by applying them to the connected components.
            </summary>
      <remarks>
            Determines if the preconditions for the graph layout algorithm
            are fulfilled, by applying them to the connected components.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.ComponentArrangement">
      <summary>
            Specifies whether or not the separately laid out components of the input graph should be
            arranged by this class.
            </summary>
      <remarks>
            Specifies whether or not the separately laid out components of the input graph
            should be arranged by this class.
            <p>
            By default this feature is enabled.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.ComponentSpacing">
      <summary>The current component spacing.</summary>
      <remarks>
            Specifies the current component spacing.
            This value represents the minimum
            allowed distance between the bounding boxes of to components.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.ConsiderLabels">
      <summary>
            Determines whether or not to take node and edge labels into account when
            calculating the bounding box of the graph components.
            </summary>
      <remarks>
            Specifies whether or not to take node and edge labels into account when
            calculating the bounding box of the graph components.
            <p>
            By default this feature is enabled.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculate the layout.</summary>
      <remarks>
            Calculate the layout.
            This is done by decomposing the graph in its connected components
            and applying the core layout algorithm on each component.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.FindGraphComponents(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Determines which nodes will belong to the same graph component.</summary>
      <param name="graph">the input graph</param>
      <param name="compNumber">
            return value that will hold the zero-based number
            of the component that it belongs to. The component number of
            Node <c>v</c> is <c>compNum.getInt(v)</c>.
            </param>
      <returns>the number of connected components of this graph.</returns>
      <remarks>
            Determines which nodes will belong to the same graph component.
            Additionally to normal connectedness a group node and all of its children
            will belong to the same component.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentLayouter.GivenComponentDpKey">
      <summary>DataProvider key that can be used to determine components by hand.</summary>
      <remarks>
            DataProvider key that can be used to determine components by hand.
            The algorithm will use the
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)" />
            method to query for
            object instances that will be used to determine components:
            If <see langword="null" /> is returned for a node that node's component will be determined as usual.
            If non-<see langword="null" /> values are returned, they will be compared using their natural order
            (
            <see cref="T:System.IComparable" />
            ) to determine the component order.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.GridSpacing">
      <summary>The current grid spacing.</summary>
      <remarks>
            Specifies the current grid spacing.
            If this value is set to a value greater than 0, components will be moved by
            multiples of this value. This assures, that laid out subcomponents, which
            adhere to a known grid, will stay on their grid.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.GroupingActive">
      <summary>
            Determines whether or not grouping information bound to the graph will be
            used to calculate the components.
            </summary>
      <remarks>
            Getter:<br />
            Determines whether or not grouping information bound to the graph will be
            used to calculate the components.
            <p>
            The default value is <see langword="true" />.
            </p>
            <para />
            Setter:<br />
            Specifies whether or not grouping information bound to the graph should be
            used to determine the connectedness of the graph structure.
            <p>
            The default value is <see langword="true" />.
            </p>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.ComponentLayouter.LayoutNodeDpKey">
      <summary>DataProvider key that can be used to determine which nodes should be laid out.</summary>
      <remarks>
            DataProvider key that can be used to determine which nodes should be laid out.
            Note that components will be laid out if and only if at least one of the nodes
            that make up the component returns <see langword="true" /> if queried through the
            DataProvider instance. If no such instance is registered with the graph,
            all components will be laid out by the core layout algorithm.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.PreferredLayoutSize">
      <summary>The preferred layout size for this layouter.</summary>
      <remarks>Gets the preferred layout size for this layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.SetOrigin(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.EdgeList,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>Sets the origin for a subgraph.</summary>
      <remarks>Sets the origin for a subgraph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ComponentLayouter.SetPreferredLayoutSize(System.Double,System.Double)">
      <summary>Sets the preferred layout size for this layouter.</summary>
      <param name="width">the preferred width of the calculated graph layout.</param>
      <param name="height">the preferred height of the calculated graph layout.</param>
      <remarks>Sets the preferred layout size for this layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ComponentLayouter.Style">
      <summary>The component arrangement style used by this <c>ComponentLayouter</c>.</summary>
      <remarks>
            Specifies the component arrangement style used by this <c>ComponentLayouter</c>.
            <p>
            The default is
            <see cref="F:yWorks.yFiles.Layout.ComponentArrangementStyles.Rows" />
            .
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.CompositeLayouter">
      <summary>
            A layouter that allows to express a layout stage
            as a chain of more basic layout stages.
            </summary>
      <remarks>
            A layouter that allows to express a layout stage
            as a chain of more basic layout stages.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayouter.#ctor(yWorks.yFiles.Layout.ILayoutStage,yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Creates a new instance of <c>CompositeLayouter</c> with the
            specified <c>LayoutStage</c> prepended to the specified
            <c>Layouter</c>.
            </summary>
      <param name="stage">
            a <c>LayoutStage</c> that is prepended to the specified
            core layouter.
            </param>
      <param name="coreLayouter">
            a <c>Layouter</c> that is used as core (i.e.
            innermost) layouter for this <c>CompositeLayouter</c>.
            </param>
      <remarks>
            Creates a new instance of <c>CompositeLayouter</c> with the
            specified <c>LayoutStage</c> prepended to the specified
            <c>Layouter</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayouter.AppendStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Appends a stage to the layout pipeline.</summary>
      <remarks>
            Appends a stage to the layout pipeline. Stages added with this method will be
            invoked just before the core layouter of the composite layout stage will be invoked.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns true if all layout stages and the core layout stage
            can layout the given graph.
            </summary>
      <remarks>
            Returns true if all layout stages and the core layout stage
            can layout the given graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
      <remarks>Assigns a new graph layout to the given layout graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CompositeLayouter.LayoutStages">
      <summary>The chain of layout stages that make up this composite layout stage.</summary>
      <remarks>Returns the chain of layout stages that make up this composite layout stage.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayouter.PrependStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Prepends a stage to this composite layout stage.</summary>
      <remarks>
            Prepends a stage to this composite layout stage. Stage added with this method
            will be invoked before any other stages will be invoked.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.CompositeLayoutStage">
      <summary>
            A composite layout stage that allows to express a layout stage
            as a chain of more basic layout stages.
            </summary>
      <remarks>
            A composite layout stage that allows to express a layout stage
            as a chain of more basic layout stages.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.#ctor">
      <summary>Creates a new instance of CompositeLayoutStage</summary>
      <remarks>Creates a new instance of CompositeLayoutStage</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.#ctor(yWorks.yFiles.Layout.ILayoutStage,yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Creates a new instance of CompositeLayoutStage</summary>
      <remarks>Creates a new instance of CompositeLayoutStage</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.AppendStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Appends a stage to the layout pipeline.</summary>
      <remarks>
            Appends a stage to the layout pipeline. Stages added with this method will be
            invoked just before the core layouter of the composite layout stage will be invoked.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true" />.</summary>
      <remarks>Returns <see langword="true" />.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
      <remarks>Assigns a new graph layout to the given layout graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CompositeLayoutStage.LayoutStages">
      <summary>The chain of layout stages that make up this composite layout stage.</summary>
      <remarks>Returns the chain of layout stages that make up this composite layout stage.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CompositeLayoutStage.PrependStage(yWorks.yFiles.Layout.ILayoutStage)">
      <summary>Prepends a stage to this composite layout stage.</summary>
      <remarks>
            Prepends a stage to this composite layout stage. Stages added with this method
            will be invoked before any other stages will be invoked.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.CopiedLayoutGraph">
      <summary>
            This is a LayoutGraph implementation that serves as a copy of
            another LayoutGraph or as copy of a combined GraphInterface and
            and GraphLayout interface implementation.
            </summary>
      <remarks>
            This is a LayoutGraph implementation that serves as a copy of
            another LayoutGraph or as copy of a combined GraphInterface and
            and GraphLayout interface implementation.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.#ctor(yWorks.yFiles.Algorithms.IGraphInterface,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>
            Initializes this graph as a copy of the given graph interface
            and graph layout.
            </summary>
      <remarks>
            Initializes this graph as a copy of the given graph interface
            and graph layout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.#ctor(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Initializes this graph as a copy of the given graph</summary>
      <remarks>Initializes this graph as a copy of the given graph</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CommitLayoutToOriginalGraph">
      <summary>Writes the current layout information to the original graph.</summary>
      <remarks>
            Writes the current layout information to the original graph.
            Works only when the graph was constructed as copy of another graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateEdge(System.Object)">
      <summary>Creates an copied edge.</summary>
      <param name="origEdge">the original edge the copied edge is based on</param>
      <returns>the newly created edge (belongs to the copied graph)</returns>
      <remarks>
            Creates an copied edge. The mappings are updated so that it is possible to look up the newly created
            node by using
            <see cref="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetCopiedEdge(System.Object)" />
            .<br />
            This method can be used to keep the CopiedLayoutGraph in sync with the original graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateGraphCopyFactory">
      <summary>
            Creates a factory that delegates to the
            <see cref="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateNode(System.Object)" />
            and
            <see cref="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateEdge(System.Object)" />
            methods of this instance.
            </summary>
      <remarks>
            Creates a factory that delegates to the
            <see cref="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateNode(System.Object)" />
            and
            <see cref="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateEdge(System.Object)" />
            methods of this instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.CreateNode(System.Object)">
      <summary>Creates a copy of the given original node.</summary>
      <param name="origNode">the node of the original graph the copy will be created for</param>
      <returns>the newly created node that represents a copy of the given node.</returns>
      <remarks>
            Creates a copy of the given original node. The mappings are updated so that the lookup methods
            (
            <see cref="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetOriginalNode(yWorks.yFiles.Algorithms.Node)" />
            and
            <see cref="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetCopiedNode(System.Object)" />
            can be used.<br />
            This method is especially useful to keep the CopiedLayoutGraph in sync with the original graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetCopiedEdge(System.Object)">
      <summary>
            Returns the copied edge that corresponds to the given
            original edge.
            </summary>
      <param name="e">an edge in the original graph whose copy is in this graph</param>
      <returns>an edge in this graph that is the copy of the given original edge</returns>
      <remarks>
            Returns the copied edge that corresponds to the given
            original edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetCopiedNode(System.Object)">
      <summary>
            Returns the copied node that corresponds to the given
            original node.
            </summary>
      <param name="v">a node in the original graph whose copy is in this graph</param>
      <returns>a node in this graph that is the copy of the given original node</returns>
      <remarks>
            Returns the copied node that corresponds to the given
            original node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetFeature(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns the edge which is described by a given label layout.</summary>
      <remarks>Returns the edge which is described by a given label layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetFeature(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns the node which is described by a given label layout.</summary>
      <remarks>Returns the node which is described by a given label layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </summary>
      <param name="e">an edge in the drawing.</param>
      <returns>the edge label layout information for the given edge.</returns>
      <remarks>
            Returns EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </summary>
      <param name="v">a node in the drawing.</param>
      <returns>the node label layout information for <c>node</c>.</returns>
      <remarks>
            Returns NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the layout information for an edge in the drawing.</summary>
      <param name="e">an edge in the drawing.</param>
      <returns>the layout information for the given edge.</returns>
      <remarks>Returns the layout information for an edge in the drawing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the layout information for a node in the drawing.</summary>
      <param name="v">a node in the drawing.</param>
      <returns>the layout information for <c>node</c>.</returns>
      <remarks>Returns the layout information for a node in the drawing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetOriginalEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the original edge that corresponds to the given
            edge.
            </summary>
      <param name="e">an edge in this graph that is a copy of the returned edge</param>
      <returns>an edge in the original graph whose copy is the given edge</returns>
      <remarks>
            Returns the original edge that corresponds to the given
            edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.GetOriginalNode(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the original node that corresponds to the given
            node.
            </summary>
      <param name="v">a node in this graph that is a copy of the returned node</param>
      <returns>a node in the original graph whose copy is the given node</returns>
      <remarks>
            Returns the original node that corresponds to the given
            node.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CopiedLayoutGraph.LayoutForOriginalGraph">
      <summary>The GraphLayout that is valid for the original graph.</summary>
      <remarks>
            Returns the GraphLayout that is valid for the original graph. The information contained
            in the GraphLayout is identical to the graph layout associated with this graph, but it
            uses the original graph elements as lookup domain, i.e.
            <c>getLayout(copiedNode)</c> corresponds to
            <c>getLayoutForOriginalGraph().getLayout(getOriginalNode(copiedNode))</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CopiedLayoutGraph.OriginalGraph">
      <summary>The original graph</summary>
      <remarks>Returns the original graph</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.CopiedLayoutGraph.OriginalLayout">
      <summary>The original layout</summary>
      <remarks>Returns the original layout</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.CopiedLayoutGraph.SyncStructure">
      <summary>Synchronizes the structure of the CopiedLayoutGraph with the actual structure of the underlying LayoutGraph.</summary>
      <remarks>Synchronizes the structure of the CopiedLayoutGraph with the actual structure of the underlying LayoutGraph.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.DefaultEdgeLayout">
      <summary>This class is a default implementation of the EdgeLayout interface.</summary>
      <remarks>This class is a default implementation of the EdgeLayout interface.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.#ctor">
      <summary>Creates a new DefaultEdgeLayout.</summary>
      <remarks>Creates a new DefaultEdgeLayout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.#ctor(yWorks.yFiles.Layout.IEdgeLayout)">
      <summary>Creates a new DefaultEdgeLayout which is the copy of another EdgeLayout.</summary>
      <param name="layout">another edge layout</param>
      <remarks>Creates a new DefaultEdgeLayout which is the copy of another EdgeLayout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.AddPoint(System.Double,System.Double)">
      <summary>Adds a control point to the end of the control point sequence.</summary>
      <param name="x">the absolute x-coordinate of the control point.</param>
      <param name="y">the absolute y-coordinate of the control point.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.ClearPoints">
      <summary>Remove all control points from this edge layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.GetPoint(System.Int32)">
      <summary>
            Returns the control point at position <c>index</c> of
            the sequence.
            </summary>
      <param name="index">position of the control point in the control point sequence.</param>
      <returns>the absolute coordinates of the control point at the given index.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.PointCount">
      <summary>Returns the number of control points of the edge.</summary>
      <returns>the number of control points</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultEdgeLayout.SetPoint(System.Int32,System.Double,System.Double)">
      <summary>
            Sets the coordinates of the control point at position <c>index</c> of
            the sequence.
            </summary>
      <param name="index">position of the control point in the control point sequence.</param>
      <param name="x">absolute x-coordinate of the control point at the given index.</param>
      <param name="y">absolute y-coordinate of the control point at the given index.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultEdgeLayout.SourcePoint">
      <summary>
            The relative coordinates of the first end point of this layout
            that is associated with the source node of the edge.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultEdgeLayout.TargetPoint">
      <summary>
            The relative coordinates of the second end point of this layout
            that is associated with the target node of the edge.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.DefaultGraphLayout">
      <summary>
            This class is a default implementation of the simple GraphLayout
            interface.
            </summary>
      <remarks>
            This class is a default implementation of the simple GraphLayout
            interface.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.DefaultGraphLayout" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.GetBoundingBox">
      <summary>
            Returns the bounding box of this graph layout
            This is the smallest rectangle containing the entire layout.
            </summary>
      <remarks>
            Returns the bounding box of this graph layout
            This is the smallest rectangle containing the entire layout.
            If the layout does not contain any node layout information
            (and therefore no edge layout information either),
            the bounding box will have negative width and/or height.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.GetEdgeLabelLayout(System.Object)">
      <summary>Returns the edge label layouts associated with the given edge.</summary>
      <remarks>Returns the edge label layouts associated with the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.GetEdgeLayout(System.Object)">
      <summary>Returns the layout information associated with the given edge object.</summary>
      <remarks>Returns the layout information associated with the given edge object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.GetNodeLabelLayout(System.Object)">
      <summary>Returns the node label layouts associated with the given node.</summary>
      <remarks>Returns the node label layouts associated with the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.GetNodeLayout(System.Object)">
      <summary>Returns the layout information associated with the given node object.</summary>
      <remarks>Returns the layout information associated with the given node object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.SetEdgeLabelLayout(System.Object,yWorks.yFiles.Layout.IEdgeLabelLayout[])">
      <summary>Sets the edge label layouts associated with the given edge.</summary>
      <remarks>Sets the edge label layouts associated with the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.SetEdgeLayout(System.Object,yWorks.yFiles.Layout.IEdgeLayout)">
      <summary>Sets the layout information associated with the given edge object.</summary>
      <remarks>Sets the layout information associated with the given edge object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.SetNodeLabelLayout(System.Object,yWorks.yFiles.Layout.INodeLabelLayout[])">
      <summary>Sets the node label layouts associated with the given node.</summary>
      <remarks>Sets the node label layouts associated with the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultGraphLayout.SetNodeLayout(System.Object,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Sets the layout information associated with the given node object.</summary>
      <remarks>Sets the layout information associated with the given node object.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.DefaultLayoutGraph">
      <summary>This class is a default implementation of the abstract class LayoutGraph.</summary>
      <remarks>This class is a default implementation of the abstract class LayoutGraph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.#ctor">
      <summary>Creates a new Layout Graph</summary>
      <remarks>Creates a new Layout Graph</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.#ctor(yWorks.yFiles.Layout.DefaultLayoutGraph,yWorks.yFiles.Algorithms.ICursor)">
      <summary>Creates a copy of the given subgraph.</summary>
      <remarks>Creates a copy of the given subgraph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.#ctor(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Creates a copy of the given subgraph.</summary>
      <remarks>Creates a copy of the given subgraph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.#ctor(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.ICursor)">
      <summary>Creates a copy of the given subgraph.</summary>
      <remarks>Creates a copy of the given subgraph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.CreateEdgeLayout">
      <summary>Override this to create your own EdgeLayouts.</summary>
      <remarks>Override this to create your own EdgeLayouts.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.CreateGraphCopyFactory">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory" />
            .
            </summary>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.CreateNodeLayout">
      <summary>Override this to create your own NodeLayouts.</summary>
      <remarks>Override this to create your own NodeLayouts.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.DefaultLayoutGraph.edgeLabelFeatureMap">
      <summary>Map used to associate the owner of an edge label with the edge label itself.</summary>
      <remarks>Map used to associate the owner of an edge label with the edge label itself.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.DefaultLayoutGraph.edgeLabelMap">
      <summary>EdgeMap used to associate edge label layouts with the edges of this graph.</summary>
      <remarks>EdgeMap used to associate edge label layouts with the edges of this graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetFeature(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns the edge which is described by a given label layout.</summary>
      <remarks>Returns the edge which is described by a given label layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetFeature(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns the node which is described by a given label layout.</summary>
      <remarks>Returns the node which is described by a given label layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </summary>
      <param name="edge">an edge in the drawing.</param>
      <returns>the edge label layout information for the given edge.</returns>
      <remarks>
            Returns EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns NodeLabelLayout objects that describe the layouts
            of the labels belonging to the given node.
            </summary>
      <param name="node">a node in the drawing.</param>
      <returns>the node label layout information for the given node.</returns>
      <remarks>
            Returns NodeLabelLayout objects that describe the layouts
            of the labels belonging to the given node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the layout information for an edge in the drawing.</summary>
      <param name="e">a edge in the drawing.</param>
      <returns>the layout information for the given edge.</returns>
      <remarks>Returns the layout information for an edge in the drawing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the layout information for a node in the drawing.</summary>
      <param name="v">a node in the drawing.</param>
      <returns>the layout information for <c>node</c>.</returns>
      <remarks>Returns the layout information for a node in the drawing.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.DefaultLayoutGraph.nodeLabelFeatureMap">
      <summary>Map used to associate the owner of a node label with the node label itself.</summary>
      <remarks>Map used to associate the owner of a node label with the node label itself.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.DefaultLayoutGraph.nodeLabelMap">
      <summary>NodeMap used to associate node label layouts with the nodes of this graph.</summary>
      <remarks>NodeMap used to associate node label layouts with the nodes of this graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.IEdgeLabelLayout[])">
      <summary>
            Sets the EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </summary>
      <param name="edge">an edge in the drawing.</param>
      <param name="layout">an array of edge label layout objects</param>
      <remarks>
            Sets the EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>
            Sets the NodeLabelLayout object which describes the layout
            of the label that belongs to the given node.
            </summary>
      <param name="node">a node in the drawing.</param>
      <param name="layout">a layout object for the node label</param>
      <remarks>
            Sets the NodeLabelLayout object which describes the layout
            of the label that belongs to the given node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.INodeLabelLayout[])">
      <summary>
            Sets the NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </summary>
      <param name="node">a node in the drawing.</param>
      <param name="llayout">an array of node label layout objects</param>
      <remarks>
            Sets the NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.SetLayout(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.IEdgeLayout)">
      <summary>Sets the layout information for an edge in the drawing.</summary>
      <remarks>Sets the layout information for an edge in the drawing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultLayoutGraph.SetLayout(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Sets the layout information for a node in the drawing.</summary>
      <remarks>Sets the layout information for a node in the drawing.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.DefaultNodeLabelLayout">
      <summary>This class is the default implementation for the NodeLabelLayout.</summary>
      <remarks>This class is the default implementation for the NodeLabelLayout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLabelLayout.#ctor(yWorks.yFiles.Layout.INodeLabelModel,System.Object,yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.DefaultNodeLabelLayout" /></summary>
      <param name="model">the NodeLabel model for this label layout</param>
      <param name="param">the NodeLabelModel parameter that describes the position of the label layout.</param>
      <param name="orientedBox">the bounds of this label layout</param>
      <remarks>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.DefaultNodeLabelLayout" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLabelLayout.#ctor(yWorks.yFiles.Layout.INodeLabelModel,System.Object,yWorks.yFiles.Algorithms.Geometry.YRectangle,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.DefaultNodeLabelLayout" /></summary>
      <param name="model">the NodeLabel model for this label layout</param>
      <param name="param">
            the NodeLabelModel parameter that describes the position
            of the label layout.
            </param>
      <param name="box">the bounds of this label layout</param>
      <remarks>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.DefaultNodeLabelLayout" />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLabelLayout.Box" />
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLabelLayout.LabelModel">
      <summary>The node label model associated with this label layout</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLabelLayout.ModelParameter">
      <summary>The NodeLabelModel parameter that describes the position of the label layout</summary>
      <remarks>Specifies the NodeLabelModel parameter that describes the position of the label layout</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLabelLayout.Node">
      <summary>The node associated with this layout.</summary>
      <remarks>Returns the node associated with this layout.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLabelLayout.OrientedBox" />
    <member name="T:yWorks.yFiles.Layout.DefaultNodeLayout">
      <summary>This class is a default implementation of the NodeLayout interface.</summary>
      <remarks>This class is a default implementation of the NodeLayout interface.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.#ctor">
      <summary>Creates a new instance of DefaultNodeLayout.</summary>
      <remarks>Creates a new instance of DefaultNodeLayout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>Creates a new instance of DefaultNodeLayout.</summary>
      <param name="x">the x-coordinate of the upper left corner of the node.</param>
      <param name="y">the y-coordinate of the upper left corner of the node.</param>
      <param name="width">the width of the node.</param>
      <param name="height">the height of the node.</param>
      <remarks>Creates a new instance of DefaultNodeLayout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension)">
      <summary>Creates a new instance of DefaultNodeLayout.</summary>
      <param name="location">the upper-left corner coordinate of the node layout.</param>
      <param name="size">the size of the node layout.</param>
      <remarks>Creates a new instance of DefaultNodeLayout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.#ctor(yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a new instance of DefaultNodeLayout as copy of another instance
            of NodeLayout.
            </summary>
      <param name="layout">another instance of NodeLayout.</param>
      <remarks>
            Creates a new instance of DefaultNodeLayout as copy of another instance
            of NodeLayout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLayout.Height">
      <summary>The height of the node.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.SetCenter(System.Double,System.Double)">
      <summary>Sets the center coordinates of the node.</summary>
      <param name="x">the x-coordinates of the center.</param>
      <param name="y">the y-coordinates of the center</param>
      <remarks>Sets the center coordinates of the node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.SetLocation(System.Double,System.Double)">
      <summary>Sets the coordinates of the upper left corner of the node.</summary>
      <param name="x">the x-coordinates of the upper left corner.</param>
      <param name="y">the y-coordinates of the upper left corner.</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.DefaultNodeLayout.SetSize(System.Double,System.Double)">
      <summary>Sets the size of the node.</summary>
      <param name="width">the width of the node.</param>
      <param name="height">the height of the node.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLayout.Width">
      <summary>The width of the node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLayout.X">
      <summary>X-Coordinate of the upper left corner of the node.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.DefaultNodeLayout.Y">
      <summary>Y-Coordinate of the upper left corner of the node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel">
      <summary>
            An edge label model that allows placement of labels
            at some positions along an edge.
            </summary>
      <remarks>
            An edge label model that allows placement of labels
            at some positions along an edge.
            <p>
            It's possible to specify a distance value that controls the
            distance between label and edge.
            Furthermore, there's the possibility to mask out
            arbitrary edge label candidates. This can either be done by
            specifying predefined candidate masks or by OR-ing allowed label
            candidates to a user defined mask.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.#ctor">
      <summary>Returns a new instance of DiscreteEdgeLabelModel.</summary>
      <remarks>
            Returns a new instance of DiscreteEdgeLabelModel.
            Position mask
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.SixPos" />
            is used to define the allowed positions for
            an edge label.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.DiscreteEdgeLabelPosition)">
      <summary>Returns a new instance of DiscreteEdgeLabelModel.</summary>
      <param name="candidateMask">
            
            Position mask that defines the allowed positions for an edge label.
            </param>
      <remarks>Returns a new instance of DiscreteEdgeLabelModel.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.CandidateMask">
      <summary>The bit mask specifying the valid positions for edge labels.</summary>
      <remarks>
            Returns the bit mask specifying the valid positions for edge labels.
            <p>
            Defaults to
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.SixPos" />
            .
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given edge label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)" />
            
            method.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.CreatePositionParameter(System.Int32)">
      <summary>Returns a model parameter that encodes the specified position.</summary>
      <param name="position">
            one of
            <ul><li><see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Shead" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Head" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Thead" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Stail" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tail" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Ttail" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Scenter" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Center" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tcenter" /></li></ul></param>
      <returns>a model parameter that encodes the specified position.</returns>
      <exception cref="T:System.ArgumentException">
            if the specified position is not one
            of the symbolic position constants defined in this class.
            </exception>
      <remarks>Returns a model parameter that encodes the specified position.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed edge label positions.
            </summary>
      <remarks>
            Returns a model parameter that encodes the default position of this model's
            allowed edge label positions.
            <p />
            Default positions are (in descending order):
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Center" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Scenter" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tail" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Stail" />
            </li>
            </ul>
            Descending order means that whenever two or more of the above default positions
            are part of the allowed positions, then the model parameter encodes the one
            that is listed first.
            <p />
            Note that the model parameter encodes
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Center" />
            when none of the above
            default positions is part of the allowed positions.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.Distance">
      <summary>The distance between the label's bounding box and the edge's path.</summary>
      <remarks>Sets the distance between the label's bounding box and the edge's path.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns a list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate" />
            objects each of which describes
            a valid label position within this model.
            </summary>
      <param name="labelLayout">
            
            The label for which candidates should be generated.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate" />
            objects.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the bounds of the label for the position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <param name="param">
            
            The model parameter that describes the abstract position of the label within
            this model.
            The parameter must have been generated by this model.
            </param>
      <returns>
            
            The bounds of the label.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.DiscreteEdgeLabelPosition)">
      <summary>Returns the coordinates of the upper-left corner of the given label position.</summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceNode">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetNode">
            
            The layout of the target node of the label owning edge.
            </param>
      <param name="pos">
            
            A label position (given by a symbolic position specifier) that is valid in
            this model.
            </param>
      <returns>
            
            The coordinates of the upper-left corner of a label position.
            </returns>
      <remarks>Returns the coordinates of the upper-left corner of the given label position.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteEdgeLabelLayoutModel.IsParameterValid(System.Object)">
      <summary>
            Checks if the given model parameter encodes an edge label position that is
            valid in this model.
            </summary>
      <returns>
            
            Whether the label position encoded by the given model parameter is among the
            allowed positions.
            </returns>
      <remarks>
            Checks if the given model parameter encodes an edge label position that is
            valid in this model.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition" />
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Shead">
      <summary>
            Symbolic position specifier.
            Places the label near the source node.
            The label's position is to the left of or above the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Head">
      <summary>
            Symbolic position specifier.
            Places the label near the middle of the edge's path.
            The label's position is to the left of or above the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Thead">
      <summary>
            Symbolic position specifier.
            Places the label near the target node.
            The label's position is to the left of or above the edge's path.
            Places the label near the target node on the "head" side of the edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Stail">
      <summary>
            Symbolic position specifier.
            Places the label near the source node.
            The label's position is to the right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tail">
      <summary>
            Symbolic position specifier.
            Places the label near the middle of the edge's path.
            The label's position is to the right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Ttail">
      <summary>
            Symbolic position specifier.
            Places the label near the target node.
            The label's position is to the right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Scenter">
      <summary>
            Symbolic position specifier.
            Places the label near the source node directly on the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Center">
      <summary>
            Symbolic position specifier.
            Places the label near the middle of an edge directly on its path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tcenter">
      <summary>
            Symbolic position specifier.
            Places the label near the target node directly on the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.TwoPos">
      <summary>
            Position mask that constrains allowed positions to the two near the edge's
            end points.
            Namely, these are
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Head" />
            and
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tail" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Centered">
      <summary>
            Position mask that constrains allowed positions to
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Center" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.SixPos">
      <summary>
            Position mask that constrains allowed positions to a set of six positions on
            the "head" and "tail" sides of an edge.
            Namely, these are
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Shead" />
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Head" />
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Thead" />
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Stail" />
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tail" />
            , and
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Ttail" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.ThreeCenter">
      <summary>
            Position mask that constrains allowed positions to a set of three positions
            directly on the edge's path.
            Namely, these are
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Scenter" />
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Center" />
            , and
            <see cref="F:yWorks.yFiles.Layout.DiscreteEdgeLabelPosition.Tcenter" />
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel">
      <summary>
            A node label model that allows placement of labels at eight positions around
            a node and at nine positions inside the node.
            </summary>
      <remarks>
            A node label model that allows placement of labels at eight positions around
            a node and at nine positions inside the node.
            <p />
            It's possible to specify an insets value that controls the distance between label
            and node.
            <br />
            Furthermore, there's the possibility to mask out arbitrary node label candidates.
            This can either be done by specifying predefined candidate masks or by OR-ing
            allowed node label candidates to a user defined mask.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.#ctor">
      <summary>Returns a new instance of DiscreteNodeLabelModel.</summary>
      <remarks>
            Returns a new instance of DiscreteNodeLabelModel.
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.InternalMask" />
            is used to define the allowed positions for the node
            label.
            The distance between label and node is set to 4.0 [pixel].
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.DiscreteNodeLabelPosition)">
      <summary>Returns a new instance of DiscreteNodeLabelModel.</summary>
      <param name="candidateMask">
            
            Defines the allowed positions for the node label.
            </param>
      <remarks>
            Returns a new instance of DiscreteNodeLabelModel.
            The given position mask is used to define the allowed positions for the node
            label.
            The distance between label and node is set to 4.0 [pixel].
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.DiscreteNodeLabelPosition,System.Double)">
      <summary>Returns a new instance of DiscreteNodeLabelModel.</summary>
      <param name="candidateMask">
            
            Defines the allowed positions for the node label.
            </param>
      <param name="inset">
            
            The distance between label and node.
            </param>
      <remarks>Returns a new instance of DiscreteNodeLabelModel.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.CandidateMask">
      <summary>Allowed candidate positions, default is all positions.</summary>
      <remarks>Allowed candidate positions, default is all positions.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given node label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)" />
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed node label positions.
            </summary>
      <remarks>
            Returns a model parameter that encodes the default position of this model's
            allowed node label positions.
            <p />
            Default positions are (in descending order):
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Center" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.NorthEast" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.North" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.East" />
            </li>
            </ul>
            Descending order means that whenever two or more of the above default positions
            are part of the allowed positions, then the model parameter encodes the one
            that is listed first.
            <p />
            Note that the model parameter encodes
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Center" />
            when none of the above
            default positions is part of the allowed positions.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.Distance">
      <summary>The distance between the bounding boxes of label and node.</summary>
      <remarks>
            Getter:<br />
            Returns the distance between the bounding boxes of label and node.
            <para />
            Setter:<br />
            Sets the distance between the bounding boxes of label and node in the manner
            of an insets.
            It is applied to all label positions, except the
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Center" />
            position.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.INodeLabelLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Returns a list of candidate positions for the given node label.</summary>
      <remarks>Returns a list of candidate positions for the given node label.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the the oriented label position and bounds encoded by the given
            model parameter.
            </summary>
      <param name="labelSize">The size of the label.</param>
      <param name="nodeLayout">The geometric description of the label's node.</param>
      <param name="param">
            A model parameter that encodes a label position that is valid
            in this model.
            </param>
      <remarks>
            Returns the the oriented label position and bounds encoded by the given
            model parameter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.DiscreteNodeLabelPosition)">
      <summary>
            Returns the oriented label position and bounds for a node label of the
            specified size.
            </summary>
      <param name="labelSize">The size of the label.</param>
      <param name="nodeLayout">The geometric description of the label's node.</param>
      <param name="pos">A label position that is valid in this model.</param>
      <returns>the oriented label position and bounds.</returns>
      <remarks>
            Returns the oriented label position and bounds for a node label of the
            specified size.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.DiscreteNodeLabelLayoutModel.IsParameterValid(System.Object)">
      <summary>
            Checks if the given model parameter encodes a node label position that is valid
            in this model.
            </summary>
      <returns>
            
            Whether the label position encoded by the given model parameter is among the
            allowed positions.
            </returns>
      <remarks>
            Checks if the given model parameter encodes a node label position that is valid
            in this model.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.DiscreteNodeLabelPosition" />
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.North">
      <summary>Symbolic position specifier. Places the label north of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.NorthWest">
      <summary>Symbolic position specifier. Places the label north-west of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.NorthEast">
      <summary>Symbolic position specifier. Places the label north-east of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.East">
      <summary>Symbolic position specifier. Places the label east of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.West">
      <summary>Symbolic position specifier. Places the label west of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.South">
      <summary>Symbolic position specifier. Places the label south of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SouthWest">
      <summary>Symbolic position specifier. Places the label south-west of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SouthEast">
      <summary>Symbolic position specifier. Places the label south-east of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Center">
      <summary>Symbolic position specifier. Places the label in the center of  the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Bottom">
      <summary>Symbolic position specifier. Places the label at the bottom inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Top">
      <summary>Symbolic position specifier. Places the label at the top inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Left">
      <summary>Symbolic position specifier. Places the label at the left inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.Right">
      <summary>Symbolic position specifier. Places the label at the right inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.TopLeft">
      <summary>Symbolic position specifier. Places the label at the top-left inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.TopRight">
      <summary>Symbolic position specifier. Places the label at the top-right inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.BottomLeft">
      <summary>Symbolic position specifier. Places the label at the bottom-left inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.BottomRight">
      <summary>Symbolic position specifier. Places the label at the bottom-right inside of the node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SandwichMask">
      <summary>
            Position mask that constrains the positions to
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.North" />
            and
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.South" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.InternalMask">
      <summary>Position mask that allows only the nine node-internal positions.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SidesMask">
      <summary>
            Position mask that constrains the positions to
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.East" />
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.West" />
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.North" />
            , and
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.South" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.CornerMask">
      <summary>
            Position mask that constrains the positions to
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.NorthEast" />
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.NorthWest" />
            ,
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SouthEast" />
            , and
            <see cref="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.SouthWest" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.DiscreteNodeLabelPosition.EightPosMask">
      <summary>Position mask that allows only the eight node-external positions.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.EdgeFlow">
      <summary>
            Edge flow specifier used by method
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.DetermineEdgeFlowDirection(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.EdgeFlow.Up">
      <summary>
            Edge flow specifier used by method
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.DetermineEdgeFlowDirection(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            This value specifies that the flow direction of most edges is up.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.EdgeFlow.Down">
      <summary>
            Edge flow specifier used by method
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.DetermineEdgeFlowDirection(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            This value specifies that the flow direction of most edges is down.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.EdgeFlow.Left">
      <summary>
            Edge flow specifier used by method
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.DetermineEdgeFlowDirection(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            This value specifies that the flow direction of most edges is left.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.EdgeFlow.Right">
      <summary>
            Edge flow specifier used by method
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.DetermineEdgeFlowDirection(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            This value specifies that the flow direction of most edges is right.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.EdgeFlow.None">
      <summary>
            Edge flow specifier used by method
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.DetermineEdgeFlowDirection(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)" />
            .
            This value specifies that there is no main flow direction.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.EdgeLabelCandidate">
      <summary>A candidate position for edge labels</summary>
      <remarks>A candidate position for edge labels</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,System.Object,yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns a new instance of EdgeLabelCandidate.</summary>
      <param name="orientedBox">the box that specifies the candidate's size and position.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <remarks>Returns a new instance of EdgeLabelCandidate.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,System.Object,yWorks.yFiles.Layout.IEdgeLabelLayout,System.Boolean)">
      <summary>Returns a new instance of EdgeLabelCandidate.</summary>
      <param name="orientedBox">the box that specifies the candidate's size and position.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <param name="internal">
            flag whether the candidate is
            allowed to overlap the layout of the edge.
            </param>
      <remarks>Returns a new instance of EdgeLabelCandidate.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns a new instance of LabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <remarks>Returns a new instance of LabelCandidate.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.IEdgeLabelLayout,System.Boolean)">
      <summary>Returns a new instance of EdgeLabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <param name="internal">
            flag whether the candidate is
            allowed to overlap the layout of the edge.
            </param>
      <remarks>Returns a new instance of EdgeLabelCandidate.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.EdgeLabelLayoutImpl">
      <summary>
            This class is an default implementation of the EdgeLabelLayout
            interface.
            </summary>
      <remarks>
            This class is an default implementation of the EdgeLabelLayout
            interface.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeLabelLayoutImpl.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.EdgeLabelLayoutImpl" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.EdgeLabelLayoutImpl.EdgeLabelModel">
      <summary>The edge label model associated with this label layout</summary>
      <remarks>Sets the edge label model associated with this label layout</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.EdgeLabelLayoutImpl.LabelModel">
      <summary>The edge label model associated with this label layout</summary>
      <remarks>Returns the edge label model associated with this label layout</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.EdgeLabelLayoutImpl.PreferredPlacement">
      <summary>The preferred placement of this label</summary>
      <remarks>Sets the preferred placement of this label</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel">
      <summary>
            A node label model that sets
            the labels at the opposite side of the outgoing edges of a node.
            </summary>
      <remarks>
            A node label model that sets
            the labels at the opposite side of the outgoing edges of a node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given node label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)" />
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.DefaultParameter">
      <summary>The default position, this is offset (0,0)</summary>
      <remarks>Returns the default position, this is offset (0,0)</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.INodeLabelLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Returns a list of candidate positions for the label.</summary>
      <remarks>
            Returns a list of candidate positions for the label.
            The list consists of exactly one position.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeOppositeNodeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>Returns the oriented position and bounds for a label of the specified size.</summary>
      <param name="labelSize">the size of the label.</param>
      <param name="nodeLayout">the geometric description of the labeled node.</param>
      <param name="param">not used by this model</param>
      <remarks>Returns the oriented position and bounds for a label of the specified size.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.EdgeReversalStage">
      <summary>
            A layout stage that can be used to (selectively) reverse edges in a
            graph while keeping the layout and label positions of the reversed edges
            as close to the pre-reversal layout and positions as possible.
            </summary>
      <remarks>
            A layout stage that can be used to (selectively) reverse edges in a
            graph while keeping the layout and label positions of the reversed edges
            as close to the pre-reversal layout and positions as possible.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.EdgeReversalStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.EdgeReversalStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.FindReversedTreeEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>
            Marks edges in a tree-structured graph component that need to be reversed
            to make the specified node the root of the tree component.
            </summary>
      <param name="graph">the graph to which the specified node belongs.</param>
      <param name="root">the node to be considered the root of its tree component.</param>
      <param name="reversedEdges">
            a data acceptor that is used to mark edges for
            reversal.
            </param>
      <exception cref="T:System.ArgumentException">
            if the specified node does not belong to
            the specified graph.
            </exception>
      <remarks>
            Marks edges in a tree-structured graph component that need to be reversed
            to make the specified node the root of the tree component.
            Only edges in the graph component to which the specified node belongs will
            be marked.
            Edges are marked with a <c>boolean</c> <see langword="true" /> flag.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.ReverseEdge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Reverse the specified edge in the specified graph.</summary>
      <param name="graph">the graph to which the specified edge belongs.</param>
      <param name="edge">the edge to be reversed.</param>
      <remarks>
            Reverse the specified edge in the specified graph.
            The layout of the specified edge is reversed as specified in
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ReverseEdgeLayout(yWorks.yFiles.Layout.IEdgeLayout)" />
            .
            Moreover, the positions of all labels associated to the specified edge
            are adjusted to match the pre-reversal position as closely as possible.
            (Depending on a label's model it might not always be possible to achieve
            an exact match.)
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.EdgeReversalStage.ReverseEdges(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Reverses <em>selected</em> edges in the specified graph.</summary>
      <param name="graph">the graph in which to reverse edges.</param>
      <remarks>
            Reverses <em>selected</em> edges in the specified graph.
            An edge is considered <em>selected</em> in this context according to the
            criteria described for
            <see cref="F:yWorks.yFiles.Layout.EdgeReversalStage.ReverseEdgesDpKey" />
            .
            <p>
            Implementation detail: This method calls
            <see cref="M:yWorks.yFiles.Layout.EdgeReversalStage.ReverseEdge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)" />
            in order to reverse a
            <em>selected</em> edge.
            </p>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.EdgeReversalStage.ReverseEdgesDpKey">
      <summary>This key can be used to <em>select</em> specific edges for reversal.</summary>
      <remarks>
            This key can be used to <em>select</em> specific edges for reversal.
            An edge is considered <em>selected</em> in this context, if the
            corresponding <c>DataProvider</c> returns <see langword="true" /> for
            said edge.
            <p>
            <b>Note:</b>
            If there is no <c>DataProvider</c> for this key, all edges are
            considered <em>selected</em>.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.FixNodeLayoutStage">
      <summary>
            Layout stage that can be used to fix the position of either a <em>single</em>
            node or the alignment of the bounding box of several nodes (but not the
            positions of the individual nodes).
            </summary>
      <remarks>
            Layout stage that can be used to fix the position of either a <em>single</em>
            node or the alignment of the bounding box of several nodes (but not the
            positions of the individual nodes).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FixNodeLayoutStage.#ctor">
      <summary>Initializes a new <c>FixNodeLayoutStage</c>.</summary>
      <remarks>Initializes a new <c>FixNodeLayoutStage</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FixNodeLayoutStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new <c>FixNodeLayoutStage</c>.</summary>
      <param name="core">the core layout algorithm for this stage.</param>
      <remarks>Initializes a new <c>FixNodeLayoutStage</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FixNodeLayoutStage.CalculateBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList)">
      <summary>Calculates the bounding box of the specified nodes.</summary>
      <param name="graph">the graph associated to the specified nodes.</param>
      <param name="fixed">the list of nodes that determine the bounding box.</param>
      <returns>the bounding box of the specified nodes.</returns>
      <remarks>
            Calculates the bounding box of the specified nodes.
            The return values of methods
            <see cref="P:yWorks.yFiles.Layout.FixNodeLayoutStage.IncludingEdges" />
            and
            <see cref="P:yWorks.yFiles.Layout.FixNodeLayoutStage.IncludingLabels" />
            determine whether or not edges and labels
            are taken into account when calculating the box.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList)">
      <summary>Calculates the fix point for the specified nodes in the specified graph.</summary>
      <param name="graph">the graph associated to the specified nodes.</param>
      <param name="fixed">the list of nodes for which a fix point has to be determined.</param>
      <returns>the fix point for the specified nodes in the specified graph.</returns>
      <remarks>
            Calculates the fix point for the specified nodes in the specified graph.
            The default implementation calls
            <see cref="M:yWorks.yFiles.Layout.FixNodeLayoutStage.CalculateBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList)" />
            and
            <see cref="M:yWorks.yFiles.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.yFiles.Util.Geom.Rectangle2D)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>
            Calculates the fix point of the specified rectangle according to the policy
            returned by
            <see cref="P:yWorks.yFiles.Layout.FixNodeLayoutStage.FixPointPolicy" />
            .
            </summary>
      <param name="bounds">the rectangle for which to determine the fix point.</param>
      <returns>
            the fix point of the specified rectangle or <see langword="null" /> if
            nothing should be fixed.
            </returns>
      <remarks>
            Calculates the fix point of the specified rectangle according to the policy
            returned by
            <see cref="P:yWorks.yFiles.Layout.FixNodeLayoutStage.FixPointPolicy" />
            .
            If the specified rectangle is <see langword="null" /> or the rectangle has
            negative <c>width</c> or negative <c>height</c>,
            <see langword="null" /> will be returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FixNodeLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.FixNodeLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="F:yWorks.yFiles.Layout.FixNodeLayoutStage.FixedNodeDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key to specify a <c>DataProvider</c>
            whose
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)" />
            method is used to
            determine which nodes should be considered fixed.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key to specify a <c>DataProvider</c>
            whose
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)" />
            method is used to
            determine which nodes should be considered fixed.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.FixNodeLayoutStage.FixPointPolicy">
      <summary>
            The fix point calculation policy used in
            <see cref="M:yWorks.yFiles.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.yFiles.Util.Geom.Rectangle2D)" />
            to determine which
            point in the corresponding rectangle should be considered fixed.
            </summary>
      <remarks>
            Specifies the fix point calculation policy used in
            <see cref="M:yWorks.yFiles.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.yFiles.Util.Geom.Rectangle2D)" />
            to determine which
            point in the corresponding rectangle should be considered fixed.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.FixPointPolicy.Center" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.FixNodeLayoutStage.IncludingEdges">
      <summary>
            Determines whether or not subgraph edges should be taken into account
            when calculating the bounding box of the fixed nodes.
            </summary>
      <remarks>
            Determines whether or not subgraph edges should be taken into account
            when calculating the bounding box of the fixed nodes.
            <p>
            By default, this property is set to <see langword="false" />, i.e. subgraph
            edges are not taken into account.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.FixNodeLayoutStage.IncludingLabels">
      <summary>
            Determines whether or not label geometries should be taken into account
            when calculating the bounding box of the fixed nodes.
            </summary>
      <remarks>
            Determines whether or not label geometries should be taken into account
            when calculating the bounding box of the fixed nodes.
            <p>
            By default, this property is set to <see langword="false" />, i.e. label
            geometries are not taken into account.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.FixPointPolicy">
      <summary>
            Fix point calculation policy that results in the center of a given
            rectangle to be considered the fix point.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.FixPointPolicy.Center">
      <summary>
            Fix point calculation policy that results in the center of a given
            rectangle to be considered the fix point.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.FixPointPolicy.UpperLeft">
      <summary>
            Fix point calculation policy that results in the upper left corner of a
            given rectangle to be considered the fix point.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel">
      <summary>
            An edge label model that allows placement of labels
            at a fixed offset from the source intersection point of the node.
            </summary>
      <remarks>
            An edge label model that allows placement of labels
            at a fixed offset from the source intersection point of the node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.#ctor">
      <summary>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel" />
            .
            </summary>
      <remarks>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns a model parameter that represents the given edge label
            context.
            </summary>
      <remarks>
            Returns a model parameter that represents the given edge label
            context. The created model parameter reproduces the location
            of the given label bounds.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.DefaultParameter">
      <summary>The default parameter.</summary>
      <remarks>Returns the default parameter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns exactly one label candidate that corresponds to
            the actual label layout of the given label.
            </summary>
      <remarks>
            Returns exactly one label candidate that corresponds to
            the actual label layout of the given label.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the positions of the upper left corner of the label
            with given parameter.
            </summary>
      <remarks>
            Returns the positions of the upper left corner of the label
            with given parameter.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter">
      <summary>The model parameters for the <c>FreeEdgeLabelModel</c>.</summary>
      <remarks>The model parameters for the <c>FreeEdgeLabelModel</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.#ctor">
      <summary>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter" />
            with radius <c>50</c>
            and angle <c>0</c>.
            </summary>
      <remarks>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter" />
            with radius <c>50</c>
            and angle <c>0</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.#ctor(System.Double,System.Double)">
      <summary>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter" />
            with given radius and angle.
            </summary>
      <param name="radius">the distance of the label from the source node of the underlying edge</param>
      <param name="theta">
            the angle between the first segment of the underlying edge and the imaginary line to the center of
            the label. the angle is measured in radian.
            </param>
      <remarks>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter" />
            with given radius and angle.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter" />
            with given radius and angle.
            </summary>
      <param name="radius">the distance of the label from the source node of the underlying edge</param>
      <param name="theta">
            the angle between the first segment of the underlying edge and the
            imaginary line to the center of the label. the angle is measured in radian.
            </param>
      <param name="angle">the rotation angle of the label.</param>
      <remarks>
            Creates a new instance of
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter" />
            with given radius and angle.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.Angle">
      <summary>The rotation angle of the label defined by this label position.</summary>
      <remarks>Specifies the rotation angle of the label defined by this label position.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.Point">
      <summary>
            A point whose x-coordinate corresponds to the radius associated with this
            class and whose y-coordinate corresponds to the angle associated with this class.
            </summary>
      <remarks>
            Returns a point whose x-coordinate corresponds to the radius associated with this
            class and whose y-coordinate corresponds to the angle associated with this class.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.SetPoint(System.Double,System.Double)">
      <summary>Sets angle and radius for this class.</summary>
      <remarks>
            Sets angle and radius for this class. The x-coordinate of the given point
            holds the radius, the y-coordinate the angle.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel.ModelParameter.ToString">
      <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
      <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel">
      <summary>
            A node label model that allows placement of labels at a fixed offset relative
            to the node's upper-left corner.
            </summary>
      <remarks>
            A node label model that allows placement of labels at a fixed offset relative
            to the node's upper-left corner.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.#ctor">
      <summary>Returns a new instance of FreeNodeLabelModel.</summary>
      <remarks>Returns a new instance of FreeNodeLabelModel.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given node label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)" />
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed node label positions.
            </summary>
      <remarks>
            Returns a model parameter that encodes the default position of this model's
            allowed node label positions.
            <p>
            The offset is set to a default value of -20 pixel for both directions, i.e.,
            the node label's upper-left corner is placed 20 pixel to the left and 20
            pixel above the node.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.INodeLabelLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Returns a list of candidate positions for the given node label.</summary>
      <remarks>
            Returns a list of candidate positions for the given node label.
            The list consists of exactly one position.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the oriented label position and bounds encoded by the given model
            parameter.
            </summary>
      <param name="labelSize">The size of the label that should be placed.</param>
      <param name="nodeLayout">The layout of the node to which the label belongs.</param>
      <param name="param">
            The model parameter that describes the abstract position of
            the label within this model. The parameter must have been generated by
            this model.
            </param>
      <returns>the oriented label position and bounds.</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.ModelParameter">
      <summary>The model parameter that encodes a node label position within FreeNodeLabelModel.</summary>
      <remarks>
            The model parameter that encodes a node label position within FreeNodeLabelModel.
            <p />
            Holds the offset of a node label's upper-left corner relative to its node's
            upper-left corner.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.ModelParameter.#ctor">
      <summary>Returns a new instance of ModelParameter.</summary>
      <remarks>
            Returns a new instance of ModelParameter.
            It has no offset, i.e., the upper-left corners of both node label and node
            are at the same location.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.ModelParameter.#ctor(System.Double,System.Double)">
      <summary>Returns a new instance of ModelParameter with the given offset.</summary>
      <remarks>Returns a new instance of ModelParameter with the given offset.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.ModelParameter.Point">
      <summary>The offset of this ModelParameter.</summary>
      <remarks>Returns the offset of this ModelParameter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel.ModelParameter.SetPoint(System.Double,System.Double)">
      <summary>Sets the node label's offset.</summary>
      <remarks>Sets the node label's offset.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.GraphLayoutLineWrapper">
      <summary>A layout stage that can be used to "line-wrap" or "column-wrap" a graph layout.</summary>
      <remarks>
            A layout stage that can be used to "line-wrap" or "column-wrap" a graph layout.
            This stage both supports wrapping a layout at a given width (height) or wrapping
            the layout at a specific width (height) automatically so that the overall resulting
            aspect ratio will be close to a specifiable value.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.GraphLayoutLineWrapper.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.GraphLayoutLineWrapper" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.GraphLayoutLineWrapper.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.ColumnMode">
      <summary>Determines whether this algorithm should not wrap lines or rows, but columns.</summary>
      <remarks>
            Determines whether this algorithm should not wrap lines or rows, but columns.
            If set to <see langword="true" />, the layout will be wrapped vertically and new columns will
            be appended to the right of the first column.
            The
            <see cref="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidth" />
            property will be interpreted as a fixed height, in that case, of course.
            The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.GraphLayoutLineWrapper.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.EdgeSpacing">
      <summary>The space between edges that should be used for the additional routing.</summary>
      <remarks>
            Specifies the space between edges that should be used for the additional routing.
            The default is <c>5</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidth">
      <summary>
            The desired width of the lines to use if
            <see cref="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidthLineBreaks" />
            is set to
            <see langword="true" />.
            </summary>
      <remarks>
            Specifies the desired width of the lines to use if
            <see cref="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidthLineBreaks" />
            is set to
            <see langword="true" />.
            Note that the algorithm will not necessarily be able to satisfy very small values since the nodes need to
            fit into a line completely.
            <p>
            The default is <c>500</c>
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidthLineBreaks">
      <summary>
            Specifies whether the algorithm should use the
            <see cref="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidth">fixed width</see>
            to determine line breaks.
            </summary>
      <remarks>
            Specifies whether the algorithm should use the
            <see cref="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidth">fixed width</see>
            to determine line breaks.
            The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.Mirror">
      <summary>
            Specifies whether lines should be going from left to right and right to left
            in an alternating fashion.
            </summary>
      <remarks>
            Specifies whether lines should be going from left to right and right to left
            in an alternating fashion.
            If set to <see langword="true" /> every second line will be rotated 180 degrees and
            ports will be adjusted correspondingly.
            The default is <see langword="true" />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.Spacing">
      <summary>The space between adjacent lines of the wrapped graph layout.</summary>
      <remarks>
            Specifies the space between adjacent lines of the wrapped graph layout.
            The default is <c>10</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.TargetRatio">
      <summary>The desired target aspect ratio the algorithm should try to generate.</summary>
      <remarks>
            Specifies the desired target aspect ratio the algorithm should try to generate.
            This setting only affects the outcome if
            <see cref="P:yWorks.yFiles.Layout.GraphLayoutLineWrapper.FixedWidthLineBreaks" />
            is set to <see langword="false" />.
            The default is <c>1.0d</c>.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.IEdgeLabelLayout">
      <summary>
            This interface defines the properties of one edge label
            from the perspective of a labeling algorithm.
            </summary>
      <remarks>
            This interface defines the properties of one edge label
            from the perspective of a labeling algorithm.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.IEdgeLabelLayout.LabelModel">
      <summary>The edge label model associated with this label layout</summary>
      <remarks>Returns the edge label model associated with this label layout</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.IEdgeLabelLayout.PreferredPlacement">
      <summary>The preferred placement of this label.</summary>
      <remarks>
            Returns the preferred placement of this label. This feature
            is being interpreted by label aware layout algorithms.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.IEdgeLabelModel">
      <summary>
            This interface defines the properties of the model associated with an edge label
            layout.
            </summary>
      <remarks>
            This interface defines the properties of the model associated with an edge label
            layout.
            <p>
            An edge label model provides a set of possible candidates for the placement of
            an edge label.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLabelModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given edge label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)" />
            
            method.
            </returns>
      <remarks>
            Creates a model parameter that represents the given edge label context best
            within this model.
            The created model parameter represents the closest parameter representation
            of the given label location that can be achieved within this model.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.IEdgeLabelModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed edge label positions.
            </summary>
      <remarks>
            Returns a model parameter that encodes the default position of this model's
            allowed edge label positions.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelCandidates(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns a list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate" />
            objects each of which describes
            a valid label position within this model.
            </summary>
      <param name="labelLayout">
            
            The label for which candidates should be generated.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate" />
            objects.
            </returns>
      <remarks>
            Returns a list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate" />
            objects each of which describes
            a valid label position within this model.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the bounds of the label for the position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <param name="param">
            
            The model parameter that describes the abstract position of the label within
            this model.
            The parameter must have been generated by this model.
            </param>
      <returns>
            
            The bounds of the label.
            </returns>
      <remarks>
            Returns the bounds of the label for the position encoded
            by the given model parameter.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.IEdgeLayout">
      <summary>This interface encapsulates the layout information for an edge.</summary>
      <remarks>
            This interface encapsulates the layout information for an edge.
            The layout information consists of
            the two end points of the edge layout and a sequence of control points
            that determine the visual path of the edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLayout.AddPoint(System.Double,System.Double)">
      <summary>Adds a control point to the end of the control point sequence.</summary>
      <param name="x">the absolute x-coordinate of the control point.</param>
      <param name="y">the absolute y-coordinate of the control point.</param>
      <remarks>Adds a control point to the end of the control point sequence.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLayout.ClearPoints">
      <summary>Remove all control points from this edge layout.</summary>
      <remarks>Remove all control points from this edge layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLayout.GetPoint(System.Int32)">
      <summary>
            Returns the control point at position <c>index</c> of
            the sequence.
            </summary>
      <param name="index">position of the control point in the control point sequence.</param>
      <returns>the absolute coordinates of the control point at the given index.</returns>
      <remarks>
            Returns the control point at position <c>index</c> of
            the sequence.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLayout.PointCount">
      <summary>Returns the number of control points of the edge.</summary>
      <returns>the number of control points</returns>
      <remarks>
            Returns the number of control points of the edge.
            The source and target points are not included in the point count.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IEdgeLayout.SetPoint(System.Int32,System.Double,System.Double)">
      <summary>
            Sets the coordinates of the control point at position <c>index</c> of
            the sequence.
            </summary>
      <param name="index">position of the control point in the control point sequence.</param>
      <param name="x">absolute x-coordinate of the control point at the given index.</param>
      <param name="y">absolute y-coordinate of the control point at the given index.</param>
      <remarks>
            Sets the coordinates of the control point at position <c>index</c> of
            the sequence.
            The first control point in the sequence has index 0
            and the last control point has index pointCount() - 1.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.IEdgeLayout.SourcePoint">
      <summary>
            The relative coordinates of the first end point of this layout
            that is associated with the source node of the edge.
            </summary>
      <remarks>
            Getter:<br />
            Returns the relative coordinates of the first end point of this layout
            that is associated with the source node of the edge.
            The returned coordinates are relative to the center location of the source
            node of the edge. To obtain the absolute coordinates of the end point it
            is therefore necessary to add the center coordinates of the source node layout
            to the returned value.
            <para />
            Setter:<br />
            Sets the relative coordinates of the first end point of this layout
            that is associated with the source node of the edge.
            The given coordinates must be relative to the center location of the source
            node of the edge.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.IEdgeLayout.TargetPoint">
      <summary>
            The relative coordinates of the second end point of this layout
            that is associated with the target node of the edge.
            </summary>
      <remarks>
            Getter:<br />
            Returns the relative coordinates of the second end point of this layout
            that is associated with the target node of the edge.
            The returned coordinates are relative to the center location of the target
            node of the edge. To obtain the absolute coordinates of the end point it
            is therefore necessary to add the center coordinates of the target node layout
            to the returned value.
            <para />
            Setter:<br />
            Sets the relative coordinates of the second end point of this layout
            that is associated with the target node of the edge.
            The given coordinates must be relative to the center location of the target
            node of the edge.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.IGraphLayout">
      <summary>This interface defines the layout information of a  graph.</summary>
      <remarks>This interface defines the layout information of a  graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IGraphLayout.GetBoundingBox">
      <summary>Returns the bounding box of the graph layout.</summary>
      <remarks>
            Returns the bounding box of the graph layout.
            That is the smallest rectangular area that contains all
            defined layout elements. If there are no elements in this
            graph layout, the resulting rectangle will have negative
            width and height.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IGraphLayout.GetEdgeLabelLayout(System.Object)">
      <summary>
            Returns an array of layout information for all edge labels
            belonging to the given edge.
            </summary>
      <remarks>
            Returns an array of layout information for all edge labels
            belonging to the given edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IGraphLayout.GetEdgeLayout(System.Object)">
      <summary>Returns the layout information for a given edge.</summary>
      <remarks>Returns the layout information for a given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IGraphLayout.GetNodeLabelLayout(System.Object)">
      <summary>
            Returns an array of layout information for all node labels
            belonging to the given node.
            </summary>
      <remarks>
            Returns an array of layout information for all node labels
            belonging to the given node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IGraphLayout.GetNodeLayout(System.Object)">
      <summary>Returns the layout information for a given node.</summary>
      <remarks>Returns the layout information for a given node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.IIntersectionCalculator">
      <summary>
            Interface implemented by classes that are responsible for calculating the
            intersection point between an Edge and the visual representation of its
            source or target node.
            </summary>
      <remarks>
            Interface implemented by classes that are responsible for calculating the
            intersection point between an Edge and the visual representation of its
            source or target node. This interface is especially useful in conjunction with
            the
            <see cref="T:yWorks.yFiles.Layout.PortCalculator" />
            
            <see cref="T:yWorks.yFiles.Layout.ILayoutStage" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IIntersectionCalculator.CalculateIntersectionPoint(yWorks.yFiles.Layout.INodeLayout,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Calculates an intersection point given the coordinates of a point lying on
            the last/first segment of an Edge and a normalized direction.
            </summary>
      <param name="nl">
            the currently calculated
            <see cref="T:yWorks.yFiles.Layout.INodeLayout" /></param>
      <param name="xOffset">
            the relative (to the node's center)
            x-coordinate of a point on the last line segment
            </param>
      <param name="yOffset">the relative y-coordinate of a point on the last line segment</param>
      <param name="dx">
            the x component of the normalized direction vector indicating the
            direction of the segment pointing towards the node
            </param>
      <param name="dy">
            the y component of the normalized direction vector indicating the
            direction of the segment pointing towards the node
            </param>
      <returns>
            the new relative (to the node's center) intersection coordinates or
            <see langword="null" /> if no such intersection could be found
            </returns>
      <remarks>
            Calculates an intersection point given the coordinates of a point lying on
            the last/first segment of an Edge and a normalized direction.
            If no such intersection can be found this method should return <see langword="null" />.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.ILabelLayout">
      <summary>
            This interface defines the properties of one label
            from the perspective of a labeling algorithm.
            </summary>
      <remarks>
            This interface defines the properties of one label
            from the perspective of a labeling algorithm.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ILabelLayout.Box">
      <summary>The bounding box of the label</summary>
      <remarks>Returns the bounding box of the label</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ILabelLayout.ModelParameter">
      <summary>
            The label model parameter that describes
            the position of this label.
            </summary>
      <remarks>
            Specifies the label model parameter that describes
            the position of this label.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ILabelLayout.OrientedBox">
      <summary>The box of the label</summary>
      <remarks>Returns the box of the label</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.ILayouter">
      <summary>
            This is a general interface for algorithms that
            perform a layout process on a given layout graph.
            </summary>
      <remarks>
            This is a general interface for algorithms that
            perform a layout process on a given layout graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ILayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true" /> iff the given graph can be laid
            out by this algorithm.
            </summary>
      <remarks>
            Returns <see langword="true" /> iff the given graph can be laid
            out by this algorithm. Calling <c>doLayout</c> with
            the given graph as its argument will only success if
            this method returns <see langword="true" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ILayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
      <remarks>Main layout routine that assigns new layout information to the given graph.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.ILayoutStage">
      <summary>
            Interface for a layouter that forms a stage of a larger layout
            process.
            </summary>
      <remarks>
            Interface for a layouter that forms a stage of a larger layout
            process. It delegates the core layout process
            to another layouter. A layout stage may perform pre-processing steps
            before the core layouter gets called and post-processing steps after
            the layouter gets called.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ILayoutStage.CoreLayouter">
      <summary>The core layouter.</summary>
      <remarks>Specifies the core layouter.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.INodeLabelLayout">
      <summary>
            This interface defines the properties of one edge label
            from the perspective of a labeling algorithm.
            </summary>
      <remarks>
            This interface defines the properties of one edge label
            from the perspective of a labeling algorithm.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLabelLayout.LabelModel">
      <summary>The node label model associated with this label layout</summary>
      <remarks>Returns the node label model associated with this label layout</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.INodeLabelModel">
      <summary>
            This interface defines the properties of the model
            associated with a node label layout.
            </summary>
      <remarks>
            This interface defines the properties of the model
            associated with a node label layout.
            <p>
            A node label model provides a set of possible
            candidates for the placement of a node label.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.INodeLabelModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given node label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)" />
            method.
            </returns>
      <remarks>
            Creates a model parameter that represents the given node label context best
            within this model.
            The created model parameter represents the closest parameter representation
            of the given oriented label bounds that can be achieved within this model.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLabelModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed node label positions.
            </summary>
      <remarks>
            Returns a model parameter that encodes the default position of this model's
            allowed node label positions.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelCandidates(yWorks.yFiles.Layout.INodeLabelLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns a list of
            <see cref="T:yWorks.yFiles.Layout.NodeLabelCandidate" />
            objects each of which describes
            a valid label position within this model.
            </summary>
      <param name="nl">
            
            The label layout for which candidates should be generated.
            </param>
      <param name="nodeLayout">
            
            The layout of the node to which the label belongs.
            </param>
      <returns>
            
            A list of
            <see cref="T:yWorks.yFiles.Layout.NodeLabelCandidate" />
            objects.
            </returns>
      <remarks>
            Returns a list of
            <see cref="T:yWorks.yFiles.Layout.NodeLabelCandidate" />
            objects each of which describes
            a valid label position within this model.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.INodeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the oriented label position and bounds encoded by the given model
            parameter.
            </summary>
      <param name="labelSize">The size of the label that should be placed.</param>
      <param name="nodeLayout">The layout of the node to which the label belongs.</param>
      <param name="param">
            The model parameter that describes the abstract position of
            the label within this model. The parameter must have been generated by
            this model.
            </param>
      <returns>the oriented label position and bounds.</returns>
      <remarks>
            Returns the oriented label position and bounds encoded by the given model
            parameter.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.INodeLayout">
      <summary>
            This interface describes the layout information for a node in the drawing
            of a graph.
            </summary>
      <remarks>
            This interface describes the layout information for a node in the drawing
            of a graph.
            The layout information consists of the size and position of the node.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLayout.Height">
      <summary>The height of the node.</summary>
      <remarks>Returns the height of the node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.INodeLayout.SetLocation(System.Double,System.Double)">
      <summary>Sets the coordinates of the upper left corner of the node.</summary>
      <param name="x">the x-coordinates of the upper left corner.</param>
      <param name="y">the y-coordinates of the upper left corner.</param>
      <remarks>Sets the coordinates of the upper left corner of the node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.INodeLayout.SetSize(System.Double,System.Double)">
      <summary>Sets the size of the node.</summary>
      <param name="width">the width of the node.</param>
      <param name="height">the height of the node.</param>
      <remarks>Sets the size of the node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLayout.Width">
      <summary>The width of the node.</summary>
      <remarks>Returns the width of the node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLayout.X">
      <summary>X-Coordinate of the upper left corner of the node.</summary>
      <remarks>Returns X-Coordinate of the upper left corner of the node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.INodeLayout.Y">
      <summary>Y-Coordinate of the upper left corner of the node.</summary>
      <remarks>Returns Y-Coordinate of the upper left corner of the node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.IntersectionCalculatorKeys" />
    <member name="F:yWorks.yFiles.Layout.IntersectionCalculatorKeys.SourceIntersectionCalculatorDpKey">
      <summary>
            Key to be used when registering a DataProvider to a graph instance that provides
            for each Edge object in a graph an <c>IntersectionCalculator</c> instance
            that is configured to calculate the intersection of the edge and the source
            node.
            </summary>
      <remarks>
            Key to be used when registering a DataProvider to a graph instance that provides
            for each Edge object in a graph an <c>IntersectionCalculator</c> instance
            that is configured to calculate the intersection of the edge and the source
            node.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.IntersectionCalculatorKeys.TargetIntersectionCalculatorDpKey">
      <summary>
            Key to be used when registering a DataProvider to a graph instance that provides
            for each Edge object in a graph an <c>IntersectionCalculator</c> instance
            that is configured to calculate the intersection of the edge and the target
            node.
            </summary>
      <remarks>
            Key to be used when registering a DataProvider to a graph instance that provides
            for each Edge object in a graph an <c>IntersectionCalculator</c> instance
            that is configured to calculate the intersection of the edge and the target
            node.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.IProfitModel">
      <summary>This is an interface for ranking LabelCandidates.</summary>
      <remarks>This is an interface for ranking LabelCandidates.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.IProfitModel.GetProfit(yWorks.yFiles.Layout.LabelCandidate)">
      <summary>Returns the profit for placing a label-candidate.</summary>
      <param name="candidate">a label candidate</param>
      <returns>a value between 0 and 1.</returns>
      <remarks>
            Returns the profit for placing a label-candidate.
            Higher profit means higher probability that the candidate is chosen
            by a labeling algorithm.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelCandidate">
      <summary>Base class for candidate positions for labels.</summary>
      <remarks>Base class for candidate positions for labels.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,System.Object,yWorks.yFiles.Layout.ILabelLayout)">
      <summary>Returns a new instance of LabelCandidate.</summary>
      <param name="labelBox">the box that specifies the candidate's size and position.</param>
      <param name="param">
            the parameters of the labeling model
            with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <remarks>Returns a new instance of LabelCandidate.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,System.Object,yWorks.yFiles.Layout.ILabelLayout,System.Boolean)">
      <summary>Returns a new instance of LabelCandidate.</summary>
      <param name="labelBox">the box that specifies the candidate's size and position.</param>
      <param name="param">
            the parameters of the labeling model
            with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <param name="internal">
            flag whether the candidate is
            allowed to overlap its own feature.
            </param>
      <remarks>Returns a new instance of LabelCandidate.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.ILabelLayout)">
      <summary>Returns a new instance of LabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <remarks>Returns a new instance of LabelCandidate.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.ILabelLayout,System.Boolean)">
      <summary>Returns a new instance of LabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <param name="internal">
            flag whether the candidate is
            allowed to overlap its own feature.
            </param>
      <remarks>Returns a new instance of LabelCandidate.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.BoundingBox">
      <summary>The bounding box of this label candidate.</summary>
      <remarks>Returns the bounding box of this label candidate.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Box">
      <summary>The real bounds of this label candidate.</summary>
      <remarks>Returns the real bounds of this label candidate.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.EdgeOverlapPenalty">
      <summary>The penalty value for a candidate position that overlaps the path of an edge.</summary>
      <remarks>Specifies the penalty value for a candidate position that overlaps the path of an edge.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Height">
      <summary>The height of the label candidate bounds.</summary>
      <remarks>Returns the height of the label candidate bounds.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Internal">
      <summary>Specifies whether this candidate is an internal node label, i.e.</summary>
      <remarks>
            Returns whether this candidate is an internal node label, i.e. an label
            which resides inside the boundaries of a node.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Location">
      <summary>The upper left corner of the label candidate bounds.</summary>
      <remarks>Returns the upper left corner of the label candidate bounds.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.ModelParameter">
      <summary>
            The model parameter that was used by the underlying model to
            generate this label candidate.
            </summary>
      <remarks>
            Returns the model parameter that was used by the underlying model to
            generate this label candidate.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.NodeOverlapPenalty">
      <summary>The penalty for a candidate position that overlaps the bounds of a node.</summary>
      <remarks>Specifies the penalty for a candidate position that overlaps the bounds of a node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.OverlapPenalty">
      <summary>The sum of node overlap penalty and edge overlap penalty.</summary>
      <remarks>Returns the sum of node overlap penalty and edge overlap penalty.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Owner">
      <summary>The LabelLayout to which this candidate box belongs.</summary>
      <remarks>Returns the LabelLayout to which this candidate box belongs.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Parameter">
      <summary>
            The model parameter that was used by the underlying model to
            generate this label candidate.
            </summary>
      <remarks>
            Returns the model parameter that was used by the underlying model to
            generate this label candidate.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelCandidate.Propagate">
      <summary>
            Sets the model parameters of the owner of this label candidate to the
            model parameters of this candidate box.
            </summary>
      <remarks>
            Sets the model parameters of the owner of this label candidate to the
            model parameters of this candidate box.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Propagated">
      <summary>If this box had been chosen by the labeling algorithm.</summary>
      <remarks>Returns if this box had been chosen by the labeling algorithm.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Size">
      <summary>The width and height of the label candidate bounds.</summary>
      <remarks>Returns the width and height of the label candidate bounds.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelCandidate.ToString">
      <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
      <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Width">
      <summary>The width of the label candidate bounds.</summary>
      <remarks>Returns the width of the label candidate bounds.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.X">
      <summary>The minimal x-coordinate of the label candidate bounds.</summary>
      <remarks>Returns the minimal x-coordinate of the label candidate bounds.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelCandidate.Y">
      <summary>The minimal y-coordinate of the label candidate bounds.</summary>
      <remarks>Returns the minimal y-coordinate of the label candidate bounds.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelLayoutData">
      <summary>This class encapsulates layout data for a label.</summary>
      <remarks>
            This class encapsulates layout data for a label. The data is used
            by clients to inform label aware layouters about labeling constraints like label size and
            preferred placement. Label aware layouters like
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter" />
            on the other hand return the calculated label positions by assigning the
            corresponding bounds to the passed in label layout data.
            <p />
            Data providers are being used to associate an array of LabelLayoutData with either
            the nodes or the edges of a layout graph. The data providers must be registered with the
            input graph by using one of the keys defined in
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutKeys" />
            .
            <p />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.#ctor(System.Double,System.Double)">
      <summary>Creates a new instance of LabelLayoutData.</summary>
      <param name="width">the width of the label</param>
      <param name="height">the height of the label</param>
      <remarks>
            Creates a new instance of LabelLayoutData.
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.Anywhere" />
            is used
            as preferred placement specifier.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.#ctor(System.Double,System.Double,yWorks.yFiles.Layout.LabelPlacements)">
      <summary>Creates a new instance of LabelLayoutData.</summary>
      <param name="width">the width of the label</param>
      <param name="height">the height of the label</param>
      <param name="preferredPlacement">a preferred placement specifier</param>
      <remarks>Creates a new instance of LabelLayoutData.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.#ctor(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle)">
      <summary>Creates a new instance of LabelLayoutData.</summary>
      <param name="bounds">
            the
            <see cref="T:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle">oriented bounds</see>
            of the label
            </param>
      <remarks>Creates a new instance of LabelLayoutData.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.#ctor(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.LabelPlacements)">
      <summary>Creates a new instance of LabelLayoutData.</summary>
      <param name="bounds">
            the
            <see cref="T:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle">oriented bounds</see>
            of the label
            </param>
      <param name="preferredPlacement">a preferred placement specifier</param>
      <remarks>Creates a new instance of LabelLayoutData.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.Bounds">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle">oriented bounds</see>
            of the label.
            </summary>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle">oriented bounds</see>
            of the label.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.Height">
      <summary>The height of the label.</summary>
      <remarks>Returns the height of the label.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.PreferredPlacement">
      <summary>The preferred placement for this label.</summary>
      <remarks>Specifies the preferred placement for this label.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.SetLocation(System.Double,System.Double)">
      <summary>Sets the coordinates of the upper-left corner of the bounding box of the label.</summary>
      <remarks>Sets the coordinates of the upper-left corner of the bounding box of the label.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.SetSize(System.Double,System.Double)">
      <summary>
            Sets the
            <see cref="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Width">width</see>
            and
            <see cref="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Height">height</see>
            of the oriented
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutData.Bounds">bounds</see>
            of this label.
            </summary>
      <remarks>
            Sets the
            <see cref="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Width">width</see>
            and
            <see cref="P:yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle.Height">height</see>
            of the oriented
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutData.Bounds">bounds</see>
            of this label.
            Note that
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutData.Width" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutData.Height" />
            in contrast yield the width and height of the bounding
            box of the oriented bounds, which only coincide with the size of the oriented bounds in the case where the
            oriented bounds are not rotated.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutData.ToString">
      <summary>Returns a string representation of this object.</summary>
      <remarks>Returns a string representation of this object.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.Width">
      <summary>The width of the label.</summary>
      <remarks>Returns the width of the label.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.X">
      <summary>The x-coordinate of the label's upper-left corner of the bounding box.</summary>
      <remarks>Returns the x-coordinate of the label's upper-left corner of the bounding box.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutData.Y">
      <summary>The y-coordinate of the label's upper-left corner of the bounding box.</summary>
      <remarks>Returns the y-coordinate of the label's upper-left corner of the bounding box.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelLayoutDataRefinement">
      <summary>A layout stage that improves the placement of edge labels.</summary>
      <remarks>
            A layout stage that improves the placement of edge labels. This layout stage
            expects that its core layouter calculates initial edge label layout data bound to the
            data provider key
            <see cref="F:yWorks.yFiles.Layout.LabelLayoutKeys.EdgeLabelLayoutDpKey" />
            . Next, this stage tries to
            improve the position of the labels with respect to the preferred placement specifier of the
            labels.
            <br />
            Most commonly, this layout stage is used in conjunction with the integrated edge
            labeling functionality of class
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter" />
            .
            The following code snippet shows how this layout stage can be set up:
            <pre>
            // 'hierarchic' is of type y.layout.hierarchic.HierarchicLayouter.
            // String together a label layout process.
            CompositeLayoutStage ll = new CompositeLayoutStage();
            ll.appendStage(new LabelLayoutTranslator());
            ll.appendStage(new LabelLayoutDataRefinement());
            // Set the compound label layout process as the label layouter for
            // HierarchicLayouter.
            hierarchic.setLabelLayouter(ll);
            hierarchic.setLabelLayouterEnabled(true);
            </pre>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutDataRefinement.#ctor">
      <summary>Creates a new instance of LabelLayoutDataImprovement</summary>
      <remarks>Creates a new instance of LabelLayoutDataImprovement</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutDataRefinement.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true" />.</summary>
      <remarks>Returns <see langword="true" />.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutDataRefinement.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
      <remarks>Assigns a new graph layout to the given layout graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutDataRefinement.InternalLabelingAlgorithm">
      <summary>
            The internal labeling algorithm used to improve the
            label positions.
            </summary>
      <remarks>
            Specifies the internal labeling algorithm used to improve the label
            positions.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelLayoutImpl">
      <summary>This class is a default implementation of the LabelLayout interface.</summary>
      <remarks>This class is a default implementation of the LabelLayout interface.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutImpl.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LabelLayoutImpl" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutImpl.Box">
      <summary>The bounding box of the label.</summary>
      <remarks>Specifies the bounding box of the label.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutImpl.ModelParameter">
      <summary>
            The label model parameter that describes
            the position of this label.
            </summary>
      <remarks>
            Specifies the label model parameter that describes
            the position of this label.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutImpl.OrientedBox">
      <summary>The box of the label</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelLayoutKeys">
      <summary>
            This interface provides label-specific keys that can
            be used to add data providers to a layout graph.
            </summary>
      <remarks>
            This interface provides label-specific keys that can
            be used to add data providers to a layout graph.
            <p />
            Label aware layout algorithms like
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter">HierarchicLayouter</see>
            look for data providers named by these keys.
            <p />
            Instead of setting up label layout data and data providers one can also use
            the  layout stage
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            to automatically translate
            information provided by the standard label layout classes
            <see cref="T:yWorks.yFiles.Layout.IEdgeLabelLayout" />
            and
            <see cref="T:yWorks.yFiles.Layout.INodeLabelLayout" />
            to layout data accessible by the keys defined below.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelLayoutKeys.EdgeLabelLayoutDpKey">
      <summary>
            Key that is used to add or access a data provider to a graph that must
            return for each edge of the graph an array of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData" />
            .
            </summary>
      <remarks>
            Key that is used to add or access a data provider to a graph that must
            return for each edge of the graph an array of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData" />
            .
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelLayoutKeys.NodeLabelLayoutDpKey">
      <summary>
            Key that is used to add or access a data provider to a graph that must
            returns for each node of the graph an array of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData" />
            .
            </summary>
      <remarks>
            Key that is used to add or access a data provider to a graph that must
            returns for each node of the graph an array of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelLayoutTranslator">
      <summary>
            Layout stage that automatically translates label layout information provided by the standard
            label layout classes
            <see cref="T:yWorks.yFiles.Layout.IEdgeLabelLayout" />
            and
            <see cref="T:yWorks.yFiles.Layout.INodeLabelLayout" />
            to layout data
            of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData" />
            that is accessible by the keys defined in class
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutKeys" />
            .
            </summary>
      <remarks>
            Layout stage that automatically translates label layout information provided by the standard
            label layout classes
            <see cref="T:yWorks.yFiles.Layout.IEdgeLabelLayout" />
            and
            <see cref="T:yWorks.yFiles.Layout.INodeLabelLayout" />
            to layout data
            of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData" />
            that is accessible by the keys defined in class
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutKeys" />
            .
            <p />
            One can use this layout stage as label layouter of a label aware layouter like
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter">HierarchicLayouter</see>
            . This can be done by
            assigning the stage by an appropriate call to
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">setLabelLayouter</see>
            .
            <p />
            Note that care must be taken on the choice of label model that is used by the
            classes
            <see cref="T:yWorks.yFiles.Layout.IEdgeLabelLayout" />
            and
            <see cref="T:yWorks.yFiles.Layout.INodeLabelLayout" />
            . The calculated label positions
            must be consistent with the label positions allowed by the label model. The best label layout
            results are achieved by choosing
            <see cref="T:yWorks.yFiles.Layout.FreeEdgeLabelLayoutModel" />
            for edge layouts and
            <see cref="T:yWorks.yFiles.Layout.FreeNodeLabelLayoutModel" />
            for node layouts.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutTranslator.#ctor">
      <summary>Creates a new instance of LabelLayoutTranslator.</summary>
      <remarks>
            Creates a new instance of LabelLayoutTranslator.
            Initially no core layouter will be bound to this layout stage.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutTranslator.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>The returned result gets calculated by the core layouter.</summary>
      <remarks>The returned result gets calculated by the core layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelLayoutTranslator.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Before invoking the core layouter this stage translates traditional
            label layout information to data provider based label layout data.
            </summary>
      <remarks>
            Before invoking the core layouter this stage translates traditional
            label layout information to data provider based label layout data.
            Afterwards the calculated layout data will be written back to the
            original label layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.ResettingEdgeLabelOrientation">
      <summary>Specifies whether or not to reset the orientation of edge labels.</summary>
      <remarks>
            Whether or not to reset the orientation of edge labels. If this option is enabled, the up vector of the corresponding oriented
            box is set to (0,-1). Default value is true.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.ResettingNodeLabelOrientation">
      <summary>Specifies whether or not to reset the orientation of node labels.</summary>
      <remarks>
            Whether or not to reset the orientation of node labels. If this option is enabled, the up vector of the corresponding oriented
            box is set to (0,-1). Default value is false.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels">
      <summary>Specifies whether edge label translation is enabled.</summary>
      <remarks>
            Getter:<br />
            Returns whether edge label translation is enabled.
            Defaults to <see langword="true" />.
            <para />
            Setter:<br />
            Determines whether edge label translation should be enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels">
      <summary>Specifies whether node label translation is enabled.</summary>
      <remarks>
            Getter:<br />
            Returns whether node label translation is enabled.
            Defaults to <see langword="false" />.
            <para />
            Setter:<br />
            Determines whether node label translation should be enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.WriteBackEdgeLabels">
      <summary>Specifies whether edge labels are written back to their model.</summary>
      <remarks>
            Getter:<br />
            Returns whether edge labels are written back to their model.
            Defaults to <see langword="true" />.
            <para />
            Setter:<br />
            Determines whether edge label information is written back to the model.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.LabelLayoutTranslator.WriteBackNodeLabels">
      <summary>Specifies whether node labels are written back to their model.</summary>
      <remarks>
            Getter:<br />
            Returns whether node labels are written back to their model.
            Defaults to <see langword="false" />.
            <para />
            Setter:<br />
            Determines whether node label information is written back to the model.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelPlacements" />
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.Anywhere">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label can be placed anywhere along an edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.AtSource">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed near the source
            node of an edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.AtTarget">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed near the target
            node of an edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.AtCenter">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed near the center
            of the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.AlongEdgeMask">
      <summary>
            Placement specifier mask. Masks all placement specifiers that are not one of
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.AtTarget" />
            ,
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.AtSource" />
            , or
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.AtCenter" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.OnEdge">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed on the path of the edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.LeftOfEdge">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed on the left hand side of the edge
            path if looking from the source node into the direction of the target node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.RightOfEdge">
      <summary>
            Preferred placement specifier for edge labels.
            Expresses that the label should be placed on the right hand side of the edge
            path if looking from the source node into the direction of the target node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LabelPlacements.OnSideOfEdgeMask">
      <summary>
            Placement specifier mask. Masks all placement specifiers that are not one of
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.OnEdge" />
            ,
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.LeftOfEdge" />
            , or
            <see cref="F:yWorks.yFiles.Layout.LabelPlacements.RightOfEdge" />
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LabelRanking">
      <summary>Implements the ranking for edge and node labels for Graph2D.</summary>
      <remarks>
            Implements the ranking for edge and node labels for Graph2D.
            Node label positions have no ranking for the moment, they are all
            equal to 1.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelRanking.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LabelRanking" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LabelRanking.GetProfit(yWorks.yFiles.Layout.LabelCandidate)">
      <summary>Returns the profit for placing a label-candidate.</summary>
      <param name="candidate">a label candidate</param>
      <returns>a value between 0 and 1.</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayouterKeys" />
    <member name="F:yWorks.yFiles.Layout.LayouterKeys.EdgeIdDpKey">
      <summary>
            The data provider key used to look up a unique Object identifier
            (consistent with hashCode() and equals() ) for each edge in a graph.
            </summary>
      <remarks>
            The data provider key used to look up a unique Object identifier
            (consistent with hashCode() and equals() ) for each edge in a graph.
            Layout algorithms may use this information to provide consistent layouts
            for multiple runs.
            The looked up data provider should provide Object values
            for the edges of that graph. These should be consistent with the Object.hashCode()
            and Object.equals() methods.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayouterKeys.NodeIdDpKey">
      <summary>
            The data provider key used to look up a unique Object identifier
            (consistent with hashCode() and equals() ) for each node in a graph.
            </summary>
      <remarks>
            The data provider key used to look up a unique Object identifier
            (consistent with hashCode() and equals() ) for each node in a graph.
            Layout algorithms may use this information to provide consistent layouts
            for multiple runs.
            The looked up data provider should provide Object values
            for the nodes of that graph. These should be consistent with the Object.hashCode()
            and Object.equals() methods.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayouterKeys.SelectedEdgesDpKey">
      <summary>
            The data provider key used to look up the selected
            state of the edges of the graph to be laid out.
            </summary>
      <remarks>
            The data provider key used to look up the selected
            state of the edges of the graph to be laid out.
            A layout algorithm will try to retrieve a
            data provider from the graph to be laid out with this key.
            The looked up data provider should provide boolean values
            for the edges of that graph. The boolean value should signal
            whether an edge is to be considered as selected or not.
            <p />
            Note that for several layouters this key is used for restricting the sphere of action,
            e.g. to route only a subset of the edges by the <c>OrthogonalEdgeRouter</c>.
            However, it is often more convenient to use a specific data provider key for this
            purpose, for example if you want to combine two layouters of this kind which have to operate
            on different subsets of the graph. Thus, these layouters provide a method
            like <c>setSelectedEdgesDpKey(Object)</c> in the case of the <c>OrthogonalEdgeRouter</c>
            for using a different data provider.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayouterKeys.SelectedNodesDpKey">
      <summary>
            The data provider key used to look up the selected
            state of the nodes of the graph to be laid out.
            </summary>
      <remarks>
            The data provider key used to look up the selected
            state of the nodes of the graph to be laid out.
            A layout algorithm will try to retrieve a
            data provider from the graph to be laid out with this key.
            The looked up data provider should provide boolean values
            for the nodes of that graph. The boolean value should signal
            whether a node is to be considered as selected or not.
            <p />
            Note that for several layouters this key is used for restricting the sphere of action,
            e.g. to layout the subgraph induced by the set of selected nodes in the
            <c>SubgraphLayouter</c>.
            However, it is often more convenient to use a specific data provider key for this
            purpose, for example if you want to combine two layouters of this kind which have to operate
            on different subsets of the graph. Thus, these layouters provide a method like
            <c>setSubgraphNodesDpKey(Object)</c> in the case of the <c>SubgraphLayouter</c>
            for using a different data provider.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutGraph">
      <summary>This class represents a drawing of a graph.</summary>
      <remarks>This class represents a drawing of a graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.#ctor">
      <summary>Creates a new Layout Graph</summary>
      <remarks>Creates a new Layout Graph</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.#ctor(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Creates a copy of the given subgraph.</summary>
      <remarks>Creates a copy of the given subgraph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.#ctor(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.ICursor)">
      <summary>Creates a copy of the given subgraph.</summary>
      <remarks>Creates a copy of the given subgraph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.CreateGraphCopyFactory">
      <summary>
            Factory method that is called by
            <see cref="P:yWorks.yFiles.Algorithms.Graph.GraphCopyFactory" />
            to create a (possibly shared) instance.
            </summary>
      <returns>the (possibly shared) instance.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.LayoutGraph.EdgeList">
      <summary>A list, which contains the edges of the graph.</summary>
      <remarks>Returns a list, which contains the edges of the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetBoundingBox">
      <summary>Returns the bounding box of the diagram.</summary>
      <remarks>
            Returns the bounding box of the diagram.
            This is the smallest rectangle containing the entire diagram.
            If the graph does not contain any nodes (and therefore no edges either),
            the bounding box will have negative width and/or height.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetCenter(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the position of a node in a drawing.</summary>
      <param name="node">a node in the graph</param>
      <returns>the center of the node in the drawing of the node</returns>
      <remarks>
            Returns the position of a node in a drawing.
            The position is defined by the center of the node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetCenterX(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the center x-coordinate of the given node.</summary>
      <remarks>Returns the center x-coordinate of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetCenterY(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the center y-coordinate of the given node.</summary>
      <remarks>Returns the center y-coordinate of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetEdgeLabelLayout(System.Object)">
      <summary>
            Returns
            EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </summary>
      <param name="edge">an edge in the drawing.</param>
      <returns>the edge label layout information for <c>edge</c>.</returns>
      <remarks>
            Returns
            EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetEdgeLayout(System.Object)">
      <summary>Returns the layout information for an edge in the drawing.</summary>
      <param name="edge">a edge in the drawing.</param>
      <returns>the layout information for <c>edge</c>.</returns>
      <remarks>Returns the layout information for an edge in the drawing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetFeature(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns the edge which is described by a given label layout.</summary>
      <remarks>Returns the edge which is described by a given label layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetFeature(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns the node which is described by a given label layout.</summary>
      <remarks>Returns the node which is described by a given label layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetHeight(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the height of the given node</summary>
      <remarks>Returns the height of the given node</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns
            EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </summary>
      <param name="edge">an edge in the drawing.</param>
      <returns>the edge label layout information for <c>edge</c>.</returns>
      <remarks>
            Returns
            EdgeLabelLayout objects which describe the layouts
            of the labels that belong to the given edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetLabelLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns
            NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </summary>
      <param name="node">a node in the drawing.</param>
      <returns>the node label layout information for <c>node</c>.</returns>
      <remarks>
            Returns
            NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the layout information for an edge in the drawing.</summary>
      <param name="edge">a edge in the drawing.</param>
      <returns>the layout information for <c>edge</c>.</returns>
      <remarks>Returns the layout information for an edge in the drawing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetLayout(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the layout information for a node in the drawing.</summary>
      <param name="node">a node in the drawing.</param>
      <returns>the layout information for <c>node</c>.</returns>
      <remarks>Returns the layout information for a node in the drawing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetLocation(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the position of the node in a drawing.</summary>
      <param name="node">a node in the graph</param>
      <returns>the upper left corner of the drawing of the node</returns>
      <remarks>
            Returns the position of the node in a drawing.
            The position is defined by the upper left corner of the node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetNodeLabelLayout(System.Object)">
      <summary>
            Returns
            NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </summary>
      <param name="node">a node in the drawing.</param>
      <returns>the node label layout information for <c>node</c>.</returns>
      <remarks>
            Returns
            NodeLabelLayout objects which describe the layouts
            of the labels that belong to the given node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetNodeLayout(System.Object)">
      <summary>Returns the layout information for a node in the drawing.</summary>
      <param name="node">a node in the drawing.</param>
      <returns>the layout information for <c>node</c>.</returns>
      <remarks>Returns the layout information for a node in the drawing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetPath(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the path of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <returns>the path</returns>
      <remarks>
            Returns the path of an edge.
            The path of an edge is the position of the source port,
            followed by the positions of the bends, followed by the position
            of the target port.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetPathList(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the path of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <returns>the path as a YList</returns>
      <remarks>
            Returns the path of an edge.
            The path of an edge is the position of the source port,
            followed by the positions of the bends, followed by the position
            of the target port.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetPointList(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the control points of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <returns>the sequence of control points as a YList</returns>
      <remarks>Returns the control points of an edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetPoints(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the control points of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <returns>the sequence of control points.</returns>
      <remarks>Returns the control points of an edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetRectangle(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the bounding box of a node.</summary>
      <param name="node">a node in the graph.</param>
      <returns>a box.</returns>
      <remarks>Returns the bounding box of a node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetSize(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the size of the node in a drawing.</summary>
      <param name="node">a node in the graph.</param>
      <returns>the size of the node.</returns>
      <remarks>Returns the size of the node in a drawing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetSourcePointAbs(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the coordinates of the source end point of an edge
            in absolute coordinates.
            </summary>
      <param name="edge">an edge in the graph</param>
      <remarks>
            Returns the coordinates of the source end point of an edge
            in absolute coordinates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetSourcePointRel(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the coordinates of the source end point of an edge
            in relative coordinates to the center of the source node.
            </summary>
      <param name="edge">an edge in the graph</param>
      <remarks>
            Returns the coordinates of the source end point of an edge
            in relative coordinates to the center of the source node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetTargetPointAbs(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the coordinates of the target end point of an edge
            in absolute coordinates.
            </summary>
      <param name="edge">an edge in the graph</param>
      <remarks>
            Returns the coordinates of the target end point of an edge
            in absolute coordinates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetTargetPointRel(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the coordinates of the target end point of an edge
            in relative coordinates to the center of the target node.
            </summary>
      <param name="edge">an edge in the graph</param>
      <remarks>
            Returns the coordinates of the target end point of an edge
            in relative coordinates to the center of the target node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetWidth(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the width of the given node.</summary>
      <remarks>Returns the width of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetX(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the upper left x-coordinate of the given node.</summary>
      <remarks>Returns the upper left x-coordinate of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.GetY(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the upper left y-coordinate of the given node.</summary>
      <remarks>Returns the upper left y-coordinate of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.MoveBy(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Moves the location of a node by a given vector</summary>
      <param name="node">a node in the graph</param>
      <param name="dx">the x-component of the vector</param>
      <param name="dy">the y-component of the vector</param>
      <remarks>Moves the location of a node by a given vector</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetCenter(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Sets the center coordinates of the given node.</summary>
      <remarks>Sets the center coordinates of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetCenter(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Sets the position of a node in a drawing.</summary>
      <param name="node">a node in the graph</param>
      <param name="position">the center of the node in the drawing of the node</param>
      <remarks>
            Sets the position of a node in a drawing.
            The position is defined by the center of the node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetEndPointsAbs(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Set the two end points of an edge in absolute coordinates.</summary>
      <param name="edge">an edge in the graph.</param>
      <param name="source">the port on the source side of the edge.</param>
      <param name="target">the port on the target side of the edge.</param>
      <remarks>Set the two end points of an edge in absolute coordinates.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetLocation(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Sets the upper left coordinates of the given node.</summary>
      <remarks>Sets the upper left coordinates of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetLocation(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Set the position of the node in a drawing.</summary>
      <param name="node">a node in the graph</param>
      <param name="position">the upper left corner of the drawing of the node</param>
      <remarks>
            Set the position of the node in a drawing.
            The position is defined by the upper left corner of the node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetPath(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPointPath)">
      <summary>Sets the path of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <param name="path">the path sequence.</param>
      <remarks>
            Sets the path of an edge.
            The path of an edge is the position of the source port,
            followed by the positions of the bends, followed by the position
            of the target port. Both source and target port are expected to be given
            in absolute coordinates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetPath(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList)">
      <summary>Sets the path of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <param name="path">the path sequence given as a YList</param>
      <remarks>
            Sets the path of an edge.
            The path of an edge is the position of the source port,
            followed by the positions of the bends, followed by the position
            of the target port. Both source and target port are expected to be given
            in absolute coordinates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetPoints(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPointPath)">
      <summary>Sets the control points of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <param name="points">the sequence of control points.</param>
      <remarks>Sets the control points of an edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetPoints(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList)">
      <summary>Sets the control points of an edge.</summary>
      <param name="edge">an edge in the graph</param>
      <param name="points">the sequence of control points as a YList</param>
      <remarks>Sets the control points of an edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetSize(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Sets the size of the given node.</summary>
      <remarks>Sets the size of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetSize(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Geometry.YDimension)">
      <summary>Set the size of the node in a drawing.</summary>
      <param name="node">a node in the graph</param>
      <param name="size">the size of the node.</param>
      <remarks>Set the size of the node in a drawing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetSourcePointAbs(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Sets the coordinates of the source end point of an edge
            in absolute coordinates.
            </summary>
      <param name="edge">an edge in the graph</param>
      <param name="point" />
      <remarks>
            Sets the coordinates of the source end point of an edge
            in absolute coordinates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetSourcePointRel(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Sets the coordinates of the source end point of an edge
            in relative coordinates to the center of the source node.
            </summary>
      <param name="edge">an edge in the graph</param>
      <param name="point" />
      <remarks>
            Sets the coordinates of the source end point of an edge
            in relative coordinates to the center of the source node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetTargetPointAbs(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Sets the coordinates of the target end point of an edge
            in absolute coordinates.
            </summary>
      <param name="edge">an edge in the graph</param>
      <param name="point" />
      <remarks>
            Sets the coordinates of the target end point of an edge
            in absolute coordinates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraph.SetTargetPointRel(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Sets the coordinates of the target end point of an edge
            in relative coordinates to the center of the target node.
            </summary>
      <param name="edge">an edge in the graph</param>
      <remarks>
            Sets the coordinates of the target end point of an edge
            in relative coordinates to the center of the target node.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory">
      <summary>
            An implementation of the copy factory interface used by
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier" />
            that can be used by implementations of
            <see cref="T:yWorks.yFiles.Layout.LayoutGraph" />
            .
            </summary>
      <remarks>
            An implementation of the copy factory interface used by
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier" />
            that can be used by implementations of
            <see cref="T:yWorks.yFiles.Layout.LayoutGraph" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyEdge(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Copies the <c>originalEdge</c> from the source graph to the new <c>targetGraph</c>
            using the specified new source and target node in the target graph.
            </summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="newSource">the source node in the target graph to use for the newly created edge</param>
      <param name="newTarget">the target node in the target graph to use for the newly created edge</param>
      <param name="originalEdge">the original edge from the source graph</param>
      <returns>the newly created edge</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyEdgeLabelLayout(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Copies the edge label's layout.</summary>
      <remarks>Copies the edge label's layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyLabels(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Callback that copies the labels for a given edge.</summary>
      <remarks>Callback that copies the labels for a given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyLabels(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Callback that copies the labels for a given node.</summary>
      <remarks>Callback that copies the labels for a given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyNode(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Node)">
      <summary>Copies the <c>originalNode</c> from the source graph to the new <c>targetGraph</c></summary>
      <param name="targetGraph">the graph to create the new node in</param>
      <param name="originalNode">the original node from the source graph</param>
      <returns>the newly created node</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CopyNodeLabelLayout(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Copies the node label's layout.</summary>
      <remarks>Copies the node label's layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.CreateGraph">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Layout.DefaultLayoutGraph" />
            .
            </summary>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Layout.DefaultLayoutGraph" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.PostCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>Callback that will be called after the copy operation has completed.</summary>
      <param name="sourceGraph">the graph that was used to copy the entities from.</param>
      <param name="targetGraph">the graph that was used to copy the entities to.</param>
      <param name="nodeMap">
            a map that contains a mapping between the nodes in the source graph
            to their corresponding nodes in the new graph.
            </param>
      <param name="edgeMap">
            a map that contains a mapping between the edges in the source graph
            to their corresponding edges in the new graph.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.PreCopyGraphData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Callback that will be called before the copy operation takes place.</summary>
      <param name="sourceGraph">the graph that will be used to copy the entities from.</param>
      <param name="targetGraph">the graph that will be used to copy the entities to.</param>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory">
      <summary>
            An implementation of the copy factory interface used by
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier" />
            that can be used by implementations of
            <see cref="T:yWorks.yFiles.Layout.LayoutGraph" />
            that are hierarchically grouped
            using
            <see cref="T:yWorks.yFiles.Layout.Grouping.GroupingKeys" />
            .
            </summary>
      <remarks>
            An implementation of the copy factory interface used by
            <see cref="T:yWorks.yFiles.Algorithms.Util.GraphCopier" />
            that can be used by implementations of
            <see cref="T:yWorks.yFiles.Layout.LayoutGraph" />
            that are hierarchically grouped
            using
            <see cref="T:yWorks.yFiles.Layout.Grouping.GroupingKeys" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.#ctor(yWorks.yFiles.Algorithms.Util.GraphCopier.ICopyFactory)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.CopyData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="src">the old entity</param>
      <param name="dst">the new entity</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.CreateNodeId(System.Object,yWorks.yFiles.Algorithms.Node)">
      <summary>Factory method that creates an id for the given node.</summary>
      <remarks>
            Factory method that creates an id for the given node.
            This implementation uses the destination node itself as the id for the node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.PostCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Util.IMap,yWorks.yFiles.Util.IMap)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
      <param name="nodeMap">a Map that maps old node instances to their new copies</param>
      <param name="edgeMap">a Map that maps old edge instances to their new copies</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory.PreCopyData(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.Graph)">
      <summary>Empty stub to be overwritten by subclass implementations.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutMultiplexer">
      <summary>
            This class delegates its layout calls to a core layout algorithm that is dynamically
            chosen at runtime by inspecting the nodes of the input graph.
            </summary>
      <remarks>
            This class delegates its layout calls to a core layout algorithm that is dynamically
            chosen at runtime by inspecting the nodes of the input graph.
            <p>
            If a data provider is registered with the given graph using the look-up key
            <see cref="F:yWorks.yFiles.Layout.LayoutMultiplexer.LayouterDpKey" />
            
            it is used to retrieve the
            <see cref="T:yWorks.yFiles.Layout.ILayouter" />
            objects that are stored for the graph's
            nodes.
            If no such data provider is registered, this layout stage's core layouter (if
            any) is used for layout calculation of all nodes.
            <br />
            Note that the first non-<see langword="null" /> Layouter retrieved from the data provider
            is used for all nodes.
            </p>
            <p>
            The main purpose of this class is to enable the use of individual layout algorithms
            for components (when used as the core layouter of class
            <see cref="T:yWorks.yFiles.Layout.ComponentLayouter" />
            )
            or for the contents of group nodes (when used as the core layouter of class
            <see cref="T:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter" />
            ).
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutMultiplexer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.LayoutMultiplexer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutMultiplexer.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.LayoutMultiplexer.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.LayoutMultiplexer.GetCoreLayouter(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns the core layout algorithm associated with the
            nodes contained in the given graph.
            </summary>
      <remarks>
            Returns the core layout algorithm associated with the
            nodes contained in the given graph. The default implementation
            looks up the layout algorithm in the data provider registered
            with the key
            <see cref="F:yWorks.yFiles.Layout.LayoutMultiplexer.LayouterDpKey" />
            .
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayoutMultiplexer.LayouterDpKey">
      <summary>
            Look-up key used to register a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides a
            <see cref="T:yWorks.yFiles.Layout.ILayouter" />
            object for each node of a graph.
            </summary>
      <remarks>
            Look-up key used to register a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides a
            <see cref="T:yWorks.yFiles.Layout.ILayouter" />
            object for each node of a graph.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutOrientation">
      <summary>Orientation specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayoutOrientation.TopToBottom">
      <summary>
            Orientation specifier. Layout will be oriented from top to bottom,
            which is the default for all layout algorithms.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayoutOrientation.LeftToRight">
      <summary>
            Orientation specifier. Layout will be from left to right, which means
            that the layout will be rotated by 90 degrees counterclockwise
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayoutOrientation.RightToLeft">
      <summary>
            Orientation specifier. Layout will be from right to left, which means
            that the layout will be rotated by 90 degrees clockwise
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.LayoutOrientation.BottomToTop">
      <summary>
            Orientation specifier. Layout will be from bottom to top, which means
            that the layout will be flipped along the x axis.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.LayoutTool">
      <summary>
            This class is a container for several helper and utility functions for
            the LayoutGraph class.
            </summary>
      <remarks>
            This class is a container for several helper and utility functions for
            the LayoutGraph class.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.AlignNodeLayouts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Algorithms.Node,System.Boolean,System.SByte)" />
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ApplyGraphLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.IGraphLayout)">
      <summary>Applies a GraphLayout to a LayoutGraph.</summary>
      <remarks>Applies a GraphLayout to a LayoutGraph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleGrid(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double)">
      <summary>
            Reassigns the bounds of the rectangles in <c>rects</c> to fit into a
            large rectangle, whose bounds will be stored in <c>finalRect</c>.
            </summary>
      <param name="rects">the rectangles whose, coordinates will be modified</param>
      <param name="finalRect">the exact dimension will be placed in this rectangle</param>
      <param name="viewRatio">the preferred ratio of the grid</param>
      <returns>the dimension of the grid</returns>
      <remarks>
            Reassigns the bounds of the rectangles in <c>rects</c> to fit into a
            large rectangle, whose bounds will be stored in <c>finalRect</c>.
            This procedure tries to generate a final rectangle, whose aspect ratio is
            as close as possible to <c>viewRatio</c>. This is achieved by
            arranging the rectangles in a grid-like fashion.
            The dimension of this grid is returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double)">
      <summary>
            Reassigns the bounds of the rectangles in <c>rects</c> to fit in a
            large rectangle, whose bounds will be stored in <c>finalRect</c>.
            </summary>
      <param name="rects">the rectangles whose coordinates will be modified</param>
      <param name="finalRect">the exact dimension will be placed in this rectangle</param>
      <param name="viewRatio">the preferred ratio of the resulting bounds</param>
      <returns>the number of used rows</returns>
      <remarks>
            Reassigns the bounds of the rectangles in <c>rects</c> to fit in a
            large rectangle, whose bounds will be stored in <c>finalRect</c>.
            This procedure tries to generate a final rectangle, whose aspect ratio is
            as close as possible to <c>viewRatio</c>. This is achieved by
            arranging the rectangles in a rows. The number of used rows will be
            returned.
            This method invokes
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)">arrangeRectangleRows</see>
            with
            <see cref="F:yWorks.yFiles.Layout.RowAlignment.Leading" />
            as the last argument.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)">
      <summary>
            Reassigns the bounds of the rectangles in <c>rects</c> to fit into a
            large rectangle, whose bounds will be stored in <c>finalRect</c>.
            </summary>
      <param name="alignment">
            determines the alignment policy for rows, that are not
            completely filled
            </param>
      <param name="rects">the rectangles whose coordinates will be modified</param>
      <param name="finalRect">the exact dimension will be placed in this rectangle</param>
      <param name="viewRatio">the preferred ratio of the resulting bounds</param>
      <returns>the number of generated rows</returns>
      <remarks>
            Reassigns the bounds of the rectangles in <c>rects</c> to fit into a
            large rectangle, whose bounds will be stored in <c>finalRect</c>.
            This procedure tries to generate a final rectangle, whose aspect ratio is
            as close as possible to <c>viewRatio</c>. This is achieved by
            arranging the rectangles in rows. The number of generated rows is
            returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.AssignReverseLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge)">
      <summary>Set the layout of two parallel edges with different direction identical.</summary>
      <param name="e1">the edge for which the points are set.</param>
      <param name="e2">the template.</param>
      <remarks>Set the layout of two parallel edges with different direction identical.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ClipEdgeOnBB(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This helper method clips the path of the edge on the bounding box
            of the start and end points.
            </summary>
      <remarks>
            This helper method clips the path of the edge on the bounding box
            of the start and end points.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ClipEdgesOnBB(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            This helper method clips the path of the edge on the bounding box
            of the start and end points.
            </summary>
      <remarks>
            This helper method clips the path of the edge on the bounding box
            of the start and end points.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.DetermineEdgeFlowDirection(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Determines the main direction of the edge flow by analyzing the current layout of the graph.</summary>
      <param name="graph">the underlying graph.</param>
      <param name="considerEdges">the edges to consider.</param>
      <returns>
            the flow direction, i.e.,
            <see cref="F:yWorks.yFiles.Layout.EdgeFlow.Down" />
            ,
            <see cref="F:yWorks.yFiles.Layout.EdgeFlow.Left" />
            ,
            <see cref="F:yWorks.yFiles.Layout.EdgeFlow.None" />
            ,
            <see cref="F:yWorks.yFiles.Layout.EdgeFlow.Right" />
            or
            <see cref="F:yWorks.yFiles.Layout.EdgeFlow.Up" />
            .
            </returns>
      <remarks>
            Determines the main direction of the edge flow by analyzing the current layout of the graph.
            The method only considers edges for which the given DataProvider returns true.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.EdgeLayoutString(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the path of the layout of a specific edge as a String.</summary>
      <remarks>Returns the path of the layout of a specific edge as a String.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetBoundingBox(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the bounding box of the given edge.</summary>
      <remarks>Returns the bounding box of the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetBoundingBox(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Returns the bounding box of the edges accessible through the given edge cursor.</summary>
      <remarks>Returns the bounding box of the edges accessible through the given edge cursor.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetBoundingBox(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor)">
      <summary>Returns the bounding box of the nodes accessible through the given node cursor.</summary>
      <remarks>Returns the bounding box of the nodes accessible through the given node cursor.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetBoundingBox(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor,yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>Returns the bounding box of the nodes and edges accessible through the given cursors.</summary>
      <remarks>Returns the bounding box of the nodes and edges accessible through the given cursors.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetBoundingBox(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor,yWorks.yFiles.Algorithms.IEdgeCursor,System.Boolean)">
      <summary>Returns the bounding box of the nodes and edges accessible through the given cursors.</summary>
      <remarks>
            Returns the bounding box of the nodes and edges accessible through the given cursors.
            Optionally, the resulting bounding box will also include the bounds of
            all node and edge labels attached to the accessible node sand edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetBoundingBox(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the bounding box of the given node.</summary>
      <remarks>Returns the bounding box of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetEdgeClippedOnBB(yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            This helper method clips the path of an edge on the bounding box
            of the start and end vertices.
            </summary>
      <remarks>
            This helper method clips the path of an edge on the bounding box
            of the start and end vertices.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetEdgeClippedOnBB(yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Double)">
      <summary>
            This helper method clips the path of an edge on the bounding box
            of the start and end vertices.
            </summary>
      <remarks>
            This helper method clips the path of an edge on the bounding box
            of the start and end vertices.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetEdgeClippedOnBB(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This helper method clips the path of an edge on the bounding box
            of the start and end vertices.
            </summary>
      <remarks>
            This helper method clips the path of an edge on the bounding box
            of the start and end vertices.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetLabelPlacement(yWorks.yFiles.Layout.IEdgeLabelModel,yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the upper left corner of the given label's paraxial bounding box
            as encoded by the specified model parameter.
            </summary>
      <param name="model">the label model used to place the label.</param>
      <param name="labelSize">the size of the label that should be placed.</param>
      <param name="edgeLayout">the layout of the edge to which the label belongs.</param>
      <param name="sourceLayout">the layout of the source node of the label owning edge.</param>
      <param name="targetLayout">the layout of the target node of the label owning edge.</param>
      <param name="param">
            the model parameter that describes the abstract position of
            the label within the specified model. The parameter must have been
            generated by said model.
            </param>
      <returns>the upper left corner of the label's bounding box.</returns>
      <remarks>
            Returns the upper left corner of the given label's paraxial bounding box
            as encoded by the specified model parameter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetLabelPlacement(yWorks.yFiles.Layout.INodeLabelModel,yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the upper left corner of the given label's paraxial bounding box
            as encoded by the specified model parameter.
            </summary>
      <param name="model">the label model used to place the label.</param>
      <param name="labelSize">the size of the label that should be placed.</param>
      <param name="nodeLayout">the layout of the node to which the label belongs.</param>
      <param name="param">
            the model parameter that describes the abstract position of
            the label within the specified model. The parameter must have been
            generated by said model.
            </param>
      <returns>the upper left corner of the label's bounding box.</returns>
      <remarks>
            Returns the upper left corner of the given label's paraxial bounding box
            as encoded by the specified model parameter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetNodeDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the distance between the centers of two nodes</summary>
      <remarks>Returns the distance between the centers of two nodes</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetNodePositions(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns the positions of the nodes of a graph's diagram.</summary>
      <remarks>Returns the positions of the nodes of a graph's diagram.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.GetPathLength(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the length of path of a given edge.</summary>
      <remarks>
            Returns the length of path of a given edge. The path starts
            at the source point traverses through all control points and ends
            at the target point.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.InitDiagram(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            This method assigns the position (0,0) to all nodes in the graph,
            and sets the edges to straight lines with ports in the center
            of the adjacent node.
            </summary>
      <remarks>
            This method assigns the position (0,0) to all nodes in the graph,
            and sets the edges to straight lines with ports in the center
            of the adjacent node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.IsEdgeOutsideNodes(yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Double)">
      <summary>
            This helper method tests if the path of an edge is outside
            the bounding box of the start and end vertices.
            </summary>
      <remarks>
            This helper method tests if the path of an edge is outside
            the bounding box of the start and end vertices.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.IsEdgeOutsideNodes(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            This helper method tests if the path of an edge is outside
            the bounding box of the start and end vertices.
            </summary>
      <remarks>
            This helper method tests if the path of an edge is outside
            the bounding box of the start and end vertices.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.IsUsingOrthogonalEdgeRoutes(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Returns true if most of the edges of the graph are routed orthogonal.</summary>
      <param name="graph">the underlying graph.</param>
      <param name="considerEdges">the edges to consider.</param>
      <returns>true if most of the edges of the graph are routed orthogonal.</returns>
      <remarks>
            Returns true if most of the edges of the graph are routed orthogonal.
            The method only considers edges for which the given DataProvider returns true.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveEdge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,System.Double,System.Double)">
      <summary>Moves the edge points of the given edge by the vector <c>(dx,dy)</c>.</summary>
      <remarks>Moves the edge points of the given edge by the vector <c>(dx,dy)</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeCursor,System.Double,System.Double)">
      <summary>Moves all edges accessible through the given edge cursor by the vector <c>(dx,dy)</c>.</summary>
      <remarks>Moves all edges accessible through the given edge cursor by the vector <c>(dx,dy)</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveNode(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Moves the given node by the vector <c>(dx,dy)</c>.</summary>
      <remarks>Moves the given node by the vector <c>(dx,dy)</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveNodes(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor,System.Double,System.Double)">
      <summary>Moves all nodes accessible through the given node cursor by the vector <c>(dx,dy)</c>.</summary>
      <remarks>Moves all nodes accessible through the given node cursor by the vector <c>(dx,dy)</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveSubgraph(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeCursor,System.Double,System.Double)">
      <summary>
            Moves the subgraph induced by edges accessible through the given edge cursor
            by the vector <c>(dx,dy)</c>.
            </summary>
      <remarks>
            Moves the subgraph induced by edges accessible through the given edge cursor
            by the vector <c>(dx,dy)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.MoveSubgraph(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor,System.Double,System.Double)">
      <summary>
            Moves the subgraph induced by nodes accessible through the given node cursor
            by the vector <c>(dx,dy)</c>.
            </summary>
      <remarks>
            Moves the subgraph induced by nodes accessible through the given node cursor
            by the vector <c>(dx,dy)</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.PathIntersectsRect(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>
            Checks whether or not the path of an edge intersects the interior of
            a given rectangular area.
            </summary>
      <remarks>
            Checks whether or not the path of an edge intersects the interior of
            a given rectangular area.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RemoveDuplicateBends(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>This helper method removes duplicate bends from all edges in the graph</summary>
      <param name="gd">a graph diagram.</param>
      <remarks>This helper method removes duplicate bends from all edges in the graph</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RemoveDuplicateBends(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>This helper method removes duplicate bends from the given edge in the graph</summary>
      <param name="gd">a graph diagram.</param>
      <param name="edge">the edge.</param>
      <remarks>This helper method removes duplicate bends from the given edge in the graph</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ResetPath(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Assigns a trivial path which has no control points to the specified edge
            and sets the edge's ports to the center of the corresponding node.
            </summary>
      <param name="gd">a graph diagram.</param>
      <param name="edge">an edge in graph.</param>
      <remarks>
            Assigns a trivial path which has no control points to the specified edge
            and sets the edge's ports to the center of the corresponding node.
            Calling this method is equivalent to
            <blockquote>
            <c>resetPath(gd, edge, true)</c>
            </blockquote>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ResetPath(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,System.Boolean)">
      <summary>Assigns a trivial path which has no control points to the specified edge.</summary>
      <param name="gd">a graph diagram.</param>
      <param name="edge">an edge in graph.</param>
      <param name="resetPorts">
            if <see langword="true" />, the ports of the edge are set
            to the center of the corresponding node.
            </param>
      <remarks>Assigns a trivial path which has no control points to the specified edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ResetPaths(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Assigns a trivial path which has no control points to all edges in the
            specified graph and sets the edges' ports to the center of the
            corresponding nodes.
            </summary>
      <param name="gd">a graph diagram.</param>
      <remarks>
            Assigns a trivial path which has no control points to all edges in the
            specified graph and sets the edges' ports to the center of the
            corresponding nodes.
            Calling this method is equivalent to
            <blockquote>
            <c>resetPaths(gd, true)</c>
            </blockquote>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ResetPaths(yWorks.yFiles.Layout.LayoutGraph,System.Boolean)">
      <summary>
            Assigns a trivial path which has no control points to all edges in the
            specified graph.
            </summary>
      <param name="gd">a graph diagram.</param>
      <param name="resetPorts">
            if <see langword="true" />, the ports of the edges are set
            to the center of the corresponding nodes.
            </param>
      <remarks>
            Assigns a trivial path which has no control points to all edges in the
            specified graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ResetPorts(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Sets the ports to the center of the nodes.</summary>
      <param name="gd">a graph diagram.</param>
      <remarks>Sets the ports to the center of the nodes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.ReverseEdgeLayout(yWorks.yFiles.Layout.IEdgeLayout)">
      <summary>Reverses the layout of an edge.</summary>
      <remarks>
            Reverses the layout of an edge.
            This method reverses the order of points
            and swaps source with target point.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RoundEdgeLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Round the values of the control points and ports of an edge.</summary>
      <remarks>Round the values of the control points and ports of an edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RoundLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Round the values of the layout of an entire layout.</summary>
      <remarks>Round the values of the layout of an entire layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RoundNodeLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Round the values of the layout of a node.</summary>
      <remarks>Round the values of the layout of a node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RouteEdgesParallel(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,System.Double)">
      <summary>Routes two edges which are incident to the same nodes, in parallel.</summary>
      <remarks>Routes two edges which are incident to the same nodes, in parallel.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RouteEdgesParallel(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Edge,System.Double,System.Boolean,System.Double,System.Double)">
      <summary>Routes two edges which are incident to the same nodes, in parallel.</summary>
      <param name="gd">the graph</param>
      <param name="e1">the leading edge</param>
      <param name="e2">the edge to be adjusted (may be e1)</param>
      <param name="lineDistance">the distance between the two edges</param>
      <param name="joinEnds">whether the end points should all be set to the end points of e1</param>
      <param name="absJoinDist">
            the absolute distance between the end points and the beginning to
            the parallel segment routing
            </param>
      <param name="relJoinDist">
            the relative distance, measured relative to the length of the
            first/last segments
            </param>
      <remarks>Routes two edges which are incident to the same nodes, in parallel.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RouteEdgesParallel(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.EdgeList,System.Double)">
      <summary>Routes a list of edges with are incident to the same nodes, in parallel.</summary>
      <param name="gd">the graph</param>
      <param name="e1">the leading edge</param>
      <param name="list">the list of edges that will be aligned to e1</param>
      <param name="lineDistance">the distance between two edges</param>
      <remarks>
            Routes a list of edges with are incident to the same nodes, in parallel.
            Invoking this method is equivalent to:
            <blockquote><pre>
            routeEdgesParallel(gd, e1, list, lineDistance, false, false, 0.0d, 0.0d)
            </pre></blockquote>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RouteEdgesParallel(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.EdgeList,System.Double,System.Boolean,System.Boolean,System.Double,System.Double)">
      <summary>Routes a list of edges which are incident to the same nodes, in parallel.</summary>
      <param name="gd">the graph</param>
      <param name="e1">the leading edge</param>
      <param name="list">the list of edges that will be aligned to e1</param>
      <param name="lineDistance">the distance between two edges</param>
      <param name="adjustE1">whether e1 should be adjusted if the size of list is odd</param>
      <param name="joinEnds">whether the end points should all be set to the end points of e1</param>
      <param name="absJoinDist">
            the absolute distance between the end points and the beginning to
            the parallel segment routing
            </param>
      <param name="relJoinDist">
            the relative distance, measured relative to the length of the
            first/last segments
            </param>
      <remarks>Routes a list of edges which are incident to the same nodes, in parallel.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.LayoutTool.RouteSelfLoop(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Routes a self-loop.</summary>
      <param name="e">An edge with <c>e.source.equals(e.target)</c>.</param>
      <remarks>Routes a self-loop.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.MinNodeSizeStage">
      <summary>This layout stage enforces a given minimum width/height of the nodes of a graph during the layout process.</summary>
      <remarks>
            This layout stage enforces a given minimum width/height of the nodes of a graph during the layout process.
            Therefore it temporarily enlarges nodes whose width/height fall below the specified minimum values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.MinNodeSizeStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Instantiates a new MinNodeSizeStage that wraps the given core layouter.</summary>
      <param name="core">The core layouter.</param>
      <remarks>
            Instantiates a new MinNodeSizeStage that wraps the given core layouter.
            The minimum width/height of nodes is set to 1.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.MinNodeSizeStage.#ctor(yWorks.yFiles.Layout.ILayouter,System.Double,System.Double)">
      <summary>Instantiates a new MinNodeSizeStage that wraps the given core layouter.</summary>
      <param name="core">The core layouter.</param>
      <param name="minWidth">The minimum width of nodes that should be enforced.</param>
      <param name="minHeight">The minimum height of nodes that should be enforced.</param>
      <remarks>Instantiates a new MinNodeSizeStage that wraps the given core layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.MinNodeSizeStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.MinNodeSizeStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="T:yWorks.yFiles.Layout.MirrorMask" />
    <member name="F:yWorks.yFiles.Layout.MirrorMask.None">
      <summary>Constant that can be used to prevent any mirroring of layout orientations.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.MirrorMask.TopToBottom">
      <summary>
            Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
            their corresponding axis. Adding this constant to the mask will result in mirror the y-axis of the graph for layout
            orientation LayoutOrientation.TOP_TO_BOTTOM.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.MirrorMask.RightToLeft">
      <summary>
            Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
            their corresponding axis. Adding this constant to the mask will result in mirror the x-axis of the graph for layout
            orientation LayoutOrientation.RIGHT_TO_LEFT.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.MirrorMask.BottomToTop">
      <summary>
            Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
            their corresponding axis. Adding this constant to the mask will result in mirror the y-axis of the graph for layout
            orientation LayoutOrientation.BOTTOM_TO_TOP.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.MirrorMask.LeftToRight">
      <summary>
            Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
            their corresponding axis. Adding this constant to the mask will result in mirror the x-axis of the graph for layout
            orientation LayoutOrientation.LEFT_TO_RIGHT.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.NodeLabelCandidate">
      <summary>
            This class represents a candidate position for label associated to a node
            in a graph.
            </summary>
      <remarks>
            This class represents a candidate position for label associated to a node
            in a graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.NodeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,System.Object,yWorks.yFiles.Layout.INodeLabelLayout,System.Boolean)">
      <summary>Returns a new instance of NodeLabelCandidate.</summary>
      <param name="orientedBox">the box that specifies the candidate's size and position.</param>
      <param name="param">the parameters of the labeling model associated with this candidate.</param>
      <param name="owner">the label associated to the candidate.</param>
      <param name="internal">
            flag whether the candidate is inside the node,
            or outside.
            </param>
      <remarks>Returns a new instance of NodeLabelCandidate.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.NodeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns a new instance of NodeLabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <remarks>Returns a new instance of NodeLabelCandidate.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.NodeLabelCandidate.#ctor(yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YDimension,System.Object,yWorks.yFiles.Layout.INodeLabelLayout,System.Boolean)">
      <summary>Returns a new instance of NodeLabelCandidate.</summary>
      <param name="pos">
            the location of the upper
            left corner of the candidate.
            </param>
      <param name="size">the size of the candidate.</param>
      <param name="param">
            the parameters of the labeling model
            associated with this candidate.
            </param>
      <param name="owner">the label associated to the candidate.</param>
      <param name="internal">
            flag whether the candidate is inside the node,
            or outside.
            </param>
      <remarks>Returns a new instance of NodeLabelCandidate.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.NodeLabelLayoutImpl">
      <summary>
            This class is an default implementation of the NodeLabelLayout
            interface.
            </summary>
      <remarks>
            This class is an default implementation of the NodeLabelLayout
            interface.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.NodeLabelLayoutImpl.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.NodeLabelLayoutImpl" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.NodeLabelLayoutImpl.LabelModel">
      <summary>The node label model associated with this label layout</summary>
      <remarks>Specifies the node label model associated with this label layout</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage">
      <summary>Layout stage that can be used to normalize the order of the elements within a graph.</summary>
      <remarks>
            Layout stage that can be used to normalize the order of the elements within a graph. Amongst other factors,
            the results produced by layout algorithms usually depend on the order of the nodes and edges within a graph.
            Unfortunately, useful operations such as hiding or unhiding elements from a graph or
            simply invoking layout algorithms on a graph will have the potential side effect of changing that order.
            With this layout stage it is possible to establish a predefined order of nodes and edges within a graph to
            avoid non-deterministic layout behavior. Defining the order of nodes and edges is done by
            associating each node or edge in the graph with a <c>Comparable</c> value using DataProviders
            registered with the key
            <see cref="F:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.ComparableNodeDpKey" />
            , or
            <see cref="F:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.ComparableEdgeDpKey" />
            respectively.
            the DataProvider key
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="F:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.ComparableEdgeDpKey">
      <summary>
            The <c>DataProvider</c> registered with this key must return a
            <see cref="T:System.IComparable" />
            object for each edge thereby inducing a (global) order
            for edges.
            </summary>
      <remarks>
            The <c>DataProvider</c> registered with this key must return a
            <see cref="T:System.IComparable" />
            object for each edge thereby inducing a (global) order
            for edges.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.ComparableNodeDpKey">
      <summary>
            The <c>DataProvider</c> registered with this key must return a
            <see cref="T:System.IComparable" />
            object for each node thereby inducing a (global) order
            for nodes.
            </summary>
      <remarks>
            The <c>DataProvider</c> registered with this key must return a
            <see cref="T:System.IComparable" />
            object for each node thereby inducing a (global) order
            for nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.NormalizingGraphElementOrderStage.FillComparableMapFromGraph(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataMap,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>Convenience method that assigns comparable values for each node and edge.</summary>
      <remarks>
            Convenience method that assigns comparable values for each node and edge. The compared values
            are induced from the current ordering of the nodes and edges within the given graph.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.OrientationLayouter">
      <summary>
            A layout stage that performs changes the orientation
            of the layout that another algorithm calculates.
            </summary>
      <remarks>
            A layout stage that performs changes the orientation
            of the layout that another algorithm calculates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.#ctor">
      <summary>Instantiates a new OrientationLayouter.</summary>
      <remarks>Instantiates a new OrientationLayouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Instantiates a new OrientationLayouter.</summary>
      <remarks>
            Instantiates a new OrientationLayouter. the core layout routine
            will be delegated to the given layouter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.#ctor(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>Instantiates a new OrientationLayouter with a given orientation.</summary>
      <remarks>Instantiates a new OrientationLayouter with a given orientation.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.CompleteOrientationChange(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Method that will be called after the core layouter has been activated.</summary>
      <remarks>
            Method that will be called after the core layouter has been activated.
            It performs the inverse coordinate transformation that has been applied
            to the layout by method
            <see cref="M:yWorks.yFiles.Layout.OrientationLayouter.PrepareOrientationChange(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.CompleteTransform(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Transforms a point for the completion phase.</summary>
      <remarks>Transforms a point for the completion phase.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.CreateOrientedInsets(yWorks.yFiles.Util.Geom.Insets)">
      <summary>Create and return an insets object that is a geometric transform of the given insets.</summary>
      <remarks>
            Create and return an insets object that is a geometric transform of the given insets.
            The transform will correspond to the currently set orientation.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.CreateOrientedNodeSize(yWorks.yFiles.Algorithms.Geometry.YDimension)">
      <summary>Create and return an YDimension object that is a geometric transform of the given size.</summary>
      <remarks>
            Create and return an YDimension object that is a geometric transform of the given size.
            The transform will correspond to the currently set orientation.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.OrientationLayouter.HorizontalOrientation">
      <summary>
            Specifies whether or not the set orientation is a horizontal
            orientation, i.e.
            </summary>
      <remarks>
            Returns whether or not the set orientation is a horizontal
            orientation, i.e. one of
            <see cref="F:yWorks.yFiles.Layout.LayoutOrientation.LeftToRight" />
            or
            <see cref="F:yWorks.yFiles.Layout.LayoutOrientation.RightToLeft" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.IsOrientationMirrored(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>This method will return whether the layouter will mirror the graph for a given layout orientation.</summary>
      <param name="orientation">the layout orientation, for which to check the mirror state.</param>
      <returns>
        <ul>
          <li>true - if the layouter will mirror the graph at the corresponding axis
            (x-Axis for horizontal orientations, y-Axis for vertical orientations) for the given layout orientation.</li>
          <li>false - otherwise.</li>
        </ul>
      </returns>
      <remarks>This method will return whether the layouter will mirror the graph for a given layout orientation.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.OrientationLayouter.MirrorMask">
      <summary>The mirror mask, that defines which orientations this layouter shall mirror.</summary>
      <remarks>
            Specifies the mirror mask, that defines which orientations this layouter shall mirror.
            Setting a layout orientation can be seen as rotating the graph  90, 180 or 270 degrees.
            Afterwards the graph can be mirrored at the x-Axis (for horizontal layout orientations) or
            y-Axis (for vertical layout orientations). Which directions are mirrored can be defined by the given mask.
            <p>
            By default a mirror mask is set, where
            <see cref="F:yWorks.yFiles.Layout.LayoutOrientation.BottomToTop" />
            , will be mirrored at the y-Axis.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">
      <summary>The orientation of the layout.</summary>
      <remarks>
            Specifies the orientation of the layout.
            By default
            <see cref="F:yWorks.yFiles.Layout.LayoutOrientation.TopToBottom" />
            is set.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.PrepareOrientationChange(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Method that will be called before the core layouter gets activated.</summary>
      <remarks>
            Method that will be called before the core layouter gets activated.
            It prepares the layout for the desired orientation by rotating/mirroring
            the coordinates and bounds of the graph layout such that the core layouter
            can perform the layout in the canonical TOP_TO_BOTTOM manner.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.PrepareTransform(yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Transforms a point for the preparation phase.</summary>
      <remarks>Transforms a point for the preparation phase.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.Transform(yWorks.yFiles.Algorithms.Geometry.YPoint,System.Boolean)">
      <summary>
            Transforms a point for the preparation or completion
            phase.
            </summary>
      <param name="prepare">
            if <see langword="true" /> then the transformation
            is for the preparation phase, otherwise for the completion phase.
            </param>
      <remarks>
            Transforms a point for the preparation or completion
            phase.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.OrientationLayouter.Transformer">
      <summary>Class that provides a method for transferring a point to its final position.</summary>
      <remarks>
            Class that provides a method for transferring a point to its final position.
            Used for internal purposes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.Transformer.FinalizeTransform(yWorks.yFiles.Algorithms.Geometry.YPoint)" />
    <member name="M:yWorks.yFiles.Layout.OrientationLayouter.Transformer.InitTransform(yWorks.yFiles.Algorithms.Geometry.YPoint)" />
    <member name="T:yWorks.yFiles.Layout.ParallelEdgeLayouter">
      <summary>A layout algorithm that routes parallel edges (edges that connect the same pair of nodes) of a graph.</summary>
      <remarks>
            A layout algorithm that routes parallel edges (edges that connect the same pair of nodes) of a graph.
            <p />
            A core layout algorithm can be specified for this class. In that case the performed layout process of this class
            is subdivided into four stages:
            <ol>
            <li>Remove parallel edges from the input graph.
            If there are parallel edges between two nodes A and B than
            only one of these edges will remain in the graph. The remaining edge is called the leading edge and
            is the representative of the other edges.</li>
            <li>Invoke the core layouter on the now parallel edge free graph.</li>
            <li>Reinsert all formerly removed edges of the graph.</li>
            <li>Route the parallel edges such that they run in parallel
            to their leading edge which was routed by the core layouter.</li>
            </ol>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.#ctor">
      <summary>Creates a new instance of ParallelEdgeLayouter with no core layouter assigned.</summary>
      <remarks>Creates a new instance of ParallelEdgeLayouter with no core layouter assigned.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of ParallelEdgeLayouter for the given core layouter.</summary>
      <remarks>Creates a new instance of ParallelEdgeLayouter for the given core layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.AbsJoinEndDistance">
      <summary>
            The absolute distance from the end point of the lines to the first
            parallel segments if end joining is enabled.
            </summary>
      <remarks>
            Specifies the absolute distance from the end point of the lines to the first
            parallel segments if end joining is enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.AdaptiveLineDistances">
      <summary>Whether or not the line distances between parallel edges should be determined according to the nodes' bounds.</summary>
      <remarks>
            Whether or not the line distances between parallel edges should be determined according to the nodes' bounds.
            If enabled, the line distances are chosen such that all parallel edges can be drawn straight-line and still connect
            to the nodes' bounds.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.AdjustLeadingEdge">
      <summary>
            Specifies whether this layouter will adjust the leading edge if the number of edges
            is even.
            </summary>
      <remarks>
            Specifies whether this layouter will adjust the leading edge if the number of edges
            is even.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.DirectedMode">
      <summary>Specifies whether or not edges should be considered as directed.</summary>
      <remarks>
            Specifies whether or not edges should be considered as directed. In directed mode
            only edges that have the same source and target node will be routed
            in parallel. In undirected mode, all edges connecting the same pair of edges
            will be routed in parallel. By default this feature is disabled.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.FindAndHideParallelEdges(yWorks.yFiles.Algorithms.Graph)">
      <summary>This method detects parallel edges of the given graph.</summary>
      <remarks>
            This method detects parallel edges of the given graph. From each set of parallel edges
            it hides all but one edge from the given graph.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.ParallelEdgeLayouter.hiddenEdges">
      <summary>Holds the list of parallel edges that are hidden from the core layouter.</summary>
      <remarks>Holds the list of parallel edges that are hidden from the core layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.JoinEnds">
      <summary>
            The state of the automatic end joining mechanism,
            i.e.
            </summary>
      <remarks>
            Getter:<br />
            Returns the state of the automatic end joining mechanism,
            i.e. if all lines should end at the same point.
            <para />
            Setter:<br />
            Specifies whether or not to join end points of parallel edges.
            If enabled all lines end at the same point.
            By default, this feature is disabled.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.ParallelEdgeLayouter.LayoutParallelEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>This method assigns a layout to parallel edges.</summary>
      <remarks>
            This method assigns a layout to parallel edges. The layout for each parallel edge follows the
            layout of the one edge not being removed from the core layouter.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.ParallelEdgeLayouter.LeadingEdgeDpKey">
      <summary>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key that can be used to specify which parallel edge should be used
            as leading edge, i.e., as the edge whose layout is used to obtain the layout of the corresponding parallel edges.
            </summary>
      <remarks>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key that can be used to specify which parallel edge should be used
            as leading edge, i.e., as the edge whose layout is used to obtain the layout of the corresponding parallel edges.
            For every
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            instance the provider should yield
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">boolean</see>
            values
            to indicate whether an edge is a leading edge.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.LineDistance">
      <summary>
            The distance between two adjacent
            paths that run in parallel.
            </summary>
      <remarks>
            Specifies the distance between two adjacent paths that run in parallel.
            Note: if adaptive line distances are used (see
            <see cref="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.AdaptiveLineDistances" />
            ) the real distance may
            be less than the given line distance.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.ParallelEdgeLayouter.parallelEdges">
      <summary>EdgeMap that associates a hidden edge with the unique parallel edge not hidden from the core layouter.</summary>
      <remarks>EdgeMap that associates a hidden edge with the unique parallel edge not hidden from the core layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.ParallelEdgeLayouter.RelJoinEndDistance">
      <summary>
            The relative distance from the end point of the lines to the first
            parallel segments if end joining is enabled.
            </summary>
      <remarks>
            Specifies the relative distance from the end point of the lines to the first
            parallel segments if end joining is enabled.
            The length will be relative to the corresponding original
            segment's length.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.ParallelEdgeLayouter.ScopeDpKey">
      <summary>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key that can be used to tell the stage whether edges should be included in
            or excluded from the calculation.
            </summary>
      <remarks>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key that can be used to tell the stage whether edges should be included in
            or excluded from the calculation. For every
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            instance the provider
            should yield
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">boolean</see>
            values to indicate whether an
            edge should be laid out.
            If no data provider is registered for the given key, all edges wil be laid out.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter">
      <summary>This layout stage provides a framework for layouts that are based on a divide and conquer approach.</summary>
      <remarks>
            This layout stage provides a framework for layouts that are based on a divide and conquer approach.
            The workings of this stage is subdivided into four stages:
            <ol>
            <li>
            The input graph is partitioned into smaller units. Implementations of this phase can
            be set using method
            <see cref="P:yWorks.yFiles.Layout.PartitionLayouter.PartitionFinder" />
            .
            </li>
            <li>
            Optionally, the graph partitions are laid out by an layout algorithm. Implementations of this phase can
            be set using method
            <see cref="P:yWorks.yFiles.Layout.AbstractLayoutStage.CoreLayouter" />
            .
            </li>
            <li>
            The graph partitions are independently arranged. Implementations of this phase can
            be set using method
            <see cref="P:yWorks.yFiles.Layout.PartitionLayouter.PartitionPlacer" />
            .
            </li>
            <li>
            Edges that connect nodes in different graph partitions will be routed. Implementations of this phase can
            be set using method
            <see cref="P:yWorks.yFiles.Layout.PartitionLayouter.InterEdgeRouter" />
            </li>
            </ol>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.PartitionLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns
            <see cref="M:yWorks.yFiles.Layout.AbstractLayoutStage.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <remarks>
            Returns
            <see cref="M:yWorks.yFiles.Layout.AbstractLayoutStage.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
      <remarks>Main layout routine that assigns new layout information to the given graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.InterEdgeRouter">
      <summary>The currently set InterEdgeRouter instance.</summary>
      <remarks>
            Getter:<br />
            Returns the currently set InterEdgeRouter instance.
            <para />
            Setter:<br />
            Sets the InterEdgeRouter instance to use.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.PartitionFinder">
      <summary>The currently set PartitionFinder instance.</summary>
      <remarks>
            Getter:<br />
            Returns the currently set PartitionFinder instance.
            <para />
            Setter:<br />
            Sets the PartitionFinder instance to use.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.PartitionPlacer">
      <summary>The currently set PartitionPlacer instance.</summary>
      <remarks>
            Getter:<br />
            Returns the currently set PartitionPlacer instance.
            <para />
            Setter:<br />
            Sets the PartitionPlacer instance to use.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter">
      <summary>
            InterEdgeRouter implementation that routes inter-edges using
            <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter" />
            .
            </summary>
      <remarks>
            InterEdgeRouter implementation that routes inter-edges using
            <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.#ctor">
      <summary>Creates a new instance of this class.</summary>
      <remarks>Creates a new instance of this class.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.ChannelEdgeRouter">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter" />
            instance used to route inter-edges.
            </summary>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter" />
            instance used to route inter-edges.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.InterEdgeDPKey">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key which is used to register the
            inter-edge data provider passed to
            <see cref="M:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)" />
            on the given graph.
            </summary>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key which is used to register the
            inter-edge data provider passed to
            <see cref="M:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)" />
            on the given graph. Defaults to
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedEdgesDpKey" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.Margin">
      <summary>
            The maximum relative distance between an edge and its closest
            node for edges routed outside the bounding box of all graph nodes.
            </summary>
      <remarks>
            Getter:<br />
            Returns the maximum relative distance between an edge and its closest
            node for edges routed outside the bounding box of all graph nodes.
            A negative value means that there is no restriction for the edge-node
            distance.
            <para />
            Setter:<br />
            Specifies the maximum relative distance between an edge and its closest
            node for edges that are routed outside the bounding box of all graph
            nodes. The value is relative in the way that edges to the left or right
            of the nodes' bounding box must satisfy
            <c>dist(edge, bounding box) &lt;= (bounding box width) * margin</c>
            and edges above or below the nodes' bounding box must satisfy
            <c>dist(edge, bounding box) &lt;= (bounding box height) * margin</c>.
            Passing in a negative value effectively allow edges to be arbitrarily
            far from their closest nodes.
            By default <c>margin</c> is set to <c>-1.0</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Routes inter-edges of the partitioned graph.</summary>
      <param name="graph">the input graph.</param>
      <param name="partitionIDDP">the partition id for each node in the graph.</param>
      <param name="interEdgeDP">
            holds a boolean value for each edge of the graph
            indicating if the edge is an inter-edge or not.
            </param>
      <remarks>
            Routes inter-edges of the partitioned graph.
            This implementation will register/deregister <c>interEdgeDP</c>
            on the specified input graph before/after doing any actual routing.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter.RouteInterEdgesOnly">
      <summary>
        <see langword="true" /> if this <c>ChannelInterEdgeRouter</c>
            is configured to route inter-partition edges only.
            </summary>
      <remarks>
            Getter:<br />
            Returns <see langword="true" /> if this <c>ChannelInterEdgeRouter</c>
            is configured to route inter-partition edges only.
            By default, all edges are routed, i.e. <c>routeInterEdgesOnly</c>
            is set to <see langword="false" />.
            <para />
            Setter:<br />
            Specifies whether to route inter-partition edges only.
            By default, all edges are routed, i.e. <c>routeInterEdgesOnly</c>
            is set to <see langword="false" />.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.ComponentPartitionPlacer">
      <summary>
            PartitionPlacer implementation that uses
            <see cref="T:yWorks.yFiles.Layout.ComponentLayouter" />
            to place
            the partitions.
            </summary>
      <remarks>
            PartitionPlacer implementation that uses
            <see cref="T:yWorks.yFiles.Layout.ComponentLayouter" />
            to place
            the partitions.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.ComponentPartitionPlacer.#ctor">
      <summary>Creates a new instance of this class.</summary>
      <remarks>Creates a new instance of this class.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.ComponentPartitionPlacer.ComponentLayouter">
      <summary>The ComponentLayouter instance used to place the graph partitions.</summary>
      <remarks>Specifies the ComponentLayouter instance used to place the graph partitions.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.ComponentPartitionPlacer.PlacePartitions(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Arranges the graph while taking partition ids and inter-edge information into account.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDDP">the partition id for each node in the graph.</param>
      <param name="interEdgeDP">
            holds a boolean value for each edge of the graph indicating if the
            edge is an inter-edge or not. An inter-edge is an edge that connects nodes that do not
            belong to the same partition.
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder">
      <summary>
            PartitionFinder implementation that uses
            <see cref="M:yWorks.yFiles.Algorithms.Groups.EdgeBetweennessClustering(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,System.Int32,System.Int32,yWorks.yFiles.Algorithms.IDataProvider)" />
            as partition strategy.
            </summary>
      <remarks>
            PartitionFinder implementation that uses
            <see cref="M:yWorks.yFiles.Algorithms.Groups.EdgeBetweennessClustering(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Boolean,System.Int32,System.Int32,yWorks.yFiles.Algorithms.IDataProvider)" />
            as partition strategy.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder.FindPartitions(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns a partition id for each node of an input graph.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDMap">used to return the resulting partition ids</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder.MaximumPartitionCount">
      <summary>The maximum number of partitions that this class should return.</summary>
      <remarks>
            Specifies the maximum number of partitions that this class should return. By default there is no limit
            to the number of returned partitions.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder.MinimumPartitionCount">
      <summary>The minimum number of partitions that this class should return.</summary>
      <remarks>
            Specifies the minimum number of partitions that this class should return.
            By default this value is set to <c>0</c>.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.IInterEdgeRouter">
      <summary>Implementations of this interface are responsible for routing inter-edges.</summary>
      <remarks>
            Implementations of this interface are responsible for routing inter-edges.
            An inter-edge is an edge that connects nodes that do not
            belong to the same partition.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.IInterEdgeRouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Routes inter-edges of the partitioned graph.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDDP">the partition id for each node in the graph.</param>
      <param name="interEdgeDP">
            holds a boolean value for each edge of the graph indicating if the
            edge is an inter-edge or not.
            </param>
      <remarks>Routes inter-edges of the partitioned graph.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.IPartitionFinder">
      <summary>Implementations of this interface are responsible to partition the input graph.</summary>
      <remarks>Implementations of this interface are responsible to partition the input graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.IPartitionFinder.FindPartitions(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Returns a partition id for each node of an input graph.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDMap">used to return the resulting partition ids</param>
      <remarks>
            Returns a partition id for each node of an input graph. Nodes that share a common partition id
            will be considered to belong to the same partition.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.IPartitionPlacer">
      <summary>Implementations of this interface are responsible for arranging the graph partitions.</summary>
      <remarks>
            Implementations of this interface are responsible for arranging the graph partitions. Arranging a
            graph partition usually involves to apply a coordinate translation to all elements belonging to
            the partition in order to generate a non-overlapping node-arrangement.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.IPartitionPlacer.PlacePartitions(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Arranges the graph while taking partition ids and inter-edge information into account.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDDP">the partition id for each node in the graph.</param>
      <param name="interEdgeDP">
            holds a boolean value for each edge of the graph indicating if the
            edge is an inter-edge or not. An inter-edge is an edge that connects nodes that do not
            belong to the same partition.
            </param>
      <remarks>Arranges the graph while taking partition ids and inter-edge information into account.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PartitionLayouter.OrthogonalInterEdgeRouter">
      <summary>
            InterEdgeRouter implementation that routes inter-edges using
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            .
            </summary>
      <remarks>
            InterEdgeRouter implementation that routes inter-edges using
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.OrthogonalInterEdgeRouter.#ctor">
      <summary>Creates a new instance of this class.</summary>
      <remarks>Creates a new instance of this class.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.OrthogonalInterEdgeRouter.OrthogonalEdgeRouter">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            instance used to route inter-edges.
            </summary>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            instance used to route inter-edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PartitionLayouter.OrthogonalInterEdgeRouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Routes inter-edges of the partitioned graph.</summary>
      <param name="graph">the input graph</param>
      <param name="partitionIDDP">the partition id for each node in the graph.</param>
      <param name="interEdgeDP">
            holds a boolean value for each edge of the graph indicating if the
            edge is an inter-edge or not.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.PartitionLayouter.OrthogonalInterEdgeRouter.SelectedEdgesDpKey">
      <summary>
            The <c>DataProvider</c> key to mark edges as
            <em>selected</em>.
            </summary>
      <exception cref="T:System.ArgumentException">if the specified key is <see langword="null" />.</exception>
      <remarks>
            Specifies the <c>DataProvider</c> key to mark edges as
            <em>selected</em>.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedEdgesDpKey" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortCalculator">
      <summary>
            This class implements a LayoutStage that can be used to adjust the final port
            assignments after a layout has been calculated.
            </summary>
      <remarks>
            This class implements a LayoutStage that can be used to adjust the final port
            assignments after a layout has been calculated. This can be useful if the port
            assignment calculated by the layout algorithm is insufficient. This stage uses
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            instances bound to the graph using the keys defined in
            the
            <see cref="T:yWorks.yFiles.Layout.IIntersectionCalculator" />
            interface to calculate the new port offsets.
            For each edge in the <c>LayoutGraph</c> instance the
            <c>DataProvider</c>s are queried for an implementation of the
            <see cref="T:yWorks.yFiles.Layout.IIntersectionCalculator" />
            interface. If the result is non-<see langword="null" />,
            that implementation will be queried and if the result of the query is
            non-<see langword="null" />, the returned point will be applied to the edge layout.
            <p />
            For this layout stage to work use
            <see cref="M:yWorks.yFiles.Layout.CompositeLayoutStage.PrependStage(yWorks.yFiles.Layout.ILayoutStage)" />
            or
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.PrependStage(yWorks.yFiles.Layout.ILayoutStage)" />
            
            to add this layout stage and register appropriate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            
            implementations to the graph using the keys defined in
            <see cref="T:yWorks.yFiles.Layout.IIntersectionCalculator" />
            .
            <p />
            Note, that this class will not change the coordinates of a port if it is
            associated with a strong port constraint.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.#ctor">
      <summary>Creates a new PortCalculator without a core layouter.</summary>
      <remarks>Creates a new PortCalculator without a core layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Creates a new PortCalculator using the given layouter as the core of
            this layout stage.
            </summary>
      <remarks>
            Creates a new PortCalculator using the given layouter as the core of
            this layout stage.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.CalculatePorts(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Performs the actual port calculation on the specified graph instance.</summary>
      <remarks>Performs the actual port calculation on the specified graph instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.PortCalculator.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="F:yWorks.yFiles.Layout.PortCalculator.Eps">
      <summary>
            EPSILON used by
            <see cref="M:yWorks.yFiles.Layout.PortCalculator.EqualsEps(System.Double,System.Double,System.Double,System.Double)" />
            .
            </summary>
      <remarks>
            EPSILON used by
            <see cref="M:yWorks.yFiles.Layout.PortCalculator.EqualsEps(System.Double,System.Double,System.Double,System.Double)" />
            .
            By default this is <c>0.2d</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCalculator.EqualsEps(System.Double,System.Double,System.Double,System.Double)">
      <summary>Callback method that determines whether two points are equal.</summary>
      <remarks>Callback method that determines whether two points are equal.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortCandidate">
      <summary>This class represents a candidate for an edge's ports.</summary>
      <remarks>
            This class represents a candidate for an edge's ports.
            It may be a fixed port, where the exact port coordinates are given or a
            free variant where the coordinates may be chosen arbitrarily. Additionally valid
            in- respectively outgoing directions may be specified for edges connecting to
            that PortCandidate's Port and a cost penalty may be specified that indicates the
            cost associated with the usage of the port.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.#ctor(System.Double,System.Double,System.Boolean,yWorks.yFiles.Layout.PortDirection,System.Double)">
      <summary>Creates a new instance of PortCandidate using the given values.</summary>
      <remarks>
            Creates a new instance of PortCandidate using the given values.
            Clients use the factory methods instead.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.#ctor(System.Double,System.Double,yWorks.yFiles.Layout.PortDirection)">
      <summary>Creates a new instance of PortCandidate using the given values.</summary>
      <remarks>
            Creates a new instance of PortCandidate using the given values.
            Clients use the factory methods instead.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.#ctor(yWorks.yFiles.Layout.PortDirection)">
      <summary>Creates a new instance of PortCandidate using the given direction.</summary>
      <remarks>
            Creates a new instance of PortCandidate using the given direction.
            Clients use the factory methods instead.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.#ctor(yWorks.yFiles.Layout.PortDirection,System.Double)">
      <summary>Creates a new instance of PortCandidate using the given values.</summary>
      <remarks>
            Creates a new instance of PortCandidate using the given values.
            Clients use the factory methods instead.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidate.Cost">
      <summary>The cost associated with the usage of this PortCandidate.</summary>
      <remarks>Returns the cost associated with the usage of this PortCandidate.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.CreateCandidate(System.Double,System.Double,yWorks.yFiles.Layout.PortDirection)">
      <summary>
            Factory method that returns an instance describing a fixed port with zero
            cost penalty for the given direction at the given offsets.
            </summary>
      <param name="directionMask">a bitwise combination of the constants in this class.</param>
      <param name="xOffset">the x offset</param>
      <param name="yOffset">the y offset</param>
      <remarks>
            Factory method that returns an instance describing a fixed port with zero
            cost penalty for the given direction at the given offsets.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.CreateCandidate(System.Double,System.Double,yWorks.yFiles.Layout.PortDirection,System.Double)">
      <summary>
            Factory method that returns an instance describing a fixed port with the given
            cost penalty for the given
            direction at the given offset.
            </summary>
      <param name="directionMask">a bitwise combination of the constants in this class.</param>
      <param name="cost">the cost to associate with the usage of this port</param>
      <param name="xOffset">the x offset</param>
      <param name="yOffset">the y offset</param>
      <remarks>
            Factory method that returns an instance describing a fixed port with the given
            cost penalty for the given
            direction at the given offset.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.CreateCandidate(yWorks.yFiles.Layout.PortConstraint)">
      <summary>
            Factory method that returns an instance describing a non-fixed port with zero
            cost penalty for the direction specified by the given
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" /></summary>
      <param name="fromPortConstraint">the port constraint to obtain the direction from</param>
      <remarks>
            Factory method that returns an instance describing a non-fixed port with zero
            cost penalty for the direction specified by the given
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.CreateCandidate(yWorks.yFiles.Layout.PortDirection)">
      <summary>
            Factory method that returns an instance describing a non-fixed port with 0 cost penalty for the given
            direction.
            </summary>
      <param name="directionMask">a bitwise combination of the constants in this class.</param>
      <remarks>
            Factory method that returns an instance describing a non-fixed port with 0 cost penalty for the given
            direction.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.CreateCandidate(yWorks.yFiles.Layout.PortDirection,System.Double)">
      <summary>
            Factory method that returns an instance describing a non-fixed port with the given
            cost penalty for the given
            direction.
            </summary>
      <param name="directionMask">a bitwise combination of the constants in this class.</param>
      <param name="cost">the cost to associate with the usage of this port</param>
      <remarks>
            Factory method that returns an instance describing a non-fixed port with the given
            cost penalty for the given
            direction.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidate.Direction">
      <summary>The direction mask for this instance.</summary>
      <remarks>Returns the direction mask for this instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.Equals(System.Object)">
      <summary>Tests for equality based on the internal attributes.</summary>
      <remarks>Tests for equality based on the internal attributes.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidate.Fixed">
      <summary>
            Specifies whether this instance describes a fixed or
            <see cref="P:yWorks.yFiles.Layout.PortConstraint.Strong">strong</see>
            port.
            </summary>
      <remarks>
            Returns whether this instance describes a fixed or
            <see cref="P:yWorks.yFiles.Layout.PortConstraint.Strong">strong</see>
            port.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.GetDirectionForLayoutOrientation(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>
            Returns the direction constant with respect to the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </summary>
      <param name="layoutOrientation">the orientation for which the direction should be interpreted.</param>
      <returns>
            the
            <see cref="P:yWorks.yFiles.Layout.PortCandidate.Direction" />
            with respect to the orientation.
            </returns>
      <remarks>
            Returns the direction constant with respect to the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.GetXOffsetForLayoutOrientation(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>
            Yields the X-offset with respect for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </summary>
      <param name="layoutOrientation">The orientation for which to interpret the x offset.</param>
      <returns>The x offset.</returns>
      <remarks>
            Yields the X-offset with respect for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.GetXOffsetForLayoutOrientation(yWorks.yFiles.Layout.LayoutOrientation,yWorks.yFiles.Layout.MirrorMask)">
      <summary>
            Yields the X-offset with respect for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            and
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.MirrorMask" />
            mirror mask}.
            </summary>
      <param name="layoutOrientation">The orientation for which to interpret the x offset.</param>
      <param name="mirrorMask">The mirror mask for which to interpret the x offset.</param>
      <returns>The x offset.</returns>
      <remarks>
            Yields the X-offset with respect for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            and
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.MirrorMask" />
            mirror mask}.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.GetYOffsetForLayoutOrientation(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>
            Yields the Y-offset with respect for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </summary>
      <param name="layoutOrientation">The orientation for which to interpret the x offset.</param>
      <returns>The y offset.</returns>
      <remarks>
            Yields the Y-offset with respect for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.GetYOffsetForLayoutOrientation(yWorks.yFiles.Layout.LayoutOrientation,yWorks.yFiles.Layout.MirrorMask)">
      <summary>
            Yields the Y-offset with respect for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            and
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.MirrorMask" />
            mirror mask}.
            </summary>
      <param name="layoutOrientation">The orientation for which to interpret the y offset.</param>
      <param name="mirrorMask">The mirror mask for which to interpret the y offset.</param>
      <returns>The y offset.</returns>
      <remarks>
            Yields the Y-offset with respect for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            and
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.MirrorMask" />
            mirror mask}.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.IsInDirection(yWorks.yFiles.Layout.PortDirection)">
      <summary>Determines whether this instance lies in the given direction.</summary>
      <param name="directionMask">the mask of directions as defined by the constants in this class.</param>
      <returns>whether this instance specifies on of the given directions</returns>
      <remarks>Determines whether this instance lies in the given direction.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortCandidate.SourcePcListDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key that holds a
            <see cref="T:yWorks.yFiles.Util.ICollection" />
            of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s for the
            source port of each edge.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key that holds a
            <see cref="T:yWorks.yFiles.Util.ICollection" />
            of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s for the
            source port of each edge.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortCandidate.TargetPcListDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key that holds a
            <see cref="T:yWorks.yFiles.Util.ICollection" />
            of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s for the
            target port of each edge.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key that holds a
            <see cref="T:yWorks.yFiles.Util.ICollection" />
            of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s for the
            target port of each edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.ToPortConstraint">
      <summary>
            A utility method for converting this instance to a
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" /></summary>
      <returns>a PortConstraint that matches this PortCandidate</returns>
      <remarks>
            A utility method for converting this instance to a
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.ToPortConstraintForLayoutOrientation(yWorks.yFiles.Layout.LayoutOrientation)">
      <summary>
            A utility method for converting this instance to a
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            interpreted for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </summary>
      <returns>a PortConstraint that matches this PortCandidate</returns>
      <remarks>
            A utility method for converting this instance to a
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            interpreted for the given
            <see cref="P:yWorks.yFiles.Layout.OrientationLayouter.Orientation">layout orientation</see>
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidate.ToString">
      <summary>Returns a human-readable string representation of this PortCandidate.</summary>
      <remarks>Returns a human-readable string representation of this PortCandidate.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidate.XOffset">
      <summary>The x offset of the port with respect to the corresponding node's center.</summary>
      <remarks>Returns the x offset of the port with respect to the corresponding node's center.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidate.YOffset">
      <summary>The y offset of the port with respect to the corresponding node's center.</summary>
      <remarks>Returns the y offset of the port with respect to the corresponding node's center.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortCandidateSet">
      <summary>
            This class describes a set of possible
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s and their cardinality for a node-like entity.
            </summary>
      <remarks>
            This class describes a set of possible
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s and their cardinality for a node-like entity.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.#ctor">
      <summary>Creates a new and empty instance of PortCandidateSet</summary>
      <remarks>Creates a new and empty instance of PortCandidateSet</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.Add(yWorks.yFiles.Layout.PortCandidate)">
      <summary>Adds another PortCandidate with capacity 1 to the set of PortCandidates.</summary>
      <param name="p">the candidate to add.</param>
      <remarks>Adds another PortCandidate with capacity 1 to the set of PortCandidates.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.Add(yWorks.yFiles.Layout.PortCandidate,System.Int32)">
      <summary>Adds another PortCandidate with the given capacity to the set of candidates.</summary>
      <param name="p">the candidate to add</param>
      <param name="connections">the maximum number of connections allowed to the candidate</param>
      <remarks>Adds another PortCandidate with the given capacity to the set of candidates.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidateSet.ConnectionCount">
      <summary>
            The maximum number of connections this set allows or
            <see cref="F:System.Int32.MaxValue" />
            if
            the number is unbound.
            </summary>
      <remarks>
            Returns the maximum number of connections this set allows or
            <see cref="F:System.Int32.MaxValue" />
            if
            the number is unbound.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.CreateMatcher">
      <summary>
            Creates a CandidateMatcher instance that can be used to query
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry">entries</see>
            from.
            </summary>
      <returns>a fresh matching instance that reflects the current state of this set of candidates.</returns>
      <remarks>
            Creates a CandidateMatcher instance that can be used to query
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry">entries</see>
            from.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidateSet.Entries">
      <summary>
            An Iterator over the list of
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry">entries</see>
            .
            </summary>
      <remarks>
            Returns an Iterator over the list of
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry">entries</see>
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.GetCost(yWorks.yFiles.Layout.PortCandidateSet.IEntry,yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Double,System.Double)">
      <summary>Calculates the cost for each entry for the given edge configuration.</summary>
      <remarks>Calculates the cost for each entry for the given edge configuration.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.GetPriority(yWorks.yFiles.Layout.PortCandidateSet.IEntry,yWorks.yFiles.Algorithms.Edge,System.Boolean)">
      <summary>Returns the priority of the given entry.</summary>
      <remarks>
            Returns the priority of the given entry.
            The higher the priority the sooner it will be chosen by the
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher" />
            .
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortCandidateSet.NodeDpKey">
      <summary>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to associate instances of this class with nodes in a graph.
            </summary>
      <remarks>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to associate instances of this class with nodes in a graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.Remove(yWorks.yFiles.Layout.PortCandidateSet.IEntry)">
      <summary>Removes the entry from the internal list of PortCandidate entries.</summary>
      <param name="entry">the entry to remove from this set of candidates.</param>
      <remarks>Removes the entry from the internal list of PortCandidate entries.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher">
      <summary>
            The interface that is used by
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet" />
            to retrieve
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s from.
            </summary>
      <remarks>
            The interface that is used by
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet" />
            to retrieve
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s from.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate">
      <summary>
            Returns an the next best matching
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry" />
            .
            </summary>
      <returns>the next best entry with respect to the costs</returns>
      <remarks>
            Returns an the next best matching
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate(yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Double,System.Double,System.Int32)">
      <summary>
            Returns the next best matching
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry" />
            for the given parameters.
            </summary>
      <param name="edge">the edge that will connect to the port</param>
      <param name="source">whether the edge connects to the node with its source side</param>
      <param name="xOffset">the preferred x offset of the connection point (relative to the node's center)</param>
      <param name="yOffset">the preferred y offset of the connection point (relative to the node's center)</param>
      <param name="directionMask">
            a bitwise combination of the constants defined in
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            indicating the preferred connection points
            </param>
      <returns>the next best entry with respect to the constraints and the costs</returns>
      <remarks>
            Returns the next best matching
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry" />
            for the given parameters.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate(yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Int32)">
      <summary>
            Returns an the next best matching
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry" />
            for the given parameters.
            </summary>
      <param name="edge">the edge that will connect to the port</param>
      <param name="source">whether the edge connects to the node with its source side</param>
      <param name="directionMask">
            a bitwise combination of the constants defined in
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            indicating the preferred connection points
            </param>
      <returns>the next best entry with respect to the constraints and the costs</returns>
      <remarks>
            Returns an the next best matching
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry" />
            for the given parameters.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortCandidateSet.IEntry">
      <summary>
            An interface that is returned by the find methods in
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher" />
            and the
            <see cref="P:yWorks.yFiles.Layout.PortCandidateSet.Entries" />
            method.
            </summary>
      <remarks>
            An interface that is returned by the find methods in
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet.ICandidateMatcher" />
            and the
            <see cref="P:yWorks.yFiles.Layout.PortCandidateSet.Entries" />
            method.
            This interface provides access to the actual
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            and the maximum number of connections
            allowed for that instance.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidateSet.IEntry.Connections">
      <summary>The maximum number of connections allowed for the port candidate.</summary>
      <remarks>Returns the maximum number of connections allowed for the port candidate.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortCandidateSet.IEntry.PortCandidate">
      <summary>The associated PortCandidate.</summary>
      <remarks>Returns the associated PortCandidate.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortConstraint">
      <summary>
            This class represents a constraint for either a source or target port
            of an edge.
            </summary>
      <remarks>
            This class represents a constraint for either a source or target port
            of an edge. Objects of type PortConstraint are expected to be returned by
            data providers that are registered by the keys defined in the
            interface
            <see cref="T:yWorks.yFiles.Layout.PortConstraintKeys" />
            .
            <p />
            A port constraint expresses at what position an edge is allowed
            to connect to either its source or target node.
            A weak port constraint limits the position of the port
            to a particular side of a node.
            Additionally, a strong port constraint fixes the position of the
            port completely to the position of the current port coordinates.
            <p />
            For example, <c>PortConstraint p = PortConstraint.create(PortConstraint.NORTH)</c>
            expresses that an edge should connect at the north side of a node. It is
            a weak constraint.
            On the other hand <c>p = PortConstraint.create(PortConstraint.NORTH, true)</c>
            expresses that an edge should not only connect at the north side of a node
            but also should use the current port coordinates. This is a strong constraint.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.#ctor">
      <summary>
            Creates the empty constraint, that allows ports to connect at any side of a
            node.
            </summary>
      <remarks>
            Creates the empty constraint, that allows ports to connect at any side of a
            node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.#ctor(yWorks.yFiles.Layout.PortSide)">
      <summary>
            Creates the weak constraint, that allows ports to connect to a specific side
            of a node.
            </summary>
      <param name="side">
            weak constraint specifier. One of
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.North" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.South" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.East" />
            or
            <see cref="F:yWorks.yFiles.Layout.PortSide.West" />
            .
            </param>
      <remarks>
            Creates the weak constraint, that allows ports to connect to a specific side
            of a node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.#ctor(yWorks.yFiles.Layout.PortSide,System.Boolean)">
      <summary>
            Creates a constraint, that allows ports to connect to a specific side
            of a node.
            </summary>
      <param name="side">
            weak constraint specifier. One of
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.North" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.South" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.East" />
            or
            <see cref="F:yWorks.yFiles.Layout.PortSide.West" />
            .
            </param>
      <param name="strong">
            whether the layouter should use the current port coordinates
            (strong constraint)
            </param>
      <remarks>
            Creates a constraint, that allows ports to connect to a specific side
            of a node.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.AtAnySide">
      <summary>
            Specifies whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            associated
            with it.
            </summary>
      <remarks>
            Returns whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            associated
            with it.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.AtEast">
      <summary>
            Specifies whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.East" />
            associated
            with it.
            </summary>
      <remarks>
            Returns whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.East" />
            associated
            with it.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.AtNorth">
      <summary>
            Specifies whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.North" />
            associated
            with it.
            </summary>
      <remarks>
            Returns whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.North" />
            associated
            with it.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.AtSouth">
      <summary>
            Specifies whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.South" />
            associated
            with it.
            </summary>
      <remarks>
            Returns whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.South" />
            associated
            with it.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.AtWest">
      <summary>
            Specifies whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.West" />
            associated
            with it.
            </summary>
      <remarks>
            Returns whether or not this port constraint has
            the weak constraint side
            <see cref="F:yWorks.yFiles.Layout.PortSide.West" />
            associated
            with it.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.Create(yWorks.yFiles.Layout.PortSide)">
      <summary>Creates a weak port constraint.</summary>
      <param name="side">
            One of
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.North" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.South" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.East" />
            or
            <see cref="F:yWorks.yFiles.Layout.PortSide.West" />
            .
            </param>
      <remarks>Creates a weak port constraint.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.Create(yWorks.yFiles.Layout.PortSide,System.Boolean)">
      <summary>Creates a port constraint.</summary>
      <param name="side">
            One of
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.North" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.South" />
            ,
            <see cref="F:yWorks.yFiles.Layout.PortSide.East" />
            or
            <see cref="F:yWorks.yFiles.Layout.PortSide.West" />
            .
            </param>
      <param name="strong">defines whether it is a strong or weak PortConstraint.</param>
      <remarks>
            Creates a port constraint. The boolean value defines whether it is a
            strong or weak one.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.Equals(System.Object)">
      <summary>
            Tests for equality based on the strong attribute and the
            side attribute.
            </summary>
      <remarks>
            Tests for equality based on the strong attribute and the
            side attribute.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.GetSPC(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the source port constraint associated with the
            given edge.
            </summary>
      <remarks>
            Returns the source port constraint associated with the
            given edge.
            The data provider key
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
            
            is used to lookup the source port constraint data
            provider in the given graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.GetTPC(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the target port constraint associated with the
            given edge.
            </summary>
      <remarks>
            Returns the target port constraint associated with the
            given edge.
            The data provider key
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
            
            is used to lookup the source port constraint data
            provider in the given graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.HasPC(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns whether or not there are non-trivial
            source or target port constraints associated with the
            given edge.
            </summary>
      <remarks>
            Returns whether or not there are non-trivial
            source or target port constraints associated with the
            given edge.
            The data provider keys
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
            
            and
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
            
            are used to lookup the data providers in the given graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.HasSPC(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns whether or not there is a non-trivial
            source port constraint associated with the
            given edge.
            </summary>
      <remarks>
            Returns whether or not there is a non-trivial
            source port constraint associated with the
            given edge.
            The data provider key
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
            
            is used to lookup the source port constraint data
            provider in the given graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.HasTPC(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns whether or not there is a non-trivial
            target port constraint associated with the
            given edge.
            </summary>
      <remarks>
            Returns whether or not there is a non-trivial
            target port constraint associated with the
            given edge.
            The data provider key
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
            
            is used to lookup the source port constraint data
            provider in the given graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.Side">
      <summary>The side of a node at which a port should connect.</summary>
      <remarks>Returns the side of a node at which a port should connect.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.PortConstraint.Strong">
      <summary>
        <see langword="true" /> if this <c>PortConstraint</c> represents
            a strong constraint and <see langword="false" /> otherwise.
            </summary>
      <remarks>
            Returns <see langword="true" /> if this <c>PortConstraint</c> represents
            a strong constraint and <see langword="false" /> otherwise.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraint.ToString">
      <summary>Returns a string representation of this object.</summary>
      <remarks>Returns a string representation of this object.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortConstraintConfigurator">
      <summary>Provides configuration services for the port constraints of a graph.</summary>
      <remarks>Provides configuration services for the port constraints of a graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintConfigurator.#ctor">
      <summary>Creates a new instance of PortConstraintConfigurator</summary>
      <remarks>Creates a new instance of PortConstraintConfigurator</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintConfigurator.CreatePortConstraintFromSketch(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Boolean)">
      <summary>Creates and returns a port constraint for the given edge.</summary>
      <param name="source">
            if <see langword="true" /> a source port constraint for the given
            edge will be created, otherwise a target port constraint.
            </param>
      <param name="strong">
            if <see langword="true" /> a strong port constraint is created,
            otherwise a weak port constraint is created.
            </param>
      <remarks>
            Creates and returns a port constraint for the given edge.
            The side constraint is setup according to the current drawing of the edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintConfigurator.CreatePortConstraintsFromSketch(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeCursor,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean,yWorks.yFiles.Algorithms.IEdgeMap,System.Boolean)">
      <summary>Creates port constraints for some edges of the given graph.</summary>
      <param name="ec">EdgeCursor that provides access to the edges for which to set port constraints.</param>
      <param name="spcMap">an edge map that will be used to store the source port constraints of the edges.</param>
      <param name="strongSP">whether or not to assign strong source port constraints</param>
      <param name="tpcMap">an edge map that will be used to store the target port constraints of the edges.</param>
      <param name="strongTP">whether or not to assign strong target port constraints</param>
      <remarks>Creates port constraints for some edges of the given graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintConfigurator.CreatePortConstraintsFromSketch(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Creates weak port constraints for all edges of the given graph.</summary>
      <param name="spcMap">an edge map that will be used to store the source port constraints of the edges.</param>
      <param name="tpcMap">an edge map that will be used to store the target port constraints of the edges.</param>
      <remarks>Creates weak port constraints for all edges of the given graph.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortConstraintEnforcementStage">
      <summary>
            This layout stage can be used to enforce that a layout algorithm will not change
            the relative coordinates of ports that are associated with a strong/fixed port constraint.
            </summary>
      <remarks>
            This layout stage can be used to enforce that a layout algorithm will not change
            the relative coordinates of ports that are associated with a strong/fixed port constraint.
            Usage:
            <pre>
            //prepare port constraints
            graph.addDataProvider(PortConstraintKeys.SOURCE_PORT_CONSTRAINT_KEY, createSPCs(graph));
            graph.addDataProvider(PortConstraintKeys.TARGET_PORT_CONSTRAINT_KEY, createTPCs(graph));
            //create layout pipeline
            OrganicLayouter layouter = new OrganicLayouter();
            PortConstraintEnforcementStage stage = new PortConstraintEnforcementStage();
            stage.setCoreLayouter(organic);
            //launch algorithms
            new BufferedLayouter(stage).doLayout(graph);
            </pre>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintEnforcementStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.PortConstraintEnforcementStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.PortConstraintEnforcementStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.PortConstraintEnforcementStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="T:yWorks.yFiles.Layout.PortConstraintKeys">
      <summary>
            This interface defines keys used to associate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">DataProviders</see>
            
            that provide port constraints for all edges of the input graph.
            </summary>
      <remarks>
            This interface defines keys used to associate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider">DataProviders</see>
            
            that provide port constraints for all edges of the input graph.
            The associated DataProvider can return an object of type
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            for an edge.
            <p />
            LayoutAlgorithms implementing this interface indicate that they will
            try to obey the port constraints provided by these keys.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortConstraintKeys.SourceGroupIdDpKey">
      <summary>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides source port
            group information for edges of the input graph.
            </summary>
      <remarks>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides source port
            group information for edges of the input graph.
            The associated DataProvider can return any object or null.
            Edge sharing a source group identifier will share a common bus near the source
            or at a common source node
            if possible.
            null is not interpreted as a group identifier.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey">
      <summary>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides source port
            constraints for edges of the input graph.
            </summary>
      <remarks>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides source port
            constraints for edges of the input graph.
            The associated DataProvider can return an object of type
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            for an edge.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetGroupIdDpKey">
      <summary>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides target port
            group information for edges of the input graph.
            </summary>
      <remarks>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides target port
            group information for edges of the input graph.
            The associated DataProvider can return any object or null.
            Edge sharing a target group identifier will share a common bus near the target
            or at a common target node
            if possible.
            null is not interpreted as a group identifier.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetPortConstraintDpKey">
      <summary>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides target port
            constraints for edges of the input graph.
            </summary>
      <remarks>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides target port
            constraints for edges of the input graph.
            The associated DataProvider can return an object of type
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            for an edge.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortDirection" />
    <member name="F:yWorks.yFiles.Layout.PortDirection.North">
      <summary>Constant indicating a port in the north of a node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.East">
      <summary>Constant indicating a port in the east of a node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.West">
      <summary>Constant indicating a port in the west of a node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.South">
      <summary>Constant indicating a port in the south of a node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.WithTheFlow">
      <summary>
            Constant indicating a port lying in the direction of the main flow of the edge or overall layout.
            The exact direction is domain specific.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.AgainstTheFlow">
      <summary>
            Constant indicating a port lying in the opposite direction of the main flow of the edge or overall layout.
            The exact direction is domain specific.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.LeftInFlow">
      <summary>
            Constant indicating a port lying to the left of the direction of the main flow
            of the edge or overall layout.
            The exact direction is domain specific.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.RightInFlow">
      <summary>
            Constant indicating a port lying in the right of the direction of the main flow
            of the edge or overall layout.
            The exact direction is domain specific.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortDirection.Any">
      <summary>A bitwise combination of all possible direction constants.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.PortSide">
      <summary>Weak constraint specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortSide.Any">
      <summary>
            Weak constraint specifier. Indicates that any side of the
            node will do for the port direction.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortSide.North">
      <summary>
            Weak constraint specifier. Indicates that a port has to connect
            at the north side (i.e. top side) of a node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortSide.South">
      <summary>
            Weak constraint specifier. Indicates that a port has to connect
            at the south side (i.e. bottom side) of a node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortSide.East">
      <summary>
            Weak constraint specifier. Indicates that a port has to connect
            at the east side (i.e. right side) of a node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.PortSide.West">
      <summary>
            Weak constraint specifier. Indicates that a port has to connect
            at the west side (i.e. left side) of a node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.RemoveColinearBendsStage">
      <summary>This LayoutStage removes all collinear bends found in the graph.</summary>
      <remarks>
            This LayoutStage removes all collinear bends found in the graph. The algorithms traverses each edge path from source
            to target and removes for each triple of consecutive collinear bends the middle one.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RemoveColinearBendsStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.RemoveColinearBendsStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.RemoveColinearBendsStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.RemoveColinearBendsStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Removes collinear bends of the edges.</summary>
      <param name="graph">the graph</param>
      <remarks>Removes collinear bends of the edges.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RemoveColinearBendsStage.RemoveStraightOnly">
      <summary>The current state of the remove straight only property.</summary>
      <remarks>
            Getter:<br />
            Returns the current state of the remove straight only property.
            <para />
            Setter:<br />
            Specifies whether the algorithm removes only collinear bends which lie in the middle of their neighbors or all
            collinear bends. In the first case, the angle at the middle bend must be 180 degrees, while in the second case, the
            angle can be either 180 degrees or 0 degree. The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RemoveColinearBendsStage.Scale">
      <summary>The current scale, to which this stage will refer, when checking for collinearity.</summary>
      <remarks>
            Specifies the current scale, to which this stage will refer, when checking for collinearity.
            Default value is 2.0. Which means that values are rounded to the second position after the decimal point.
            If the rounded values of an edge are leading to a collinear bend, this bend will be removed.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel">
      <summary>An rotated edge label model that allows placement of rotated labels at some positions along an edge.</summary>
      <remarks>
            An rotated edge label model that allows placement of rotated labels at some positions along an edge.
            <p>
            It's possible to specify a distance value that controls the distance between the label and edge.
            Furthermore, there's the possibility to mask out* arbitrary edge label candidates. This can either be done by
            specifying predefined candidate masks or by OR-ing allowed label candidates to a user defined mask.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.#ctor">
      <summary>Returns a new instance of RotatedDiscreteEdgeLabelModel.</summary>
      <remarks>
            Returns a new instance of RotatedDiscreteEdgeLabelModel.
            Position mask
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.SixPos" />
            is used to define the allowed positions for
            an edge label.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition)">
      <summary>Returns a new instance of RotatedDiscreteEdgeLabelModel.</summary>
      <param name="candidateMask">Position mask that defines the allowed positions for an edge label.</param>
      <remarks>Returns a new instance of RotatedDiscreteEdgeLabelModel.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.Angle">
      <summary>The angle (measured in radians) of the label model.</summary>
      <remarks>
            Specifies the angle (measured in radians) of the label model.
            The angle is applied in clockwise direction.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.AutoRotationEnabled">
      <summary>
            Specifies whether or not edge labels are automatically rotated
            according to the angle of the corresponding reference edge segment.
            </summary>
      <remarks>
            Specifies whether or not edge labels have to be automatically rotated
            according to the angle of the corresponding reference edge segment.
            <p>
            By default, this feature is enabled.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.CandidateMask">
      <summary>The bit mask specifying the valid positions for edge labels.</summary>
      <remarks>
            Returns the bit mask specifying the valid positions for edge labels.
            <p>
            Defaults to
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.SixPos" />
            .
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given edge label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)" />
            
            method.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.CreatePositionParameter(System.Int32)">
      <summary>Returns a model parameter that encodes the specified position.</summary>
      <param name="position">
            one of
            <ul><li><see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Shead" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Head" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Thead" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Stail" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Tail" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Ttail" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Scenter" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Center" />
            ,</li><li><see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Tcenter" /></li></ul></param>
      <returns>a model parameter that encodes the specified position.</returns>
      <exception cref="T:System.ArgumentException">
            if the specified position is not one
            of the symbolic position constants defined in this class.
            </exception>
      <remarks>Returns a model parameter that encodes the specified position.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.DefaultParameter">
      <summary>A model parameter that encodes the default position of this model's allowed edge label positions.</summary>
      <remarks>
            Returns a model parameter that encodes the default position of this model's allowed edge label positions.
            <p />
            Default positions are (in descending order):
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Center" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Scenter" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Tail" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Stail" />
            </li>
            </ul>
            Descending order means that whenever two or more of the above default positions
            are part of the allowed positions, then the model parameter encodes the one that is listed first.
            <p />
            Note that the model parameter encodes
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Center" />
            when none of the above
            default positions is part of the allowed positions.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.Distance">
      <summary>The distance between the label's box and the edge's path.</summary>
      <remarks>Specifies the distance between the label's box and the edge's path.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Returns a list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate" />
            objects each of which describes
            a valid label position within this model.
            </summary>
      <param name="labelLayout">
            
            The label for which candidates should be generated.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A list of
            <see cref="T:yWorks.yFiles.Layout.EdgeLabelCandidate" />
            objects.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the bounds of the label for the position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <param name="param">
            
            The model parameter that describes the abstract position of the label within
            this model.
            The parameter must have been generated by this model.
            </param>
      <returns>
            
            The bounds of the label.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.DiscreteEdgeLabelPosition)">
      <summary>Returns the coordinates of the upper-left corner of the given label position.</summary>
      <param name="labelSize">The size of the label that should be placed.</param>
      <param name="edgeLayout">The layout of the edge to which the label belongs.</param>
      <param name="sourceNode">The layout of the source node of the label owning edge.</param>
      <param name="targetNode">The layout of the target node of the label owning edge.</param>
      <param name="pos">
            A label position (given by a symbolic position specifier) that is valid in
            this model.
            </param>
      <returns>The coordinates of the upper-left corner of a label position.</returns>
      <remarks>Returns the coordinates of the upper-left corner of the given label position.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.GetPosition(System.Object)">
      <summary>
            Returns the symbolic position specifier that is encoded by the specified
            model parameter.
            </summary>
      <param name="parameter">the model parameter that encodes the position.</param>
      <returns>
            the symbolic position specifier that is encoded by the specified
            model parameter.
            </returns>
      <exception cref="T:System.ArgumentException">
            if the specified model parameter is not
            valid for this model.
            </exception>
      <remarks>
            Returns the symbolic position specifier that is encoded by the specified
            model parameter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.IsParameterValid(System.Object)">
      <summary>
            Checks if the given model parameter encodes an edge label position that is
            valid in this model.
            </summary>
      <param name="parameter">the model parameter to check.</param>
      <returns>
        <see langword="true" /> if the specified object is a valid parameter
            for this model and encodes a valid position according to this model's
            <see cref="P:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.CandidateMask">candidate mask</see>
            ; <see langword="false" /> otherwise.
            </returns>
      <remarks>
            Checks if the given model parameter encodes an edge label position that is
            valid in this model.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelLayoutModel.PositionRelativeToSegment">
      <summary>Specifies whether or not the label position mask should be interpreted relative to the edge segment.</summary>
      <remarks>
            Specifies whether or not the label position mask should be interpreted relative to the edge segment.
            If this value is set to false (default value), the position mask is interpreted in a geometric sense.
            Note: this option is only relevant for non-center positions.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition" />
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Shead">
      <summary>
            Symbolic position specifier.
            Places the label near the source node.
            The label's position is to the left of or above the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Head">
      <summary>
            Symbolic position specifier.
            Places the label near the middle of the edge's path.
            The label's position is to the left of or above the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Thead">
      <summary>
            Symbolic position specifier.
            Places the label near the target node.
            The label's position is to the left of or above the edge's path.
            Places the label near the target node on the "head" side of the edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Stail">
      <summary>
            Symbolic position specifier.
            Places the label near the source node.
            The label's position is to the right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Tail">
      <summary>
            Symbolic position specifier.
            Places the label near the middle of the edge's path.
            The label's position is to the right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Ttail">
      <summary>
            Symbolic position specifier.
            Places the label near the target node.
            The label's position is to the right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Scenter">
      <summary>
            Symbolic position specifier.
            Places the label near the source node directly on the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Center">
      <summary>
            Symbolic position specifier.
            Places the label near the middle of an edge directly on its path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Tcenter">
      <summary>
            Symbolic position specifier.
            Places the label near the target node directly on the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.TwoPos">
      <summary>
            Position mask that constrains allowed positions to the two near the edge's
            end points.
            Namely, these are
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Head" />
            and
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Tail" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Centered">
      <summary>
            Position mask that constrains allowed positions to
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Center" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.SixPos">
      <summary>
            Position mask that constrains allowed positions to a set of six positions on
            the "head" and "tail" sides of an edge.
            Namely, these are
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Shead" />
            ,
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Head" />
            ,
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Thead" />
            ,
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Stail" />
            ,
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Tail" />
            , and
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Ttail" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.ThreeCenter">
      <summary>
            Position mask that constrains allowed positions to a set of three positions
            directly on the edge's path.
            Namely, these are
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Scenter" />
            ,
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Center" />
            , and
            <see cref="F:yWorks.yFiles.Layout.RotatedDiscreteEdgeLabelPosition.Tcenter" />
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel">
      <summary>
            An edge label model that allows placement of labels at a set of continuous positions
            along both sides of an edge or directly on the edge path.
            </summary>
      <remarks>
            An edge label model that allows placement of labels at a set of continuous positions
            along both sides of an edge or directly on the edge path.
            <p>
            The set of positions can be influenced by specifying the density value that controls
            the spacing between adjacent label positions.
            Furthermore, it's possible to specify distance values that control the distance
            between label and edge and between label and nodes.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.RotatedSliderMode)">
      <summary>Returns a new instance of RotatedSliderEdgeLabelModel.</summary>
      <param name="mode">
            Determines which slider mode to use.
            Possible values are
            <see cref="F:yWorks.yFiles.Layout.RotatedSliderMode.Center" />
            ,
            <see cref="F:yWorks.yFiles.Layout.RotatedSliderMode.SingleSide" />
            or
            <see cref="F:yWorks.yFiles.Layout.RotatedSliderMode.Side" />
            .
            </param>
      <remarks>Returns a new instance of RotatedSliderEdgeLabelModel.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.Angle">
      <summary>The angle (measured in radians) of the label model.</summary>
      <remarks>
            Specifies the angle (measured in radians) of the label model.
            The angle is applied in clockwise direction.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.AutoRotationEnabled">
      <summary>
            Specifies whether or not edge labels are automatically rotated according to
            the angle of the corresponding reference edge segment.
            </summary>
      <remarks>
            Specifies whether or not edge labels have to be automatically rotated
            according to the angle of the corresponding reference edge segment.
            <p>
            By default, this feature is enabled.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given edge label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)" />
            
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed edge label positions.
            </summary>
      <remarks>
            Returns a model parameter that encodes the default position of this model's
            allowed edge label positions.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.Distance">
      <summary>The distance between the label's box and the edge's path.</summary>
      <remarks>
            Specifies the distance between the label's box and the edge's path.
            The interpretation of positive/negative values depends on property
            <see cref="P:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.DistanceRelativeToEdge">distanceRelativeToEdge</see>
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.DistanceRelativeToEdge">
      <summary>
            A value indicating whether the distance to the edge is interpreted
            relatively to the edge's path.
            </summary>
      <remarks>
            Specifies a value indicating whether the distance to the edge is interpreted
            relatively to the edge's path. If this value is set, the label is placed
            to the left of the edge segment (relative to the segment direction) if
            <c>distance</c> is less than <c>0</c> and to the right of the
            edge segment if <c>distance</c> is greater than <c>0</c>.
            If this value is not set, the label is placed below the edge segment (in
            geometric sense) if <c>distance</c> ls less than <c>0</c> and
            above the edge segment if <c>distance</c> is greater than
            <c>0</c>.
            <p>
            The default value is <see langword="true" />.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Returns a list of candidate positions for the given edge label.</summary>
      <remarks>
            Returns a list of candidate positions for the given edge label.
            The number of candidates and their respective locations are computed depending
            on the geometries of both label and edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the bounds of the label for the position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <param name="param">
            
            The model parameter that describes the abstract position of the label within
            this model.
            The parameter must have been generated by this model.
            </param>
      <returns>
            
            The bounds of the label.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel.Mode">
      <summary>The model's slider mode.</summary>
      <remarks>Returns the model's slider mode.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.RotatedSliderMode">
      <summary>Symbolic slider mode specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedSliderMode.Center">
      <summary>
            Symbolic slider mode specifier.
            Chooses continuous label positions directly on the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedSliderMode.Side">
      <summary>
            Symbolic slider mode specifier.
            Chooses continuous label positions along both sides of the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RotatedSliderMode.SingleSide">
      <summary>
            Symbolic slider mode specifier.
            Chooses continuous label positions along a side of the edge path.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.RowAlignment">
      <summary>
            Constant which can be used for
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RowAlignment.Leading">
      <summary>
            Constant which can be used for
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)" />
            .
            Rectangles in one row will be aligned with the leading edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RowAlignment.Trailing">
      <summary>
            Constant which can be used for
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)" />
            .
            Rectangles in one row will be aligned to the trailing edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RowAlignment.Justified">
      <summary>
            Constant which can be used for
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)" />
            .
            Rectangles in one row will be justified in the row.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.RowAlignment.Center">
      <summary>
            Constant which can be used for
            <see cref="M:yWorks.yFiles.Layout.LayoutTool.ArrangeRectangleRows(yWorks.yFiles.Util.Geom.Rectangle2D[],yWorks.yFiles.Util.Geom.Rectangle2D,System.Double,yWorks.yFiles.Layout.RowAlignment)" />
            .
            Rectangles in one row will be centered on the row.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SelfLoopLayouter">
      <summary>A layout algorithm that routes the self-loops (reflexive edges) of a graph.</summary>
      <remarks>
            A layout algorithm that routes the self-loops (reflexive edges) of a graph.
            By default, this layouter routes self-loops in an orthogonal fashion.
            It places the self-loop in the least crowded quadrant around a node.
            <p>
            A core layout algorithm can be specified for this class.
            In that case, the performed layout process of this class is subdivided into four
            stages:
            </p>
            <ol>
            <li>Remove all self-loops of the input graph</li>
            <li>Invoke the core layouter on the now self-loops free graph</li>
            <li>Reinsert all formerly removed self-loops of the graph</li>
            <li>Layout the self-loops of the input graph</li>
            </ol>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SelfLoopLayouter.#ctor">
      <summary>Instantiates a new SelfLoopLayouter.</summary>
      <remarks>Instantiates a new SelfLoopLayouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SelfLoopLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Instantiates a new SelfLoopLayouter.</summary>
      <remarks>
            Instantiates a new SelfLoopLayouter. The core layout routine
            will be delegated to the given layouter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SelfLoopLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Whether or not this layouter can layout the given graph.</summary>
      <remarks>
            Whether or not this layouter can layout the given graph.
            Returns true if the core layouter can handle the given graph
            after all of its self-loops (reflexive) edges have been hidden.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SelfLoopLayouter.CornerApproximationPointsCount">
      <summary>The number of points that are used to round the corner of the selfloops.</summary>
      <remarks>
            Specifies the number of points that are used to round the corner of the selfloops. If this value is set to one
            the corners are drawn orthogonal. This value is only considered if style
            <see cref="F:yWorks.yFiles.Layout.SelfloopStyle.Rounded" />
            is used.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SelfLoopLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Lays out the given graph.</summary>
      <remarks>Lays out the given graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SelfLoopLayouter.KeepAllSelfloopLayouts">
      <summary>Specifies whether this algorithm should keep the existing layout of all self-loops.</summary>
      <remarks>
            Specifies whether this algorithm should keep the existing layout of all self-loops.
            If this property is set, the
            <see cref="F:yWorks.yFiles.Layout.SelfLoopLayouter.KeepSelfLoopLayoutDpKey" />
            data provider
            will be ignored.
            No layout for any self-loop will be calculated, instead the existing self-loop
            layout will be moved with its node.
            <br />
            The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.SelfLoopLayouter.KeepSelfLoopLayoutDpKey">
      <summary>
            This
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key can be used to register a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            with the graph to be laid out.
            </summary>
      <remarks>
            This
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key can be used to register a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            with the graph to be laid out. This algorithm will query for each self-loop
            the boolean value from the data provider to determine whether the current layout
            of the self-loop should be kept. I.e., if the <c>DataProvider</c> instance
            obtained from the graph using this key returns <see langword="true" /> for a self-loop,
            that self-loop will not be laid out by this stage but the bends will be moved
            by that stage according to the movement of their node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SelfLoopLayouter.LayoutSelfLoops(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Lays out the self-loops of the given graph.</summary>
      <remarks>
            Lays out the self-loops of the given graph.
            This method will be called after the core layouter has
            laid out the graph and all self-loops have been reinserted
            in the graph again.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SelfLoopLayouter.LayoutStyle">
      <summary>The layout style to be used.</summary>
      <remarks>
            Specifies the layout style to be used. Possible values are
            <see cref="F:yWorks.yFiles.Layout.SelfloopStyle.Orthogonal" />
            (default) and
            <see cref="F:yWorks.yFiles.Layout.SelfloopStyle.Rounded" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SelfLoopLayouter.LineDistance">
      <summary>The distance between two adjacent paths that run in parallel.</summary>
      <remarks>
            Setter:<br />
            Sets the distance between two selfloops incident to the same node. This value is only considered for layout style
            <see cref="F:yWorks.yFiles.Layout.SelfloopStyle.Rounded" />
            .
            <para />
            Getter:<br />
            Returns the distance between two adjacent paths that run in parallel.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SelfLoopLayouter.SmartSelfloopPlacement">
      <summary>Whether or not smart selfloop placement should be enabled.</summary>
      <remarks>
            Whether or not smart selfloop placement should be enabled.
            If this option is enabled, selfloops are placed on one of the four corners of the corresponding node. For the choice of the corner
            the algorithm considers all incident edges.
            Otherwise the selfloops are always placed at the upper left corner of the corresponding node.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.SelfloopStyle">
      <summary>Edge layout style modifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SelfloopStyle.Orthogonal">
      <summary>
            Edge layout style modifier.
            Using this style, selfloops are routed in an orthogonal fashion, i.e., the route consists of an alternating
            sequence of horizontal and vertical line segments.
            This style can be set with method
            <see cref="P:yWorks.yFiles.Layout.SelfLoopLayouter.LayoutStyle" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SelfloopStyle.Rounded">
      <summary>
            Edge layout style modifier.
            Using this style, the routes of selfloops are rounded.
            This style can be set with method
            <see cref="P:yWorks.yFiles.Layout.SelfLoopLayouter.LayoutStyle" />
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SequentialLayouter">
      <summary>
            This Layouter will take several
            <see cref="T:yWorks.yFiles.Layout.ILayouter" />
            implementations and will
            run these layout algorithms one after the other in the order in which they
            were added.
            </summary>
      <remarks>
            This Layouter will take several
            <see cref="T:yWorks.yFiles.Layout.ILayouter" />
            implementations and will
            run these layout algorithms one after the other in the order in which they
            were added.
            <p>
            This class can for example be used to bundle several layout steps and
            handover a single layouter to a
            <see cref="T:yWorks.yFiles.Layout.BufferedLayouter" />
            .
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.SequentialLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.AppendLayouter(yWorks.yFiles.Layout.ILayouter)">
      <summary>Appends the given layouter to the end of the layouter chain.</summary>
      <param name="layouter">the layouter that should be appended to the chain.</param>
      <remarks>Appends the given layouter to the end of the layouter chain.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.AppendLayouters(System.Collections.Generic.ICollection{yWorks.yFiles.Layout.ILayouter})">
      <summary>Appends the specified layouters to the end of the layouter chain.</summary>
      <param name="layouters">the layouters that should be appended to the chain.</param>
      <remarks>Appends the specified layouters to the end of the layouter chain.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true" /> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.ClearLayouterChain">
      <summary>Clears the layouter chain and therefore removes all layouters.</summary>
      <remarks>Clears the layouter chain and therefore removes all layouters.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SequentialLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.SequentialLayouter.Layouters">
      <summary>A list of the layouters that are currently in the layout chain.</summary>
      <remarks>
            Returns a list of the layouters that are currently in the layout chain.
            Sets the given list of layouters as the layouter chain. Note: this will overwrite the current chain.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel">
      <summary>
            An edge label model that allows placement of labels at a set of continuous positions
            along both sides of an edge or directly on the edge path.
            </summary>
      <remarks>
            An edge label model that allows placement of labels at a set of continuous positions
            along both sides of an edge or directly on the edge path.
            <p>
            The set of positions can be influenced by specifying the density value that controls
            the spacing between adjacent label positions.
            Furthermore, it's possible to specify distance values that control the distance
            between label and edge and between label and nodes.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.#ctor(yWorks.yFiles.Layout.SliderMode)">
      <summary>Initializes a new instance of <c>SliderEdgeLabelModel</c>.</summary>
      <param name="mode">
            Determines which slider mode to use.
            Possible values are either
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Center" />
            or
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side" />
            .
            </param>
      <remarks>Initializes a new instance of <c>SliderEdgeLabelModel</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.CreateModelParameter(yWorks.yFiles.Algorithms.Geometry.YOrientedRectangle,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates a model parameter that represents the given edge label context best
            within this model.
            </summary>
      <param name="labelBounds">
            
            The bounds of the label for which a parameter representation is sought.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <returns>
            
            A model parameter that can be passed to the
            <see cref="M:yWorks.yFiles.Layout.IEdgeLabelModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)" />
            
            method.
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.DefaultParameter">
      <summary>
            A model parameter that encodes the default position of this model's
            allowed edge label positions.
            </summary>
      <remarks>
            Returns a model parameter that encodes the default position of this model's
            allowed edge label positions.
            <p />
            The default positions for both slider edge label models are relative to the
            first edge segment, either at the beginning of the segment (
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side" />
            
            model) or at its middle (
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Center" />
            model).
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.Density">
      <summary>The density to generate label candidate positions.</summary>
      <remarks>
            Specifies the density to generate label candidate positions.
            <p>
            A density value of <c>1.0</c> (which is the default) generates the
            most possible candidate positions without overlap.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.GetLabelCandidates(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout)">
      <summary>Returns a list of candidate positions for the given edge label.</summary>
      <remarks>
            Returns a list of candidate positions for the given edge label.
            The number of candidates and their respective locations are computed depending
            on the geometries of both label and edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.GetLabelPlacement(yWorks.yFiles.Algorithms.Geometry.YDimension,yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.INodeLayout,System.Object)">
      <summary>
            Returns the bounds of the label for the position encoded
            by the given model parameter.
            </summary>
      <param name="labelSize">
            
            The size of the label that should be placed.
            </param>
      <param name="edgeLayout">
            
            The layout of the edge to which the label belongs.
            </param>
      <param name="sourceLayout">
            
            The layout of the source node of the label owning edge.
            </param>
      <param name="targetLayout">
            
            The layout of the target node of the label owning edge.
            </param>
      <param name="param">
            
            The model parameter that describes the abstract position of the label within
            this model.
            The parameter must have been generated by this model.
            </param>
      <returns>
            
            The bounds of the label.
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.GetOffsetVec(System.Double,System.Double,System.Double,System.Double,yWorks.yFiles.Layout.SliderRatio)">
      <summary>Returns the offset vector for a given edge label and a given edge segment.</summary>
      <param name="dx">x-coordinates delta for an edge segment.</param>
      <param name="dy">y-coordinates delta for an edge segment.</param>
      <param name="width">The label's width.</param>
      <param name="height">The label's height.</param>
      <param name="labelPosition">
            One of the symbolic ratio specifiers
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Center" />
            ,
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Left" />
            ,
            or
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Right" />
            .
            </param>
      <returns>An offset vector.</returns>
      <remarks>
            Returns the offset vector for a given edge label and a given edge segment.
            The offset vector describes where to move a label candidate such that it keeps
            a certain distance to the edge's path.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.MaximumDistance">
      <summary>
            The maximum distance between the label's bounding box and
            the edge's path.
            </summary>
      <remarks>
            Specifies the maximum distance between the label's bounding box and
            the edge's path.
            <p>
            By default, a maximum distance of <c>1.0</c> is set.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.MinimumDistance">
      <summary>
            The minimum distance between the label's bounding box and
            the edge's path.
            </summary>
      <remarks>
            Specifies the minimum distance between the label's bounding box and
            the edge's path.
            <p>
            By default, a minimum distance of <c>1.0</c> is set.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.Mode">
      <summary>The model's slider mode.</summary>
      <remarks>Returns the model's slider mode.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.NodeBorderDistance">
      <summary>
            The minimal distance between the label's bounding box and a node's
            borders.
            </summary>
      <remarks>
            Specifies the minimal distance between the label's bounding box and a node's
            borders.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.SetDistances(System.Double,System.Double)">
      <summary>
            Sets the minimum and maximum distances between the label's bounding box and
            the edge's path.
            </summary>
      <param name="minDistance">The minimal distance between label and edge.</param>
      <param name="maxDistance">The maximal distance between label and edge.</param>
      <remarks>
            Sets the minimum and maximum distances between the label's bounding box and
            the edge's path.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter">
      <summary>
            Encodes the model parameters for the two slider edge label models specified
            by
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Center" />
            and
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side" />
            .
            </summary>
      <remarks>
            Encodes the model parameters for the two slider edge label models specified
            by
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Center" />
            and
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.#ctor(System.Int32,System.Double,yWorks.yFiles.Algorithms.Geometry.YVector,System.SByte,System.Double)">
      <summary>Returns a new instance of ModelParameter that has the given characteristics.</summary>
      <param name="s">
            
            The index of the edge segment relative to which the label should be placed.
            </param>
      <param name="r">
            
            The label's ratio with respect to the length of the edge segment relative
            to which it should be placed.
            </param>
      <param name="v">
            
            The offset vector between the label and the edge segment relative to which
            it should be placed.
            </param>
      <param name="p">
            
            One of the symbolic ratio specifiers
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Center" />
            ,
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Left" />
            ,
            or
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Right" />
            .
            </param>
      <param name="aRatio">
            
            The label's absolute ratio with respect to the entire length of the edge
            path.
            <br />
            Note that this value is derived from the ratio value.
            </param>
      <remarks>Returns a new instance of ModelParameter that has the given characteristics.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.AbsRatio">
      <summary>
            The label's absolute ratio with respect to the entire length of the
            edge path.
            </summary>
      <remarks>
            Returns the label's absolute ratio with respect to the entire length of the
            edge path.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.LabelPosition">
      <summary>
            The label's symbolic ratio specifier, i.e., one of
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Center" />
            ,
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Left" />
            , or
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Right" />
            .
            </summary>
      <remarks>
            Returns the label's symbolic ratio specifier, i.e., one of
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Center" />
            ,
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Left" />
            , or
            <see cref="F:yWorks.yFiles.Layout.SliderRatio.Right" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.OffsetVector">
      <summary>
            The offset vector between the label and the edge segment relative
            to which it is placed.
            </summary>
      <remarks>
            Returns the offset vector between the label and the edge segment relative
            to which it is placed.
            <p />
            The offset vector describes the distance between the edge segment and the
            label's upper-left corner.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.Ratio">
      <summary>
            The label's ratio with respect to the length of the edge segment
            relative to which it is placed.
            </summary>
      <remarks>
            Returns the label's ratio with respect to the length of the edge segment
            relative to which it is placed.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.SliderEdgeLabelLayoutModel.ModelParameter.SegmentNumber">
      <summary>The index of the edge segment relative to which the label is placed.</summary>
      <remarks>
            Returns the index of the edge segment relative to which the label is placed.
            <p />
            The index is zero-based and starts at the edge's source end.
            Let s denote the number of edge segments.
            Then, a negative index value i denotes the segment with index s + i.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.SliderMode">
      <summary>Symbolic slider mode specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderMode.Center">
      <summary>
            Symbolic slider mode specifier.
            Chooses continuous label positions directly on the edge path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderMode.Side">
      <summary>
            Symbolic slider mode specifier.
            Chooses continuous label positions along the sides of the edge path.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SliderRatio">
      <summary>Symbolic ratio specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderRatio.Center">
      <summary>
            Symbolic ratio specifier.
            Valid only in conjunction with slider mode
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Center" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderRatio.Tail">
      <summary>
            Symbolic ratio specifier.
            Valid only in conjunction with slider mode
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side" />
            .
            Determines a label to be right of or below the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderRatio.Head">
      <summary>
            Symbolic ratio specifier.
            Valid only in conjunction with slider mode
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side" />
            .
            Determines a label to be left of or above the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderRatio.Left">
      <summary>
            Symbolic ratio specifier.
            Valid only in conjunction with slider mode
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side" />
            .
            Determines a label to be left of the edge's path.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SliderRatio.Right">
      <summary>
            Symbolic ratio specifier.
            Valid only in conjunction with slider mode
            <see cref="F:yWorks.yFiles.Layout.SliderMode.Side" />
            .
            Determines a label to be right of the edge's path.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.SubgraphLayouter">
      <summary>
            A layout stage that filters out all graph elements
            that are not part of a subgraph that is induced by
            the selected nodes of the input graph.
            </summary>
      <remarks>
            A layout stage that filters out all graph elements
            that are not part of a subgraph that is induced by
            the selected nodes of the input graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.SubgraphLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.SubgraphLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SubgraphLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.SubgraphLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.SubgraphLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.SubgraphLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.SubgraphLayouter.SubgraphNodesDpKey">
      <summary>
            The <c>DataProvider</c> key which determines the nodes that
            induce the subgraph to be laid out.
            </summary>
      <exception cref="T:System.ArgumentException">if the specified key is <see langword="null" />.</exception>
      <remarks>
            Specifies the <c>DataProvider</c> key which determines the nodes that
            induce the subgraph to be laid out.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedNodesDpKey" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Swimlanes">
      <summary>Helper class for swimlanes.</summary>
      <remarks>Helper class for swimlanes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Swimlanes.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Swimlanes" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Swimlanes.ArrangeSwimlanes(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Calculates an ordering of the swim lanes such that:
            <p />
            1) the number of swim lanes traversed by edges is reduced.
            </summary>
      <param name="graph">the input graph.</param>
      <param name="node2Swimlane">
            a DataProvider assigning an object of class
            <see cref="T:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant" />
            to each node in the
            graph. Two nodes v,w are in the same swim lane if they are assigned to the same swim lane
            representative. After calling this method, method
            <see cref="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.SwimlanePos" />
            returns for each swim lane representative an integer value (&gt;= 0) denoting the optimized
            position of the associated swim lane.
            </param>
      <remarks>
            Calculates an ordering of the swim lanes such that:
            <p />
            1) the number of swim lanes traversed by edges is reduced. 2) the number of swim lanes spanned by group nodes (see
            <see cref="T:yWorks.yFiles.Layout.Grouping.GraphGrouping" />
            ) is reduced. (Note, that a group node can span a swim lane without having a
            descendant in it.)
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Swimlanes.ArrangeSwimlanes(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,System.Int32,yWorks.yFiles.Layout.SwimlanesMode)">
      <summary>
            Calculates an ordering of the swim lanes such that:
            <p />
            1) the number of swim lanes traversed by edges is reduced.
            </summary>
      <param name="graph">the input graph.</param>
      <param name="node2Swimlane">
            a DataProvider assigning an object of class
            <see cref="T:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant" />
            to each node in the
            graph. Two nodes v,w are in the same swim lane if they are assigned to the same swim lane
            representative. After calling this method, method
            <see cref="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.SwimlanePos" />
            returns for each swim lane representative an integer value (&gt;= 0) denoting the optimized
            position of the associated swim lane.
            </param>
      <param name="iterations">the number of iterations performed by the heuristic. The default value is 5.</param>
      <param name="mode">
            swim lane ordering mode specifier. Possible values are
            <see cref="F:yWorks.yFiles.Layout.SwimlanesMode.Mixed" />
            (default),
            <see cref="F:yWorks.yFiles.Layout.SwimlanesMode.OnlyGroups" />
            and
            <see cref="F:yWorks.yFiles.Layout.SwimlanesMode.IgnoreGroups" />
            .
            </param>
      <remarks>
            Calculates an ordering of the swim lanes such that:
            <p />
            1) the number of swim lanes traversed by edges is reduced. 2) the number of swim lanes spanned by group nodes (see
            <see cref="T:yWorks.yFiles.Layout.Grouping.GraphGrouping" />
            ) is reduced. (Note, that a group node can span a swim lane without having a
            descendant in it.)
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant">
      <summary>Class that internally represents a swim lane.</summary>
      <remarks>Class that internally represents a swim lane.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.#ctor(System.Int32,System.Boolean)">
      <summary>Creates a new instance of <c>SwimlaneRepresentant</c>.</summary>
      <param name="swimlanePos">denotes the current position of the represented swim lane.</param>
      <param name="allowRearrangement">
        <see langword="true" /> if the represented swim lane may be rearranged (see
            <see cref="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.AllowRearrangement" />
            )
            </param>
      <remarks>Creates a new instance of <c>SwimlaneRepresentant</c>.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.AllowRearrangement">
      <summary>Specifies whether the represented swim lane can be rearranged.</summary>
      <remarks>
            Specifies whether the represented swim lane can be rearranged.
            <p />
            For all swim lanes with rearrangement set to <see langword="false" />, the relative ordering given by
            <see cref="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.SwimlanePos" />
            is preserved. The remaining swim lanes may be rearranged.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Swimlanes.SwimlaneRepresentant.SwimlanePos">
      <summary>The current position of the represented swim lane.</summary>
      <remarks>Specifies the current position of the represented swim lane.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.SwimlanesMode">
      <summary>Swim lane ordering mode specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SwimlanesMode.IgnoreGroups">
      <summary>
            Swim lane ordering mode specifier. Specifies that node grouping is ignored during the swim lane ordering
            optimization.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SwimlanesMode.OnlyGroups">
      <summary>
            Swim lane ordering mode specifier. Specifies that only node grouping is considered during the swim lane ordering
            optimization.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.SwimlanesMode.Mixed">
      <summary>
            Swim lane ordering mode specifier. Specifies that both node grouping and edge length are considered during the swim
            lane ordering optimization.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Circular.CircularLayouter">
      <summary>Circular style layouter.</summary>
      <remarks>
            Circular style layouter. This layouter either places all nodes on or inside a circle
            or partitions the graph in disjoint node sets each of
            which will be laid out separately. The exact behavior for the layout of these partitions
            can be controlled via
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.PartitionLayoutStyle" />
            . The partition policy
            can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle" />
            .
            The separate partitions themselves
            are arranged using a
            <see cref="T:yWorks.yFiles.Layout.Tree.BalloonLayouter" />
            .
            <p />
            Here is a sample output of the layouter using
            <see cref="F:yWorks.yFiles.Layout.Circular.LayoutStyle.BccCompact" />
            as partition policy
            and
            <see cref="F:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle.Cycle" />
            as layout style for the partitions.
            <p />
            <center><img src="doc-files/y.layout.circular.CircularLayouter.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.CircularLayouter.#ctor">
      <summary>Create a new instance of this layouter.</summary>
      <remarks>
            Create a new instance of this layouter.
            <p />
            The default values are:
            <ul>
            <li>Partition policy:
            <see cref="F:yWorks.yFiles.Layout.Circular.LayoutStyle.BccCompact" />
            </li>
            <li>Partition layout style:
            <see cref="F:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle.Cycle" />
            </li>
            </ul>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.BalloonLayouter">
      <summary>
            The BalloonLayouter used for arranging the partitions
            <p />
            Configuring that layouter has effect upon the partition arrangement
            within the overall layout.
            </summary>
      <remarks>
            Returns the BalloonLayouter used for arranging the partitions
            <p />
            Configuring that layouter has effect upon the partition arrangement
            within the overall layout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.CircularLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Always returns <see langword="true" />.</summary>
      <remarks>Always returns <see langword="true" />.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.CircularLayouter.CircleIdHolderDpKey">
      <summary>Used for publishing the final circle information.</summary>
      <remarks>
            Used for publishing the final circle information.
            If the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            associated to this key is also a
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            , the integer circle id of each node is stored using
            the acceptor's
            <see cref="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetInt(System.Object,System.Int32)">setInt</see>
            method.
            Otherwise, the provider's values should be of type
            <see cref="T:yWorks.yFiles.Algorithms.Util.IIntValueSettable" />
            whose
            <see cref="P:yWorks.yFiles.Algorithms.Util.IIntValueSettable.Value">setValue</see>
            method
            is used to store the integer circle id of each node.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.CircularLayouter.CircularCustomGroupsDpKey">
      <summary>This key is used to identify custom groups.</summary>
      <remarks>This key is used to identify custom groups.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.ConsiderNodeLabels">
      <summary>
            Specifies whether or not node labels are taken into account when calculating
            node positions (thereby preventing possible node/node label or
            node label/node label overlaps).
            </summary>
      <remarks>
            Specifies whether or not node labels are taken into account when calculating
            node positions (thereby preventing possible node/node label or
            node label/node label overlaps).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.CircularLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
      <remarks>
            Calculates a layout for the given graph.
            The given graph will not be copied during the
            layout process and the layout will be
            immediately applied to the given graph.
            This method is not side effect free in the sense that
            the order of edges or nodes in the input graph
            may change during the layout process.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.CircularLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Core layout routine.</summary>
      <remarks>Core layout routine.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.FromSketchMode">
      <summary>
            Specifies whether or not to take the coordinates of the input diagram
            into account when arranging the nodes of the partitions and the partitions themselves.
            </summary>
      <remarks>
            Determines whether or not to take the coordinates of the input diagram
            into account when arranging the nodes of the partitions and the partitions themselves.
            <p />
            If enabled:
            <ul>
            <li>For complex partitions (those consisting of more than one node), the layouter
            tries to keep peripheral nodes and maintain their circular order around the center of the disk/circle.
            Other partitions that connect to this node are moved accordingly, if possible.</li>
            <li>For multiple partitions that connect to the same node, the layouter tries to keep their
            circular order around this node. This only works as expected for
            <see cref="F:yWorks.yFiles.Layout.Circular.LayoutStyle.BccCompact" />
            as partition policy, since otherwise the underlying tree structure is not well defined</li>
            </ul>
            Switching between different partition policies or group layout styles can lead to unexpected results.
            <p />
            By default this feature is disabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle">
      <summary>The global layout style for this layouter.</summary>
      <remarks>
            Specifies the global layout style for this layouter.
            Allowed layout styles are
            <see cref="F:yWorks.yFiles.Layout.Circular.LayoutStyle.SingleCycle" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Circular.LayoutStyle.BccIsolated" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Circular.LayoutStyle.BccCompact" />
            and
            <see cref="F:yWorks.yFiles.Layout.Circular.LayoutStyle.CircularCustomGroups" />
            <p />
            By default
            <see cref="F:yWorks.yFiles.Layout.Circular.LayoutStyle.BccCompact" />
            is used as layout style
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.MaximalDeviationAngle">
      <summary>The maximal deviation angle allowed for an edge.</summary>
      <remarks>
            Specifies the maximal deviation angle allowed for an edge.
            The deviation angle for an edge is the difference between
            its optimal radiation angle away from the parent cycle and its
            actual radiation angle.
            <p />
            By default a maximal deviation angle of 90 degrees is applied.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.PartitionLayoutStyle">
      <summary>The layout style for the arrangement of each partition.</summary>
      <remarks>
            Specifies the layout style for the arrangement of each partition.
            <p />
            Default is
            <see cref="F:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle.Cycle" />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.PlaceChildrenOnCommonRadius">
      <summary>Specifies whether or not, in the underlying tree, the children of a node are placed on a common radius.</summary>
      <remarks>
            Getter:<br />
            Returns whether or not, in the underlying tree, the children of a node are placed on a common radius.
            <para />
            Setter:<br />
            Specifies whether or not, in the underlying tree, the children of a tree node are placed on a common radius.
            Disabling this feature may produce more compact layout results.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.CircularLayouter.SingleCycleLayouter">
      <summary>
            The SingleCycleLayouter used for laying out single node cycles
            <p />
            Configuring that layouter has effects upon single cycle layouts
            </summary>
      <remarks>
            Returns the SingleCycleLayouter used for laying out single node cycles
            <p />
            Configuring that layouter has effects upon single cycle layouts
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Circular.LayoutStyle">
      <summary>Layout style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.LayoutStyle.BccCompact">
      <summary>
            Layout style specifier. In this layout style the nodes within a
            biconnected component of the input graph are treated as separate
            partitions. If a node belongs to more biconnected components,
            it will be assigned to the one that seems to be more suitable.
            <p />
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle" /></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.LayoutStyle.BccIsolated">
      <summary>
            Layout style specifier. In this layout style the nodes within a
            biconnected component of the input graph are treated as separate
            partitions.
            If a node belongs to more biconnected components,
            it will form an isolated partition and will be laid out
            in between all of it's biconnected component cycles.
            <p />
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle" /></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.LayoutStyle.CircularCustomGroups">
      <summary>
            Layout style specifier. In this layout style the user can specify groups that
            will each form a separate partition. To specify groups, a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            with key
            <see cref="F:yWorks.yFiles.Layout.Circular.CircularLayouter.CircularCustomGroupsDpKey" />
            must be registered.
            <p />
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle" /></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.LayoutStyle.SingleCycle">
      <summary>
            Layout style specifier.  In this layout style all nodes of the input graph
            will be put on or inside a single cycle.
            <p />
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.LayoutStyle" /></summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle" />
    <member name="F:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle.Cycle">
      <summary>
            Place each node of a partition on the boundary of a circle.
            <p />
            This style is very fast, but the results may need much space.
            <p />
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.PartitionLayoutStyle" /></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle.Disk">
      <summary>
            Create semi-compact layout for each partition.
            <p />
            This style places nodes in the inside and the border
            of a circle and arranges them in an organic manner, leading to more compact
            layout. Only nodes with connections into other partitions are guaranteed to lie on the boundary of
            the resulting disk.
            This style may come with a performance penalty.
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.PartitionLayoutStyle" /></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Circular.PartitionLayoutStyle.Organic">
      <summary>
            Create most compact layout for each partition.
            <p />
            This style creates an organic circular layout for each partition. Even nodes that connect
            into different partitions may be placed in the inside of the resulting disk.
            This style may come with a performance penalty.
            <p />
            This parameter can be set with
            <see cref="P:yWorks.yFiles.Layout.Circular.CircularLayouter.PartitionLayoutStyle" /></summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Circular.SingleCycleLayouter">
      <summary>A layouter that places the nodes of a graph on a cycle.</summary>
      <remarks>
            A layouter that places the nodes of a graph on a cycle.
            <p />
            Here is an sample output of the layouter with activated automatic radius
            determination.
            <p />
            <center><img src="doc-files/y.layout.circular.SingleCycleLayouter.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Circular.SingleCycleLayouter" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.AutomaticRadius">
      <summary>Specifies whether or not to choose the cycle radius automatically.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not the radius for the layout should be determined
            automatically.
            If enabled a radius will be chosen such that the adjacent nodes on the circle
            will be approximately
            <see cref="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.MinimalNodeDistance" />
            apart.
            If this feature is deactivated the radius specified via
            <see cref="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.FixedRadius" />
            will be applied.
            By default this feature is enabled.
            <para />
            Getter:<br />
            Returns whether or not to choose the cycle radius automatically.
            By default this feature is enabled.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Always returns <see langword="true" />.</summary>
      <remarks>Always returns <see langword="true" />. Yes we can handle anything!</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Core layout routine.</summary>
      <remarks>Core layout routine.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.FixedRadius">
      <summary>
            The fixed radius for the cycle on which the nodes of the graph
            will be placed.
            </summary>
      <remarks>
            Setter:<br />
            Sets a  fixed radius for the cycle on which the nodes of the graph
            will be placed.
            <p />
            The fixed radius is ignored if the automatic radius feature
            is activated.
            Default value is 200.0.
            <para />
            Getter:<br />
            Returns the fixed radius for the cycle on which the nodes of the graph
            will be placed.
            Default value is 200.0.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.FromSketchModeEnabled">
      <summary>
            Specifies whether or not to take the coordinates of the input diagram
            into account when arranging the nodes.
            </summary>
      <remarks>
            Getter:<br />
            Returns whether or not to take the coordinates of the input diagram
            into account when arranging the nodes.
            <para />
            Setter:<br />
            Determines whether or not to take the coordinates of the input diagram
            into account when arranging the nodes of the partition.
            If this features is enabled, the original circular order of peripheral nodes around
            an estimated circle center is preserved.
            <p />
            By default this feature is disabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.InitialAngle">
      <summary>The angle for the first node.</summary>
      <remarks>
            Getter:<br />
            Get the angle for the first node.
            Default value is 0.0
            <para />
            Setter:<br />
            Set the angle for the first node of the sequence.
            The angle is measured in rad and world coordinates, i.e. 0 is east,
            Pi/4 south etc.
            <br />
            Note: This setting is ignored when the SingleCycleLayouter is used in connection with
            <see cref="T:yWorks.yFiles.Layout.Circular.CircularLayouter" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.LastAppliedRadius">
      <summary>The radius last applied by this layouter.</summary>
      <remarks>Returns the radius last applied by this layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.MinimalNodeDistance">
      <summary>
            The distance to keep between the nodes on the cycle
            Default value is 30.0.
            </summary>
      <remarks>
            Setter:<br />
            Sets the minimal distance to keep between the nodes on the cycle
            This feature is ignored if the automatic radius feature
            is deactivated.
            Default value is 30.0.
            <para />
            Getter:<br />
            Returns the distance to keep between the nodes on the cycle
            Default value is 30.0.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.MinimalRadius">
      <summary>The minimal radius for the cycle on which the nodes are placed.</summary>
      <remarks>
            Setter:<br />
            Sets the minimal radius for the cycle on which the nodes are placed.
            This feature is considered if the radius is detected automatically.
            Default value is 5.0.
            <para />
            Getter:<br />
            Returns the minimal radius for the cycle on which the nodes are placed.
            Default value is 5.0.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Circular.SingleCycleLayouter.NodeSequencer">
      <summary>
            The node sequencer used to determine the order of nodes
            around a cycle.
            </summary>
      <remarks>
            Specifies the node sequencer used to determine the order of nodes around
            a cycle.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy" />
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.DoNotSortBySex">
      <summary>Disables sorting the individuals according to their sex.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.FemaleFirst">
      <summary>Places female individuals before their male siblings and partners if possible.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.FemaleAlwaysFirst">
      <summary>Places female individuals before their male siblings and partners.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.MaleFirst">
      <summary>Places female individuals before their male siblings and partners if possible.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.MaleAlwaysFirst">
      <summary>Places female individuals before their male siblings and partners.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter">
      <summary>This class implements a layout algorithm for genealogical data (family trees).</summary>
      <remarks>
            This class implements a layout algorithm for genealogical data (family trees).
            <p>
            To be suitable for this layouter the graphs have to be organized in the following way:
            Individuals as well as their marriage or partnership are represented by nodes, in the following referred to as
            INDI nodes for individuals and FAM nodes for family nodes, corresponding to the INDI and FAM entries in
            Gedcom encoded genealogical data (GEDCOM is a widely used format to store genealogical data, see
            http://www.phpgedview.net/ged551-5.pdf for the most recent specifications).
            </p>
            <p>
            In order to determine whether a node represents an individual or a partnership, the data provider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType" />
            has to be registered, otherwise an
            <see cref="T:System.ArgumentException" />
            will be thrown.
            That data provider should return:
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeMale" />
            for a node representing a male individual.</li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFemale" />
            for a node representing a female individual.</li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFamily" />
            for a node representing a family.</li>
            </ul>
            All other values will be interpreted as if the node represents an individual.
            </p>
            <p>
            A FAM node is linked to the INDI nodes representing husband and wife by ingoing edges and to INDI nodes representing
            the children by outgoing edges. Two nodes of the same type (INDI or FAM) which are linked directly together
            will cause a
            <see cref="T:yWorks.yFiles.Algorithms.InvalidGraphStructureException" />
            exception. A FAM node with more than two parents
            will also cause a
            <see cref="T:yWorks.yFiles.Algorithms.InvalidGraphStructureException" />
            exception.
            </p>
            The layout is calculated basically in two steps:
            <ul>
            <li>The families are laid out by the inner layouter in a compact way: INDI-&gt;FAM&lt;-INDI-&gt;FAM&lt;-INDI</li>
            <li>The relation between these "family groups" and their children and other families are laid out by the top layouter</li>
            </ul>
            The top layouter can be accessed by
            <see cref="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TopLayouter" />
            and
            <see cref="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TopLayouter" />
            .
            By default, an
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter" />
            is used.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.#ctor">
      <summary>Creates a new instance of this</summary>
      <remarks>Creates a new instance of this</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.Alignment">
      <summary>The vertical alignment of the individual nodes</summary>
      <exception cref="T:System.ArgumentException">if the given value is not defined.</exception>
      <remarks>Specifies the vertical alignment of the individual nodes</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true" /> if the given graph can be laid out by this algorithm.</summary>
      <remarks>
            Returns <see langword="true" /> if the given graph can be laid out by this algorithm. Calling <c>doLayout</c>
            with the given graph as it's argument will only succeed if this method returns <see langword="true" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
      <param name="graph">The graph to run the layout on</param>
      <exception cref="T:System.InvalidOperationException">
            If the data provider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType" />
            is not registered
            </exception>
      <exception cref="T:yWorks.yFiles.Algorithms.InvalidGraphStructureException">If a family node has more than two parents, or two nodes of the same type are linked together</exception>
      <remarks>Main layout routine that assigns new layout information to the given graph.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType">
      <summary>
            Data provider key which defines a data provider for nodes which returns a String which defines the type of the
            node as defined in
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFamily" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeMale" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFemale" />
            .
            </summary>
      <remarks>
            Data provider key which defines a data provider for nodes which returns a String which defines the type of the
            node as defined in
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFamily" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeMale" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFemale" />
            .
            Nodes for which <see langword="null" /> is returned will be treated like nodes which represent individuals.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.FamilyNodesAlwaysBelow">
      <summary>Determines whether family/marriage nodes will be placed between the partners or below them.</summary>
      <remarks>Determines whether family/marriage nodes will be placed between the partners or below them.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.OffsetForFamilyNodes">
      <summary>The offset by which a family node will be shifted down if its parents are not direct neighbours.</summary>
      <remarks>Specifies the offset by which a family node will be shifted down if its parents are not direct neighbours.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.PartnerlessBelow">
      <summary>Determines the treatment of individuals who have only children but no partners.</summary>
      <remarks>
            Determines the treatment of individuals who have only children but no partners. If set to true,
            the family node will be placed centered below the individual node. Thus, a direct male inheritance line for
            example will be depicted in a more obvious way.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.SortFamilyMembers">
      <summary>The policy the individuals of a family will be sorted by their sex.</summary>
      <remarks>
            Specifies the policy the individuals of a family will be sorted by their sex. Default is no sorting (
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyMembersSortingPolicy.DoNotSortBySex" />
            ).
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.SpacingBetweenFamilyMembers">
      <summary>The (horizontal) space between two nodes representing members of the same family.</summary>
      <remarks>Specifies the (horizontal) space between two nodes representing members of the same family.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TopLayouter">
      <summary>The layouter which is responsible for the layout between the family groups.</summary>
      <remarks>
            Specifies the layouter which is responsible for the layout between the family groups. If no layouter is set,
            a new instance of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter" />
            is created.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFamily">
      <summary>
            Returned by the DataProvider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType" />
            for nodes which represent a family.
            </summary>
      <remarks>
            Returned by the DataProvider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType" />
            for nodes which represent a family.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeFemale">
      <summary>
            Returned by the DataProvider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType" />
            for nodes which represent a female individual.
            </summary>
      <remarks>
            Returned by the DataProvider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType" />
            for nodes which represent a female individual.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.TypeMale">
      <summary>
            Returned by the DataProvider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType" />
            for nodes which represent a male individual.
            </summary>
      <remarks>
            Returned by the DataProvider
            <see cref="F:yWorks.yFiles.Layout.Genealogy.FamilyTreeLayouter.DpKeyFamilyType" />
            for nodes which represent a male individual.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Genealogy.VerticalNodeAlignment" />
    <member name="F:yWorks.yFiles.Layout.Genealogy.VerticalNodeAlignment.Top" />
    <member name="F:yWorks.yFiles.Layout.Genealogy.VerticalNodeAlignment.Center" />
    <member name="F:yWorks.yFiles.Layout.Genealogy.VerticalNodeAlignment.Bottom" />
    <member name="T:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage">
      <summary>A layout stage for hierarchically grouped graphs.</summary>
      <remarks>
            A layout stage for hierarchically grouped graphs. Activating this stage
            guarantees that a core layouter will keep the relative positions of nodes
            within the same group.
            Also, this stage is responsible for routing edges that connect nodes
            belonging to hierarchically unrelated groups.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.#ctor">
      <summary>Initializes a new instance of <c>FixedGroupLayoutStage</c>.</summary>
      <remarks>Initializes a new instance of <c>FixedGroupLayoutStage</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Initializes a new instance of <c>FixedGroupLayoutStage</c> with the
            given core layouter.
            </summary>
      <param name="core">the core layout algorithm for this stage.</param>
      <remarks>
            Initializes a new instance of <c>FixedGroupLayoutStage</c> with the
            given core layouter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="F:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.FixedGroupNodesDpKey">
      <summary>
            This key can be used to <em>select</em> specific group nodes whose contents
            should keep their relative positions.
            </summary>
      <remarks>
            This key can be used to <em>select</em> specific group nodes whose contents
            should keep their relative positions.
            A group node is considered <em>selected</em> in this context, if the
            corresponding <c>DataProvider</c> returns <see langword="true" /> for
            <b>the node or any of its ancestor (group) nodes</b>.
            <p>
            <b>Note:</b>
            If there is no <c>DataProvider</c> for this key, all group nodes are
            considered <em>selected</em>.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.InterEdgeRoutingStyle">
      <summary>The inter-edge routing style used by this layouter.</summary>
      <remarks>Specifies the inter-edge routing style used by this layouter.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.InterEdgesDpKey">
      <summary>This key is used to mark edges as inter-edges for orthogonal routing.</summary>
      <remarks>
            This key is used to mark edges as inter-edges for orthogonal routing.
            The registered data provider's
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method will return <see langword="true" /> for inter-edges (i.e. edges
            that have to be routed) and <see langword="false" /> for all other edges.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.OrthogonalEdgeRouter">
      <summary>
            The orthogonal edge router instance used to route
            the inter-edges orthogonally.
            </summary>
      <remarks>
            Specifies the orthogonal edge router instance used to route
            the inter-edges orthogonally.
            Inter-edges that have to be routed with the specified routing algorithm
            will be marked using this stage's
            <see cref="F:yWorks.yFiles.Layout.Grouping.FixedGroupLayoutStage.InterEdgesDpKey" />
            data provider
            key.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.GraphGrouping">
      <summary>
            Instances of this class can be used by algorithms to efficiently query the structure
            of such type of graphs.
            </summary>
      <remarks>
            Instances of this class can be used by algorithms to efficiently query the structure
            of such type of graphs. The grouping information is provided through DataProviders,
            whose keys are defined in the GroupingKeys interface.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.#ctor(yWorks.yFiles.Algorithms.Graph)">
      <summary>Creates a new instance of Grouping.</summary>
      <remarks>
            Creates a new instance of Grouping. Grouping instances
            provide a convenient way for all kind of algorithms to traverse the node
            grouping hierarchy. The hierarchy is cached during the call to this constructor.
            It is build using the information bound to the graph using the DataProviders
            that are registered with the graph instance.
            Grouping instances hold a state that with the graph instance that should be
            <see cref="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.Dispose">disposed</see>
            once the grouping instance is not needed anymore.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.CreateInfoMap(yWorks.yFiles.Algorithms.Graph)">
      <summary>Factory method for a NodeMap</summary>
      <remarks>Factory method for a NodeMap</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.Dispose">
      <summary>Disposes the data structures held by this instance.</summary>
      <remarks>
            Disposes the data structures held by this instance.
            Calling this method renders this instance useless.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.DisposeInfoMap(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Factory destructor method for a NodeMap</summary>
      <remarks>Factory destructor method for a NodeMap</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetChildren(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the children of the given group node as a NodeList.</summary>
      <remarks>Returns the children of the given group node as a NodeList.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetDescendants(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns all descendants of the given group node as a NodeList.</summary>
      <param name="parent">
            A group node.
            If <see langword="null" /> is given, the graph's root is used.
            </param>
      <returns>
            A recursively built NodeList containing all descendants of the given group
            node.
            </returns>
      <remarks>Returns all descendants of the given group node as a NodeList.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetEdgesGoingIn(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Convenience method that returns a list of all Edges crossing the group node
            boundary of the given group node in such a way, that there target is inside the
            group node and the source does not lie inside the group node.
            </summary>
      <remarks>
            Convenience method that returns a list of all Edges crossing the group node
            boundary of the given group node in such a way, that there target is inside the
            group node and the source does not lie inside the group node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetEdgesGoingOut(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Convenience method that returns a list of all Edges crossing the group node
            boundary of the given group node in such a way, that there target is outside the
            group node and the source does not lie outside the group node.
            </summary>
      <remarks>
            Convenience method that returns a list of all Edges crossing the group node
            boundary of the given group node in such a way, that there target is outside the
            group node and the source does not lie outside the group node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetNearestCommonAncestor(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the nearest common ancestor in the hierarchy structure.</summary>
      <param name="n1">one of the two nodes whose common ancestor is determined.</param>
      <param name="n2">one of the two nodes whose common ancestor is determined.</param>
      <returns>
            The nearest common ancestor node, or
            <see cref="P:yWorks.yFiles.Layout.Grouping.GraphGrouping.Root" />
            .
            </returns>
      <remarks>
            Returns the nearest common ancestor in the hierarchy structure.
            <p>
            This method returns the nearest ancestor of <c>n1</c> and
            <c>n2</c> that contains both <c>n1</c> and <c>n2</c> or
            it returns
            <see cref="P:yWorks.yFiles.Layout.Grouping.GraphGrouping.Root" />
            if no such node exists.
            In the special cases of <c>n2</c> being a child of <c>n1</c>
            (or vice versa) or if <c>n1 == n2</c>, the parent of <c>n1</c>
            (or <c>n2</c> respectively) is returned.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetParent(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the parent of the given node or <see langword="null" /> if the node
            is at the top of the hierarchy
            </summary>
      <remarks>
            Returns the parent of the given node or <see langword="null" /> if the node
            is at the top of the hierarchy
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.GetRepresentative(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Convenience method that returns a node that can be used to represent
            <c>node</c> in the group <c>inGroup</c>, that is either the node
            itself if it is an immediate child of <c>inGroup</c>, or a node that
            is a child of <c>inGroup</c> and an ancestor of <c>node</c> at the
            same time or <see langword="null" /> if neither of the latter applies.
            </summary>
      <param name="node">the node for which a representative will be returned</param>
      <param name="inGroup">the group to which the representative should belong.</param>
      <remarks>
            Convenience method that returns a node that can be used to represent
            <c>node</c> in the group <c>inGroup</c>, that is either the node
            itself if it is an immediate child of <c>inGroup</c>, or a node that
            is a child of <c>inGroup</c> and an ancestor of <c>node</c> at the
            same time or <see langword="null" /> if neither of the latter applies.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.GraphGrouping.Graph">
      <summary>The Graph instance this object provides information for.</summary>
      <remarks>Returns the Graph instance this object provides information for.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.HasChildren(yWorks.yFiles.Algorithms.Node)">
      <summary>Determines if the given node is a group node with children.</summary>
      <remarks>Determines if the given node is a group node with children.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.Init">
      <summary>Initializes internal data structures.</summary>
      <remarks>
            Initializes internal data structures. The state of the graph at the moment
            of this method invocation will be reflected by this instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.IsFlat(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            A graph is considered to be flat if it is either not grouped
            or there is no group node that contains child nodes present in the graph.
            </summary>
      <remarks>
            A graph is considered to be flat if it is either not grouped
            or there is no group node that contains child nodes present in the graph.
            This method determines whether a graph is flat
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.IsGrouped(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            A graph is considered to be grouped if the three low-level
            grouping data providers
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.GroupDpKey" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.NodeIdDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey" />
            are registered.
            </summary>
      <remarks>
            A graph is considered to be grouped if the three low-level
            grouping data providers
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.GroupDpKey" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.NodeIdDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey" />
            are registered.
            <p />
            An instance of this class requires its graph to be grouped.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.IsGroupNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Determines if the given node is a group node.</summary>
      <remarks>
            Determines if the given node is a group node. Group nodes *may* have children.
            Normal nodes never have children.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GraphGrouping.IsNormalEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>Determines if the given Edge is a normal edge, i.e.</summary>
      <remarks>
            Determines if the given Edge is a normal edge, i.e. whether it does not cross
            any group node boundaries.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.GraphGrouping.LayoutGraph">
      <summary>The LayoutGraph instance this object provides information for.</summary>
      <remarks>
            Returns the LayoutGraph instance this object provides information for.
            <p>This Grouping instance must have been created with a
            <see cref="T:yWorks.yFiles.Layout.LayoutGraph" />
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.GraphGrouping.Root">
      <summary>
            A node instance that can be used as a handle to the virtual root
            of the node hierarchy.
            </summary>
      <remarks>
            Returns a node instance that can be used as a handle to the virtual root
            of the node hierarchy. This handle can be given to the getChildren() method
            to obtain the nodes, that are at the top level of the hierarchy. The instance
            is *not* part of the graph.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.GroupingKeys">
      <summary>
            This interface defines data provider keys for those layout algorithms that can
            handle hierarchically grouped graphs.
            </summary>
      <remarks>
            This interface defines data provider keys for those layout algorithms that can
            handle hierarchically grouped graphs. These keys define the parent-child relationship of nodes within the
            hierarchy and tag nodes that act as group nodes.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.GroupDpKey">
      <summary>This key is used to distinguish normal nodes from group nodes.</summary>
      <remarks>
            This key is used to distinguish normal nodes from group nodes. For every node
            the DataProvider should return true iff the node is a group node (and therefore might
            have children.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.GroupNodeInsetsDpKey">
      <summary>This key is used to provide insets for group nodes.</summary>
      <remarks>
            This key is used to provide insets for group nodes. Insets are used to provide
            space around the contents of a group node. This space can then be used for
            labels and other visual decorations.
            For each group node, a
            <see cref="T:yWorks.yFiles.Util.Geom.Insets" />
            (or a
            <see cref="T:yWorks.yFiles.Util.Geom.Insets" />
            )
            object can be provided using a data provider bound to the graph using this key.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey">
      <summary>This key is used to provide minimum sizes for nodes.</summary>
      <remarks>
            This key is used to provide minimum sizes for nodes.
            For each node, a
            <see cref="T:yWorks.yFiles.Algorithms.Geometry.YDimension" />
            object can be provided using a
            data provider that is bound to the graph with this key.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.NodeIdDpKey">
      <summary>
            This key is used to register a DataProvider instance with a graph, that
            associates each node instance with a unique (based on hashCode() and equals())
            id.
            </summary>
      <remarks>
            This key is used to register a DataProvider instance with a graph, that
            associates each node instance with a unique (based on hashCode() and equals())
            id.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey">
      <summary>This key is used to actually describe the hierarchy of the nodes in the graph.</summary>
      <remarks>
            This key is used to actually describe the hierarchy of the nodes in the graph.
            For each node that is not at the top level of the hierarchy, the id of the containing
            node can be obtained through the data provider associated with this key.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.GroupNodeHider">
      <summary>A layout stage for hierarchically grouped graphs.</summary>
      <remarks>
            A layout stage for hierarchically grouped graphs. Activating this stage
            removes all group nodes and adjacent edges from the graph before
            passing it on to its core layouter.
            After the core layouter has arranged the graph, the hidden elements
            will be reinserted in the graph again.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.#ctor">
      <summary>Creates a new instance of GroupNodeHider</summary>
      <remarks>Creates a new instance of GroupNodeHider</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of GroupNodeHider.</summary>
      <param name="coreLayouter">the core layouter used by this layout stage.</param>
      <remarks>Creates a new instance of GroupNodeHider.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Grouping.GroupNodeHider.GroupBoundsCalculator">
      <summary>The currently installed GroupBoundsCalculator instance</summary>
      <remarks>
            Setter:<br />
            Sets the new GroupBoundsCalculator instance.
            <para />
            Getter:<br />
            Returns the currently installed GroupBoundsCalculator instance
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.HideGroupNodes(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Hides the group nodes and adjacent edges from the graph.</summary>
      <remarks>
            Hides the group nodes and adjacent edges from the graph.
            Furthermore this method removes all grouping related DataProviders from the input graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.GroupNodeHider.HidingEmptyGroupNodes">
      <summary>Specifies whether or not group nodes without children will be hidden.</summary>
      <remarks>
            Specifies whether or not group nodes without children will be hidden.
            Defaults to <see langword="true" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.UnhideGroupNodes(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Unhides group nodes and adjacent edges from the graph that were previously hidden using method
            <see cref="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.HideGroupNodes(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <remarks>
            Unhides group nodes and adjacent edges from the graph that were previously hidden using method
            <see cref="M:yWorks.yFiles.Layout.Grouping.GroupNodeHider.HideGroupNodes(yWorks.yFiles.Layout.LayoutGraph)" />
            . Furthermore this method restores all
            previously removed grouping related DataProviders on the input graph.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.IGroupBoundsCalculator">
      <summary>
            Implementations of this interface are responsible for calculating the bounds
            of a group node during a layout process.
            </summary>
      <remarks>
            Implementations of this interface are responsible for calculating the bounds
            of a group node during a layout process.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IGroupBoundsCalculator.CalculateBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.NodeList)">
      <summary>This method is called during the layout process.</summary>
      <param name="graph">the graph instance for which the bounds will be calculated</param>
      <param name="groupNode">the group node whose bounds will be calculated</param>
      <param name="children">a list of nodes which reside inside the group node</param>
      <returns>a Rectangle2D instance that describes the bounds of the group node.</returns>
      <remarks>
            This method is called during the layout process. It calculates the bounds for
            the given groupNode instance that contains the children.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator">
      <summary>Convenience implementation which allows for custom insets for each group node.</summary>
      <remarks>
            Convenience implementation which allows for custom insets for each group node.
            Insets are provided through a DataProvider which must be registered with the
            graph prior to the invocation of the layout algorithm.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.#ctor">
      <summary>
            Constructs an instance that uses insets provided through the
            data provider registered at the input graph with the public key
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.GroupNodeInsetsDpKey" />
            .
            </summary>
      <remarks>
            Constructs an instance that uses insets provided through the
            data provider registered at the input graph with the public key
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.GroupNodeInsetsDpKey" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.#ctor(System.Object)">
      <summary>Constructs an instance using the given DataProvider key.</summary>
      <remarks>Constructs an instance using the given DataProvider key.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.#ctor(System.Object,yWorks.yFiles.Util.Geom.Insets)">
      <summary>Constructs an instance using the given DataProvider key and default insets.</summary>
      <remarks>Constructs an instance using the given DataProvider key and default insets.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.#ctor(yWorks.yFiles.Util.Geom.Insets)">
      <summary>
            Constructs an instance that uses the specified insets as the default if
            the data provider contains no insets information for a specific node.
            </summary>
      <remarks>
            Constructs an instance that uses the specified insets as the default if
            the data provider contains no insets information for a specific node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.CalculateBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.NodeList)">
      <summary>This method is called during the layout process.</summary>
      <param name="graph">the graph instance for which the bounds will be calculated</param>
      <param name="groupNode">the group node whose bounds will be calculated</param>
      <param name="children">a list of nodes which reside inside the group node</param>
      <returns>a Rectangle2D instance that describes the bounds of the group node.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.ConsiderNodeLabelsEnabled">
      <summary>
            Specifies whether the bounds calculation for group nodes takes labels of the
            group's content nodes into account.
            </summary>
      <remarks>
            Specifies whether the bounds calculation for group nodes should take
            labels of the group's content nodes into account.
            <p>
            Defaults to <see langword="false" />.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.CreateEnlargedBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.NodeList,yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>This method enlarges the given graph bounds by the insets associated with the given group node.</summary>
      <remarks>This method enlarges the given graph bounds by the insets associated with the given group node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.DefaultInsets">
      <summary>The default insets.</summary>
      <remarks>Specifies the default insets.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.GetNodeBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList)">
      <summary>
            Calculates and returns the united bounds of the given nodes only,
            no labels or adjacent edges are considered.
            </summary>
      <remarks>
            Calculates and returns the united bounds of the given nodes only,
            no labels or adjacent edges are considered.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator.GroupNodeInsetsDpKey">
      <summary>The DataProvider key that is used to get the insets for the nodes.</summary>
      <remarks>Specifies the DataProvider key that is used to get the insets for the nodes.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.InterEdgeRoutingStyle">
      <summary>Inter-edge routing style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.InterEdgeRoutingStyle.Adopt">
      <summary>
            Inter-edge routing style specifier. Adopts the edge layout from
            the core layouter.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.InterEdgeRoutingStyle.Orthogonal">
      <summary>Inter-edge routing style specifier. Routes the inter-edges in an orthogonal style.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.InterEdgeRoutingStyle.Straightline">
      <summary>Inter-edge routing style specifier. Routes the inter-edges as a straight line.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter">
      <summary>
            A special component layouter that handles hierarchically grouped graphs
            in a special way.
            </summary>
      <remarks>
            A special component layouter that handles hierarchically grouped graphs
            in a special way. Unlike
            <see cref="T:yWorks.yFiles.Layout.ComponentLayouter" />
            this layout stage allows
            isolated subgraphs within a group to be laid out as a separate component.
            <p />
            The orthogonal group layouter
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter" />
            uses
            this layout stage as component layouter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter.#ctor">
      <summary>Create a new instance of IsolatedGroupComponentLayouter.</summary>
      <remarks>Create a new instance of IsolatedGroupComponentLayouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Create a new instance of IsolatedGroupComponentLayouter.</summary>
      <param name="coreLayouter">
            the core layouter being invoked for each component
            of the graph.
            </param>
      <remarks>Create a new instance of IsolatedGroupComponentLayouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns true, iff the coreLayouter returns true for all components
            of the graph.
            </summary>
      <remarks>
            Returns true, iff the coreLayouter returns true for all components
            of the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculate the layout.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter.FindIsolatedGraphComponents(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Determines which nodes will belong to the same graph component.</summary>
      <remarks>
            Determines which nodes will belong to the same graph component.
            Unlike
            <see cref="T:yWorks.yFiles.Layout.ComponentLayouter" />
            this implementation identifies
            isolated subgraphs within a group also as separate components.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator">
      <summary>
            This subclass of
            <see cref="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator" />
            does not
            only allow custom insets for each group node, but also makes sure to keep provided minimum
            sizes registered for each node that are provided through a DataProvider which must be
            registered with the graph prior to the invocation of the layout algorithm.
            </summary>
      <remarks>
            This subclass of
            <see cref="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator" />
            does not
            only allow custom insets for each group node, but also makes sure to keep provided minimum
            sizes registered for each node that are provided through a DataProvider which must be
            registered with the graph prior to the invocation of the layout algorithm.
            By default
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey" />
            is used as the data provider key, but one can
            also determine another using the according constructor or method
            <see cref="P:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.MinimumNodeSizeDpKey" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.#ctor">
      <summary>
            Constructs an instance that uses the minimum size provided through the data provider registered at the input
            graph with the public key
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey" />
            .
            </summary>
      <remarks>
            Constructs an instance that uses the minimum size provided through the data provider registered at the input
            graph with the public key
            <see cref="F:yWorks.yFiles.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.#ctor(System.Object)">
      <summary>Constructs an instance using the given DataProvider key.</summary>
      <param name="minSizeDataProviderKey">
            a DataProvider key that is used to get the
            minimum sizes for the nodes.
            </param>
      <remarks>Constructs an instance using the given DataProvider key.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.CalculateBounds(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.NodeList)">
      <summary>This method is called during the layout process.</summary>
      <param name="graph">the graph instance for which the bounds will be calculated</param>
      <param name="groupNode">the group node whose bounds will be calculated</param>
      <param name="children">a list of nodes which reside inside the group node</param>
      <returns>a Rectangle2D instance that describes the bounds of the group node.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.DefaultMinimumNodeSize">
      <summary>The default minimum size for nodes.</summary>
      <remarks>
            Specifies the default minimum size for nodes.
            <p>
            By default this is a <c>YDimension</c> with length <c>0</c> and
            width <c>0</c>.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.MinimumNodeSizeDpKey">
      <summary>The DataProvider key that is used to get the minimum sizes for the nodes.</summary>
      <remarks>Specifies the DataProvider key that is used to get the minimum sizes for the nodes.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.XAlignment">
      <summary>
            A value that describes how the node will be resized horizontally if the calculated width
            of
            <see cref="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator" />
            is smaller than
            the minimal width that is provided for the node.
            </summary>
      <remarks>
            Specifies a value that describes how the node will be resized horizontally if the calculated width
            of
            <see cref="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator" />
            is smaller than
            the minimal width that is provided for the node.
            <b>The default value is 0.5</b>, which means the node will grow equally to the left and to the right,
            while the center stays put.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator.YAlignment">
      <summary>
            A value that describes how the node will be resized vertically if the calculated height
            of
            <see cref="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator" />
            is smaller than
            the minimal height that is provided for the node.
            </summary>
      <remarks>
            Specifies a value that describes how the node will be resized vertically if the calculated height
            of
            <see cref="T:yWorks.yFiles.Layout.Grouping.InsetsGroupBoundsCalculator" />
            is smaller than
            the minimal height that is provided for the node.
            <b>The default value is 0.5</b>, which means the node will grow equally upwards and downwards,
            while the center stays put.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Grouping.ParentEdgeAugmentationStage">
      <summary>
            This class can be used as a decorating stage for layout algorithms that
            cannot handle node groups.
            </summary>
      <remarks>
            This class can be used as a decorating stage for layout algorithms that
            cannot handle node groups. Before calling the core layout algorithms, this
            class will augment the graph structure. For each node that belongs to a group,
            a so-called "parent-edge" will be temporarily inserted into the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.ParentEdgeAugmentationStage.#ctor">
      <summary>Creates a new instance of ParentEdgeAugmentationStage</summary>
      <remarks>Creates a new instance of ParentEdgeAugmentationStage</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.ParentEdgeAugmentationStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns true if the core layouter can layout the augmented graph.</summary>
      <remarks>Returns true if the core layouter can layout the augmented graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.ParentEdgeAugmentationStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="T:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter">
      <summary>
            Recursively traverses a hierarchically organized graph in a bottom-up fashion
            and applies the given layout algorithm (i.e.
            </summary>
      <remarks>
            Recursively traverses a hierarchically organized graph in a bottom-up fashion
            and applies the given layout algorithm (i.e. the core layouter) to the contents
            of each group node.
            The size of the group nodes can be further determined by setting a customized
            GroupBoundsCalculator implementation.
            <p>
            Note that this class can be run without a core layouter instance.
            In this case no layout is calculated, instead the group node bounds are merely
            adjusted to fit their respective contents. There are two alternatives for applying different layout styles
            to the contents of group nodes:
            1. Map each group node to the corresponding layouter using data provider key
            <see cref="F:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.GroupNodeLayouterDpKey" />
            .
            The content of the hierarchy root is laid out with the core layouter.
            2. Alternatively you can use a
            <see cref="T:yWorks.yFiles.Layout.LayoutMultiplexer" />
            as core layouter.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.#ctor">
      <summary>Creates a new instance of RecursiveGroupLayouter.</summary>
      <remarks>Creates a new instance of RecursiveGroupLayouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Creates a new instance of RecursiveGroupLayouter using the given layout
            algorithm.
            </summary>
      <remarks>
            Creates a new instance of RecursiveGroupLayouter using the given layout
            algorithm.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.#ctor(yWorks.yFiles.Layout.ILayouter,yWorks.yFiles.Layout.Grouping.IGroupBoundsCalculator)">
      <summary>
            Creates a new instance of RecursiveGroupLayouter using the given layout
            algorithm and GroupBoundsCalculator implementation.
            </summary>
      <remarks>
            Creates a new instance of RecursiveGroupLayouter using the given layout
            algorithm and GroupBoundsCalculator implementation.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.AutoAssignPortCandidates">
      <summary>Specifies whether or not temporary port candidates should be inserted.</summary>
      <remarks>
            Getter:<br />
            Returns whether or not temporary port candidates should be inserted.
            <para />
            Setter:<br />
            Whether or not temporary port candidates should be inserted.
            If this option is enabled the recursive group layouter specifies fixed port candidates for inter-edges
            (edges which traverse the boundary of a group node) at their source and target node.
            Without these port candidates the route of inter-edges always ends at the border/center of the corresponding group node.
            Hence, enabling this option may produce more suitable edge routes if the layout algorithm applied
            to the content of a group node can handle port candidates.
            Note: predefined port candidates are always satisfied, even if this option is disabled (only if the applied layouter supports them).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.ConsiderEmptyGroups">
      <summary>
            Specifies whether or not group nodes without children are handled the same
            way as group nodes with children.
            </summary>
      <remarks>
            Specifies whether or not group nodes without children are handled the same
            way as group nodes with children.
            Defaults to <see langword="true" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.ConsiderSketch">
      <summary>Whether or not to consider the initial coordinates of the graph elements.</summary>
      <remarks>
            Specifies whether or not to consider the initial coordinates of the graph elements.
            This option should be enabled if the recursive group layouter uses a layouter that runs in "from sketch mode".
            If it is enabled, the recursive group layouter sets the coordinates of the node elements to their initial position
            before the corresponding layouter is called.
            By default this option is disabled.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.GroupBoundsCalculator">
      <summary>The currently installed GroupBoundsCalculator instance.</summary>
      <remarks>
            Getter:<br />
            Returns the currently installed GroupBoundsCalculator instance.
            <para />
            Setter:<br />
            Sets a new GroupBoundsCalculator instance that applies to all encountered group
            nodes.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.GroupNodeLayouterDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve a
            <see cref="T:yWorks.yFiles.Layout.ILayouter" />
            instance for each group node.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve a
            <see cref="T:yWorks.yFiles.Layout.ILayouter" />
            instance for each group node. The specified layouter instance is applied to the content of the group node.
            For the top level elements the core layouter is used.
            If the data provider returns "null" the corresponding group node is handled non-recursive, i.e.,
            the group node and its content is laid out with the
            <see cref="T:yWorks.yFiles.Layout.ILayouter" />
            instance specified by the nearest predecessor of the group node (with respect to the grouping hierarchy) which is associated with a layouter.
            If the content of a group node should not be changed, the group node can be associated with a "null" layouter,
            e.g., constant
            <see cref="F:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.NullLayouterField0" />
            .
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.NullLayouterField0">
      <summary>A constant that represents a layouter implementation that does nothing.</summary>
      <remarks>A constant that represents a layouter implementation that does nothing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Grouping.RecursiveGroupLayouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.EdgeList)" />
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer">
      <summary>Abstract base class for the third phase of the Sugiyama algorithm.</summary>
      <remarks>
            Abstract base class for the third phase of the Sugiyama algorithm.
            It assigns the coordinates to the nodes according to the defined
            ranks.
            It provides methods to assign the Y-Coordinates to the nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Overwrite this method to assign the final coordinates to the
            objects of he graph.
            </summary>
      <remarks>
            Overwrite this method to assign the final coordinates to the
            objects of he graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Binds the specified graph to this drawer and
            calls the abstract method
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)" /></summary>
      <remarks>
            Binds the specified graph to this drawer and
            calls the abstract method
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignYCoords(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeCursor[])">
      <summary>
            Assign the y coordinates to the nodes respecting the minimal
            layer distance.
            </summary>
      <remarks>
            Assign the y coordinates to the nodes respecting the minimal
            layer distance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.AssignYCoords(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>
            Assign the y coordinates to the nodes respecting the minimal
            layer distance.
            </summary>
      <remarks>
            Assign the y coordinates to the nodes respecting the minimal
            layer distance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.Dispose">
      <summary>Frees allocated resources after the drawer is finished.</summary>
      <remarks>Frees allocated resources after the drawer is finished.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.distanceToNextNode">
      <summary>
            Stores the minimal distance between the right border of a node and
            the left border of its right hand side neighbor in a layer.
            </summary>
      <remarks>
            Stores the minimal distance between the right border of a node and
            the left border of its right hand side neighbor in a layer.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.dummyMap">
      <summary>
            See
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.DummyMap" /></summary>
      <remarks>
            See
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.DummyMap" />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.DummyMap">
      <summary>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones.
            </summary>
      <remarks>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones. dummy stores the original edge for each dummy node or
            <see langword="null" /> for real nodes.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.edgeLengthKey">
      <summary>The key to the data provider, which stores the length of the edges.</summary>
      <remarks>The key to the data provider, which stores the length of the edges.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.EdgeLengthKey">
      <summary>The key to the data provider, which stores the length of the edges.</summary>
      <remarks>
            Set the key to the data provider, which stores the length of the edges.
            Remark: Edges, which are split in the first phase do no longer supply
            lengths. This should not be to critical as they span at least
            two layers and are so hopefully long enough.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetBottomBorder(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the height of the bottom border of the given node.</summary>
      <remarks>Returns the height of the bottom border of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetBottomHalf(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the height of the border-obeying bottom half of the node,</summary>
      <remarks>Returns the height of the border-obeying bottom half of the node,</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetBottomY(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying bottom y-coordinate of the given node.</summary>
      <remarks>Returns the border obeying bottom y-coordinate of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetDistanceToNextNode(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the minimal distance between the right border of the given node and
            the left border of its right hand side neighbor in the layer.
            </summary>
      <remarks>
            Returns the minimal distance between the right border of the given node and
            the left border of its right hand side neighbor in the layer.
            Node minimal node distances are constructed by using
            the values provided by the data providers that are registered
            with the input graph
            under the keys
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeDistance" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderLeft" />
            and
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderRight" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetFullHeight(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying full height of the given node.</summary>
      <remarks>Returns the border obeying full height of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetFullWidth(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying full width of the given node.</summary>
      <remarks>Returns the border obeying full width of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetLeftBorder(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the width of the left border of the given node.</summary>
      <remarks>Returns the width of the left border of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetLeftHalf(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the width of the border-obeying left half of the node,</summary>
      <remarks>Returns the width of the border-obeying left half of the node,</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetLeftX(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying left x-coordinate of the given node.</summary>
      <remarks>Returns the border obeying left x-coordinate of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetRightBorder(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the width of the right border of the given node.</summary>
      <remarks>Returns the width of the right border of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetRightHalf(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the width of the border-obeying right half of the node,</summary>
      <remarks>Returns the width of the border-obeying right half of the node,</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetRightX(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying right x-coordinate of the given node.</summary>
      <remarks>Returns the border obeying right x-coordinate of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetTopBorder(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the height of the top border of the given node.</summary>
      <remarks>Returns the height of the top border of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetTopHalf(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the height of the border-obeying top half of the node,</summary>
      <remarks>Returns the height of the border-obeying top half of the node,</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.GetTopY(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the border obeying top y-coordinate of the given node.</summary>
      <remarks>Returns the border obeying top y-coordinate of the given node.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.graph">
      <summary>The graph bound to this drawer instance.</summary>
      <remarks>The graph bound to this drawer instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.InitializeDistancesToNextNode(yWorks.yFiles.Algorithms.NodeList[])">
      <summary>
            Initializes the minimal distances between the right border of a node
            and the left border of its right hand side neighbor in a layer.
            </summary>
      <remarks>
            Initializes the minimal distances between the right border of a node
            and the left border of its right hand side neighbor in a layer.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.minimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
      <remarks>The minimal distance between two edges in the same layer.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
      <remarks>Specifies the minimal distance between two edges in the same layer.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.minimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
      <remarks>The minimal distance between two layers.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
      <remarks>Specifies the minimal distance between two layers.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.minimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target in the same layer.</summary>
      <remarks>The minimal distance between two edges sharing source/target in the same layer.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target in the same layer.</summary>
      <remarks>Specifies the minimal distance between two edges sharing source/target in the same layer.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.minimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
      <remarks>The minimal distance between two nodes in the same layer.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AbstractDrawer.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
      <remarks>Specifies the minimal distance between two nodes in the same layer.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlgorithmPhase">
      <summary>Constant describing the first phase of the HierarchicLayouter algorithm.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AlgorithmPhase.Layering">
      <summary>Constant describing the first phase of the HierarchicLayouter algorithm.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AlgorithmPhase.Sequencing">
      <summary>Constant describing the second phase of the HierarchicLayouter algorithm.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer">
      <summary>This class can be used to simply wrap another Drawer implementation.</summary>
      <remarks>
            This class can be used to simply wrap another Drawer implementation.
            It will rearrange nodes within each layer so that they are aligned with
            respect to a given alignment point, that is provided on a per node basis,
            which is provided by a registered
            DataProvider instance that may provide doubles that
            are interpreted as relative
            coordinates to the center of the node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.#ctor(yWorks.yFiles.Layout.Hierarchic.IDrawer)">
      <summary>Creates a new AlignmentDrawer using the given drawer as the actual drawer</summary>
      <remarks>Creates a new AlignmentDrawer using the given drawer as the actual drawer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.AlignNodes(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>Modifies the given drawing by modifying the y-coordinates only</summary>
      <remarks>Modifies the given drawing by modifying the y-coordinates only</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.AssignCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the coordinates to the nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.DummyMap">
      <summary>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target (aka multi-edges) in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.NodeAlignmentPointDpKey">
      <summary>
            The DataProvider key used for the DataProvider instance that provides for
            each node a double depicting the center anchored offset to the
            alignment point.
            </summary>
      <remarks>
            The DataProvider key used for the DataProvider instance that provides for
            each node a double depicting the center anchored offset to the
            alignment point.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.BottomAlignmentDataProvider">
      <summary>Simple utility class that can be registered with the graph to be laid out.</summary>
      <remarks>
            Simple utility class that can be registered with the graph to be laid out.
            Instances of this class will make all nodes bottom-aligned  (for top to bottom layouts).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.BottomAlignmentDataProvider.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.BottomAlignmentDataProvider" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.BottomAlignmentDataProvider.GetDouble(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to double values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.LeftAlignmentDataProvider">
      <summary>Simple utility class that can be registered with the graph to be laid out.</summary>
      <remarks>
            Simple utility class that can be registered with the graph to be laid out.
            Instances of this class will make all nodes left-aligned (for left to right layouts).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.LeftAlignmentDataProvider.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.LeftAlignmentDataProvider" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.LeftAlignmentDataProvider.GetDouble(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to double values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.RightAlignmentDataProvider">
      <summary>Simple utility class that can be registered with the graph to be laid out.</summary>
      <remarks>
            Simple utility class that can be registered with the graph to be laid out.
            Instances of this class will make all nodes right-aligned (for left to right layouts).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.RightAlignmentDataProvider.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.RightAlignmentDataProvider" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.RightAlignmentDataProvider.GetDouble(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to double values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.TopAlignmentDataProvider">
      <summary>Simple utility class that can be registered with the graph to be laid out.</summary>
      <remarks>
            Simple utility class that can be registered with the graph to be laid out.
            Instances of this class will make all nodes top-aligned (for top to bottom layouts).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.TopAlignmentDataProvider.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.TopAlignmentDataProvider" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AlignmentDrawer.TopAlignmentDataProvider.GetDouble(System.Object)">
      <summary>
            Subclasses may override this
            method to provide access to double values.
            </summary>
      <exception cref="T:System.NotSupportedException">unless overwritten.</exception>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer">
      <summary>
            This layerer implementation assigns layers by analyzing already existing
            node coordinates.
            </summary>
      <remarks>
            This layerer implementation assigns layers by analyzing already existing
            node coordinates. Nodes whose bounding boxes intersect a common y-coordinate
            are assigned to the same layer.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.<br /></summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.GetMax(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Callback used to calculate the lower (max) value of a node.</summary>
      <remarks>Callback used to calculate the lower (max) value of a node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.GetMin(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Callback used to calculate the upper (min) value of a node.</summary>
      <remarks>Callback used to calculate the upper (min) value of a node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.MaximumNodeSize">
      <summary>The maximum size of a node that is used to calculate layer overlaps.</summary>
      <exception cref="T:System.ArgumentException">
            if the specified value is less than
            <c>0</c>.
            </exception>
      <remarks>
            Specifies the maximum size of a node that is used to calculate layer overlaps.
            This can be used for more fuzzy layering.
            The default is <c>Double.MAX_VALUE</c> which results in no
            restriction being set.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.MinimumNodeSize">
      <summary>The minimum size of a node that is used to calculate layer overlaps.</summary>
      <exception cref="T:System.ArgumentException">
            if the specified value is less than
            <c>0</c>.
            </exception>
      <remarks>
            Specifies the minimum size of a node that is used to calculate layer overlaps.
            This can be used for more fuzzy layering.
            The default is <c>0.0d</c> which results in no
            restriction being set.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.NodeHalo">
      <summary>
            The size of the halo around a node or the insets respectively that are
            used to calculate layer overlaps.
            </summary>
      <remarks>
            Setter:<br />
            Sets the size of the halo around a node or the insets respectively that are
            used to calculate layer overlaps.
            This can be used for more fuzzy layering.
            <para />
            Getter:<br />
            Gets the size of the halo around a node or the insets respectively that are
            used to calculate layer overlaps.
            The default is <c>0.0d</c> which results in no modification
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer.NodeScalingFactor">
      <summary>The scaling factor that is used to scale the nodes' height.</summary>
      <exception cref="T:System.ArgumentException">
            if the specified value is less than
            <c>0</c>.
            </exception>
      <remarks>
            Specifies the scaling factor that is used to scale the nodes' height.
            Nodes are being scaled from their center.
            This can be used for more fuzzy layering.
            The default is <c>1.0d</c> which results in no scaling.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.BFSLayerer">
      <summary>Layerer that uses a breadth first search to assign layers to the nodes.</summary>
      <remarks>
            Layerer that uses a breadth first search to assign layers to the nodes.
            The nodes of the first layer can be freely chosen (see
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.BFSLayerer.CoreNodesDpKey" />
            ).
            The nodes belonging to a subsequent layer are determined as follows:
            Add all yet unassigned nodes to the new layer that are connected to nodes
            already assigned.
            <p />
            As a consequence all connected nodes will be at most one layer apart.
            Also, edges between nodes that belong to the same layer are possible.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.BFSLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.BFSLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.BFSLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.BFSLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="graph">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
      <remarks>This method assigns the nodes in the graph to layers.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.BFSLayerer.CoreNodesDpKey">
      <summary>
            The data provider key used to look up the core nodes
            of the bfs layering.
            </summary>
      <remarks>
            The data provider key used to look up the core nodes
            of the bfs layering.
            The BFSLayerer will try to retrieve a
            data provider from the graph to be layered with this key.
            The looked up data provider should provide boolean values
            for the nodes of that graph. The boolean value signals
            whether a node is to be placed in the first layer or not.
            <p />If the are no nodes marked as core nodes then nodes with
            indegree 0 are considered to be core nodes.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer">
      <summary>This class implements the second phase of the Sugiyama algorithm.</summary>
      <remarks>
            This class implements the second phase of the Sugiyama algorithm.
            It minimizes the crossings in the diagram by using either the
            barycentric or median heuristic.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.#ctor">
      <summary>Instantiates a new layer sequencer.</summary>
      <remarks>Instantiates a new layer sequencer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.AdoptValues(yWorks.yFiles.Layout.Hierarchic.ILayerSequencer)">
      <summary>Tries to adopt/copy the settings of the given LayerSequencer to this sequencer.</summary>
      <remarks>Tries to adopt/copy the settings of the given LayerSequencer to this sequencer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.GetLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Calculates the sequence of nodes within each layer.</summary>
      <param name="g">the graph being acted upon</param>
      <param name="layerID">
            provides for each node an integral number signifying the layer
            of that node. The first layer has the number 0.
            </param>
      <param name="maxLayer">the number of different layers</param>
      <returns>
            an array of length maxLayer containing node lists. Each node list
            contains the nodes of a corresponding layer. The order of the nodes
            within each node list represents the sequence of the nodes within their layer.
            </returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.GroupDpKey">
      <summary>
            This is the key, which must be used to register the DataProvider
            which contains the mappings between nodes and group ids.
            </summary>
      <remarks>
            This is the key, which must be used to register the DataProvider
            which contains the mappings between nodes and group ids. Group ids
            are integer objects, containing unique group numbers or null, if the
            node belongs to no specific group.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.MaximalDuration">
      <summary>The proposed maximal duration for the calculation of the sequence.</summary>
      <remarks>
            Setter:<br />
            Sets the maximum amount of time granted for
            this sequencer per execution.
            <para />
            Getter:<br />
            Returns the proposed maximal duration for the calculation of the sequence.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.RandomizationRounds">
      <summary>
            The number of randomized rounds this algorithm will try
            if there was no optimal solution.
            </summary>
      <remarks>
            Getter:<br />
            Returns the number of randomized rounds this algorithm will try
            if there was no optimal solution.
            <para />
            Setter:<br />
            Sets the number of additional rounds the algorithm will restart with randomized
            solutions as long as there might be a better solution to the current best.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.RecentCrossingNumber">
      <summary>
            The number of edge crossings that were
            produced by this sequencer the last time it was
            applied to a graph.
            </summary>
      <remarks>
            Returns the number of edge crossings that were
            produced by this sequencer the last time it was
            applied to a graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.RemoveFalseCrossings">
      <summary>Specifies whether or not to remove false crossings.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to remove so-called false crossings
            in an additional phase. A false crossing is a crossing
            between two edges that share a common terminal node.
            <p />
            By default this feature is active.
            <para />
            Getter:<br />
            Returns whether or not to remove false crossings.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.UseTransposition">
      <summary>
            Specifies whether or not the transposition heuristic should
            be used.
            </summary>
      <remarks>
            Setter:<br />
            Specifies whether or not an additional crossing minimization heuristic
            should be used. Activating this heuristic can reduce the overall
            number of edge crossings. On the other hand its activation
            increases running time.
            <p />
            By default the transposition rule is active.
            <para />
            Getter:<br />
            Returns whether or not the transposition heuristic should
            be used.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.UsingGroups">
      <summary>
            Specifies whether or not the layerer will preserve the groupings of
            nodes between each layer.
            </summary>
      <remarks>
            Specifies whether or not the layerer will preserve the groupings of
            nodes between each layer.
            Preserving groupings means nodes having the same integer group number will
            be placed directly next to each other within each layer.
            <p>
            Defaults to <see langword="false" />.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ClassicLayerSequencer.WeightHeuristic">
      <summary>The currently set weight heuristic.</summary>
      <remarks>
            Setter:<br />
            Sets the weight heuristic to be used.
            By default
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.WeightHeuristic.Barycenter" />
            is set.
            <para />
            Getter:<br />
            Returns the currently set weight heuristic.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ComponentArrangementPolicy">
      <summary>
            Component arrangement constant that can be used in
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.ComponentArrangementPolicy" />
            }.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.ComponentArrangementPolicy.Compact">
      <summary>
            Component arrangement constant that can be used in
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.ComponentArrangementPolicy" />
            }.
            If the graph consists of multiple components this constant specifies that, after layering the single components with
            the core layerer, the components will all be merged such that an 1:1 aspect ratio is fulfilled best.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.ComponentArrangementPolicy.Topmost">
      <summary>
            Component arrangement constant that can be used in
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.ComponentArrangementPolicy" />
            }.
            If the graph consists of multiple components this constant specifies that, after layering the single components with
            the core layerer, the components are aligned with their topmost layer.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer">
      <summary>Layerer implementation that uses relative and absolute layering constraints.</summary>
      <remarks>
            Layerer implementation that uses relative and absolute layering constraints. <p> This layerer can use two sets of
            constraints: <ul> <li>Absolute constraints, i.e. place nodes at the top or bottom layer</li> <li>Relative
            constraints, i.e. place a node above, below or in the same layer as another node</li> </ul> Constraints for a given
            graph can be created with means of a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory" />
            instance, which should be created
            with
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.CreateConstraintFactory(yWorks.yFiles.Algorithms.Graph)" />
            for a given graph instance. </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.#ctor(yWorks.yFiles.Layout.Hierarchic.ILayerer)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.AllowSameLayerEdges">
      <summary>Specifies whether same layer edges can be created by this layerer instance.</summary>
      <remarks>
            Specifies whether same layer edges can be created by this layerer instance. <p /> This only concerns edges between nodes
            that have no hard constraints that will force a same layer edge (i.e. a same layer constraint).
            <p>
            Default value is <see langword="false" />.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
      <exception cref="T:System.ArgumentException">if any strong constraints are inconsistent</exception>
      <remarks>This method assigns the nodes in the graph to layers.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.CheckConstraints">
      <summary>Checks if the current set of strong constraints is consistent (i.e.</summary>
      <exception cref="T:System.ArgumentException">if the constraint network is inconsistent</exception>
      <remarks>Checks if the current set of strong constraints is consistent (i.e. has no cycles)</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.CoreLayerer">
      <summary>The core layerer for this layerer instance.</summary>
      <remarks>
            Specifies the core layerer for this layerer instance. <p /> The ConstraintLayerer tries to create a layering for the
            nodes and edges that have no constraints that resembles the layering that would be created by the coreLayerer. This
            works the better the less constraints exist. Ideally, the constrained nodes are just embedded into the layering
            created by the coreLayerer. By default, an instance of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer" />
            is used.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.CreateConstraintFactory(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Create an instance of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory" />
            that is suitable for this
            layerer implementation.
            </summary>
      <param name="g">the current graph for the layerer</param>
      <returns>a ConstraintFactory bound to this graph.</returns>
      <remarks>
            Create an instance of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory" />
            that is suitable for this
            layerer implementation.
            The ConstraintFactory instance is usually bound to the graph instance <c>g</c>, i.e. if the input graph for the
            layerer changes, a new ConstraintFactory instance must be retrieved. This instance can be used to create
            constraints for this graph instance.
            <p>
            You can create a ConstraintFactory without binding it to a graph instance initially by passing a <see langword="null" />
            parameter. In that case, you <b>must</b> bind the returned instance to the graph instance before calculating a layering:
            <pre>
            ConstraintFactory cf = ConstraintLayerer.createConstraintFactory(null);
            ...
            Graph g = ...;
            g.addDataProvider(ConstraintFactory.LAYER_CONSTRAINTS_MEMENTO_DPKEY,
            DataProviders.createConstantDataProvider(cf.getMemento())););
            //Calculate layout
            </pre>
            </p>
            If you manually registered a DataProvider under
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.NodeIdDpKey" />
            on the graph, you must use the corresponding node ids stored in this DataProvider as arguments for
            all methods that create a constraint. Otherwise, you can just use the node instances themselves.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.EdgeWeightsDpKey">
      <summary>DataProvider key for additional edge weights of type <c>int</c>.</summary>
      <remarks>
            DataProvider key for additional edge weights of type <c>int</c>.
            The Layerer tries to keep edges with higher weights short.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.LayerConstraintsMementoDpKey">
      <summary>
        <c>DataProvider</c> key to store the constraints.</summary>
      <remarks>
        <c>DataProvider</c> key to store the constraints.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory">
      <summary>
            Interface specification for classes that can create suitable constraints for a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer" />
            instance.
            </summary>
      <remarks>
            Interface specification for classes that can create suitable constraints for a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer" />
            instance.
            If you manually register a DataProvider under
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.NodeIdDpKey" />
            on the graph, you must use the corresponding node ids stored in this DataProvider as arguments for
            all methods that create a constraint. Otherwise, you can just use the node instances themselves.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object)">
      <summary>Add a constraint that forces the node <c>above</c> to lie above the node <c>reference</c>.</summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="aboveId">the id of the node that should lie above</param>
      <remarks>Add a constraint that forces the node <c>above</c> to lie above the node <c>reference</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object,System.Int32)">
      <summary>
            Add a constraint that forces the node with id <c>above</c> to lie at least <c>minDistance</c> layers above
            the node with id <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="aboveId">the id of the node that should lie above</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
      <remarks>
            Add a constraint that forces the node with id <c>above</c> to lie at least <c>minDistance</c> layers above
            the node with id <c>reference</c>.
            The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
            layer difference may be smaller than <c>minDistance</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object,System.Int32,System.Int32)">
      <summary>
            Add a constraint that forces the node  with id <c>above</c> to lie at least <c>minDistance</c> layers above
            the node  with id <c>reference</c> with a given weight penalty for larger  layer differences.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="aboveId">the id of the node that should lie above</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
      <remarks>
            Add a constraint that forces the node  with id <c>above</c> to lie at least <c>minDistance</c> layers above
            the node  with id <c>reference</c> with a given weight penalty for larger  layer differences.
            The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
            layer difference may be smaller than <c>minDistance</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeAtBottomConstraint(System.Object)">
      <summary>Add a constraint that places a node in the bottom layer</summary>
      <param name="nodeId">the id of the node that should lie at the bottom</param>
      <remarks>Add a constraint that places a node in the bottom layer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeAtTopConstraint(System.Object)">
      <summary>Add a constraint that places a node in the topmost layer</summary>
      <param name="nodeId">the id of the node that should lie at the top</param>
      <remarks>Add a constraint that places a node in the topmost layer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object)">
      <summary>Add a constraint that forces the node with id with id <c>below</c> to lie below the node with id <c>reference</c>.</summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="belowId">the id of the node that should lie below</param>
      <remarks>Add a constraint that forces the node with id with id <c>below</c> to lie below the node with id <c>reference</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object,System.Int32)">
      <summary>
            Add a constraint that forces the node with id <c>below</c> to lie at least <c>minDistance</c> layers below
            the node with id <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="belowId">the id of the node that should lie below</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
      <remarks>
            Add a constraint that forces the node with id <c>below</c> to lie at least <c>minDistance</c> layers below
            the node with id <c>reference</c>.
            The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
            layer difference may be smaller than <c>minDistance</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object,System.Int32,System.Int32)">
      <summary>
            Add a constraint that forces the node with id <c>below</c> to lie at least <c>minDistance</c> layers below
            the node with id <c>reference</c> with a given weight penalty for larger layer differences.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="belowId">the id of the node that should lie below</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
      <remarks>
            Add a constraint that forces the node with id <c>below</c> to lie at least <c>minDistance</c> layers below
            the node with id <c>reference</c> with a given weight penalty for larger layer differences.
            The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
            layer difference may be smaller than <c>minDistance</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.AddPlaceNodeInSameLayerConstraint(System.Object,System.Object)">
      <summary>
            Add a constraint that forces the node with id <c>sameLayer</c> to lie in the same layer as the node with id
            <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="sameLayerId">the id of the node that should lie in the same layer</param>
      <remarks>
            Add a constraint that forces the node with id <c>sameLayer</c> to lie in the same layer as the node with id
            <c>reference</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.Dispose">
      <summary>Disposes the ConstraintFactory.</summary>
      <remarks>
            Disposes the ConstraintFactory. <p> This method should be called when the factory is not needed anymore, i.e.
            after the layout has been calculated. Calling this method also clears all constraints. </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.Memento">
      <summary>A token that allows to bind a constraint factory to a graph instance after creation.</summary>
      <remarks>
            Get a token that allows to bind a constraint factory to a graph instance after creation.
            This method should only be used if the constraint factory is not bound to a graph instance initially. It allows
            to bind the ConstraintFactory to a graph instance after creation. Please see the factory methods that create
            instances of this interface for a description.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer.IConstraintFactory.RemoveConstraints(System.Object)">
      <summary>Clears all constraints for a given node</summary>
      <param name="nodeId">the id of the node for which all constraints should be cleared</param>
      <remarks>Clears all constraints for a given node</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.DrawerKeys" />
    <member name="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderBottom">
      <summary>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph.
            </summary>
      <remarks>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph. The provided value is an additional overlap-free
            border added to the bottom side of the associated node.
            <p />
            Drawer implementations may ignore the data provided.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderLeft">
      <summary>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph.
            </summary>
      <remarks>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph. The provided value is an additional overlap-free
            border added to the left side of the associated node.
            <p />
            Drawer implementations may ignore the data provided.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderRight">
      <summary>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph.
            </summary>
      <remarks>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph. The provided value is an additional overlap-free
            border added to the right side of the associated node.
            <p />
            Drawer implementations may ignore the data provided.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderTop">
      <summary>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph.
            </summary>
      <remarks>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph. The provided value is an additional overlap-free
            border added to the top side of the associated node.
            <p />
            Drawer implementations may ignore the data provided.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeDistance">
      <summary>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph.
            </summary>
      <remarks>
            The key used to look up a data provider that,
            if present, must provide a double value for each node in
            the graph. The provided value specifies the minimum distance
            between the right border of the node and the left border of its right-hand
            neighbor in the layer.
            <p />
            If a data provider with this key is registered with the input graph then the
            distance values set by the methods
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalNodeDistance" />
            ,
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalEdgeDistance" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalMultiEdgeDistance" />
            will be ignored.
            <p />
            Drawer implementations may ignore the data provided.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.EdgeReverser">
      <summary>Helper that reverses edges that are oriented in the wrong direction.</summary>
      <remarks>Helper that reverses edges that are oriented in the wrong direction.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.EdgeReverser.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.EdgeReverser" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.EdgeReverser.ReverseEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Reverses the edges contained ion the given edge list</summary>
      <param name="g">the graph containing the edges in edgeList</param>
      <param name="edgeList">contains to be reversed edges.</param>
      <remarks>Reverses the edges contained ion the given edge list</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.EdgeReverser.ReverseUpwardEdges(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>
            Reverses edges in the given graph whose source node has a
            larger layer ID than the target node.
            </summary>
      <param name="g">target graph</param>
      <param name="layerMap">node map that contains a layer ID for each node</param>
      <returns>a list of edges that have been reversed</returns>
      <remarks>
            Reverses edges in the given graph whose source node has a
            larger layer ID than the target node.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer">
      <summary>This layerer implementation layers the nodes by given layer IDs.</summary>
      <remarks>
            This layerer implementation layers the nodes by given layer IDs.
            The layer IDs are given by a DataProvider that returns the integral
            layer ID of each node in the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>
            Assigns layers to the graph that were given by the
            DataProvider <c>g.getDataProvider(LAYER_ID_KEY)</c>.
            </summary>
      <remarks>
            Assigns layers to the graph that were given by the
            DataProvider <c>g.getDataProvider(LAYER_ID_KEY)</c>.
            The returned layerMap will be  a normalized variant of
            the user given data provider. A normalized variant has
            no empty layers and a minimum layerID 0.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.LayerIdDpKey">
      <summary>
            The key used by this class to query a graph for a
            DataProvider that yields the layerID for each node in the
            graph.
            </summary>
      <remarks>
            The key used by this class to query a graph for a
            DataProvider that yields the layerID for each node in the
            graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.Normalize(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>Convenience method which removes empty layers and ensures that the smallest layer has value 0.</summary>
      <param name="layerId">provides the current layer ids for nodes in <c>g</c></param>
      <param name="normalizedLayerId">accepts the new layer ids that result after normalization.</param>
      <returns>The amount of layers left after removing all empty layers.</returns>
      <remarks>Convenience method which removes empty layers and ensures that the smallest layer has value 0.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.GroupAlignmentPolicy">
      <summary>Group layering alignment strategy specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.GroupAlignmentPolicy.Top">
      <summary>
            Group layering alignment strategy specifier. If recursive group layering is enabled, groups and normal nodes that occupy
            the same layer are top aligned with respect to their inner layers.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.GroupAlignmentPolicy.Center">
      <summary>
            Group layering alignment strategy specifier. If recursive group layering is enabled, groups and normal nodes that occupy
            the same layer are center aligned with respect to their inner layers.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.GroupAlignmentPolicy.Bottom">
      <summary>
            Group layering alignment strategy specifier. If recursive group layering is enabled, groups and normal nodes that occupy
            the same layer are bottom aligned with respect to their inner layers.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter">
      <summary>This class is an extended variant of the HierarchicLayouter class.</summary>
      <remarks>
            This class is an extended variant of the HierarchicLayouter class.
            It is capable of laying out nested groups of nodes as well as the group nodes
            themselves. The grouping information is provided through
            DataProvider instances, which are registered with the LayoutGraph instance.
            The layout is being calculated recursively. The size of the group nodes is determined
            by the area occupied by the children of the group node.
            <p />
            Here is a sample output of the algorithm.
            <p />
            <center><img src="doc-files/y.layout.hierarchic.HierarchicGroupLayouter.example-grouped.gif" border="1" /></center>
            <p />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.#ctor">
      <summary>Creates a new instance of HierarchicGroupLayouter</summary>
      <remarks>Creates a new instance of HierarchicGroupLayouter</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true" />..</summary>
      <remarks>Returns <see langword="true" />..</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Layouts the given graph.</summary>
      <remarks>Layouts the given graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.Drawer">
      <summary>The drawer which is responsible for the third phase of the algorithm</summary>
      <remarks>
            Specifies the drawer which is responsible for the third phase of the
            algorithm. A drawer is responsible for the layout style of
            this layouter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.GetLayerSequence(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Determines the order of the nodes within their layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.GlobalSequencingActive">
      <summary>The current strategy for the node sequencing.</summary>
      <remarks>
            Getter:<br />
            Returns the current strategy for the node sequencing.
            <para />
            Setter:<br />
            Determines whether a global sequencing heuristic should be used.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.GroupBoundsCalculator">
      <summary>The current GroupBoundsCalculator instance.</summary>
      <remarks>
            Getter:<br />
            Gets the current GroupBoundsCalculator instance.
            <para />
            Setter:<br />
            Sets the GroupBoundsCalculator instance.
            By specifying an instance of the GroupBoundsCalculator interface one can
            control the sizes of the group nodes. For every group of nodes which is in it's
            open state the instance will be asked to calculate the bounds for the given
            child nodes. The resulting size will be used during the ongoing layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.Grouping">
      <summary>The associated <c>Grouping</c> instance.</summary>
      <remarks>Returns the associated <c>Grouping</c> instance.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.Layerer">
      <summary>
            The <c>Layerer</c>, which is responsible for the first phase
            of the algorithm.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.LayeringStrategy">
      <summary>The currently set layering strategy.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.LayerSequencer">
      <summary>
            The <c>LayerSequencer</c>, which is responsible for the second phase
            of the algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.LayoutLevel(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.NodeList,System.Boolean)">
      <summary>Layouts the children of root recursively.</summary>
      <param name="root">The current root node (parent, invisible during layout)</param>
      <param name="levelNodes">The nodes to be laid out</param>
      <returns>the bounding box of the layout</returns>
      <remarks>Layouts the children of root recursively.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.LayoutStyle">
      <summary>
            The currently set layout style or <c>-1</c>
            if the style cannot be
            determined
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicGroupLayouter.StrongPortsScalingActive">
      <summary>The property strongPortsScalingActive.</summary>
      <remarks>
            Specifies the property strongPortsScalingActive.
            This property determines whether strong port constraints at group nodes
            should be interpreted as coordinates, that should be scaled to the same
            amount as the sizes of the group nodes vary.
            The default value is <see langword="true" />.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter">
      <summary>
            This class implements a layout algorithm for drawing directed graphs
            in a hierarchic way.
            </summary>
      <remarks>
            This class implements a layout algorithm for drawing directed graphs
            in a hierarchic way.
            <p />
            The algorithm places nodes in different horizontal layers,
            in such a way that most edges in the graph run from top
            to bottom.
            <p />
            Here is a sample output of the algorithm using top to bottom
            orientation and
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Pendulum" />
            layout style.
            <p />
            <center><img src="doc-files/y.layout.hierarchic.HierarchicLayouter.gif" border="1" /></center>
            <p />
            HierarchicLayouter can handle port constraints.
            See classes
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            and
            <see cref="T:yWorks.yFiles.Layout.PortConstraintKeys" />
            on how
            to setup port constraint information for this algorithm.
            <p />
            HierarchicLayouter can consider edge label data when laying out a graph.
            That means that the layout of edge labels will be part of the resulting
            layout and the layout of nodes and edges is chosen in such a way that the
            edge labels do not conflict with the rest of the layout.
            See classes
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData" />
            ,
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutKeys" />
            , and
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            on how
            to setup the integrated edge labeling algorithm.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.#ctor">
      <summary>Instantiates a new HierarchicLayouter.</summary>
      <remarks>Instantiates a new HierarchicLayouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.BendReductionThreshold">
      <summary>
            The limit, when bends are removed and a straight line is drawn
            instead.
            </summary>
      <remarks>
            Specifies the limit, when bends are removed and a straight line is drawn
            instead.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Always returns true.</summary>
      <remarks>Always returns true.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.DisposeMementoSupport">
      <summary>Disposes the memento support if it is existent, i.e.</summary>
      <remarks>
            Disposes the memento support if it is existent, i.e. if it has been queried
            before by <c>getMementoSupport()</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Layout the given graph.</summary>
      <remarks>Layout the given graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.Drawer">
      <summary>
            The <c>Drawer</c>, which is responsible for the third phase of
            the algorithm.
            </summary>
      <remarks>
            Specifies the <c>Drawer</c>, which is responsible for the third phase of
            the algorithm. The <c>Drawer</c> is responsible for the layout style of
            this layouter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.GetLayerSequence(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Determines the order of the nodes within their layers.</summary>
      <remarks>Determines the order of the nodes within their layers.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.Layerer">
      <summary>
            The <c>Layerer</c>, which is responsible for the first phase
            of the algorithm.
            </summary>
      <remarks>
            Specifies the <c>Layerer</c>, which is responsible for the first phase
            of the algorithm.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.LayeringStrategy">
      <summary>The currently set layering strategy.</summary>
      <remarks>
            Setter:<br />
            Sets a predefined layering strategy.
            This layouter assigns the nodes to separate layers. The nodes within each layer will be
            placed on the same horizontal line.
            The layers will be arranged vertically starting with the small-numbered layers.
            The rank of a node is the number of the layer it belongs to.
            <p />
            An important layering strategy for the hierarchic layout style is called <i>Hierarchical Layering</i>.
            A hierarchical layering tries to assign nodes to layers in a way that as much as possible
            edges of the graph will point to the main layout direction, i.e. the start nodes of the edges will
            have a smaller rank than the corresponding end nodes. Also, a hierarchical layering
            will never put two connected nodes in the same layer.
            <p />
            By default the layering strategy
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalTightTree" />
            is set.
            <para />
            Getter:<br />
            Returns the currently set layering strategy.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.LayerSequencer">
      <summary>
            The <c>LayerSequencer</c>, which is responsible for the second phase
            of the algorithm.
            </summary>
      <remarks>
            Specifies the <c>LayerSequencer</c>, which is responsible for the second phase
            of the algorithm.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.LayoutStyle">
      <summary>
            The currently set layout style or <c>-1</c>
            if the style cannot be
            determined
            </summary>
      <remarks>
            Setter:<br />
            Sets the layout style for this layouter. Possible values are
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Polyline" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.LinearSegments" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.MedianSimplex" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Simplex" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Pendulum" />
            ,
            and
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Tree" />
            .
            The default is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.LinearSegments" />
            <para />
            Getter:<br />
            Returns the currently set layout style or <c>-1</c>
            if the style cannot be
            determined
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MaximalDuration">
      <summary>A time limit for the algorithm in milliseconds</summary>
      <remarks>Specifies a time limit for the algorithm in milliseconds</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MementoSupport">
      <summary>The cookie for the memento support of the hierarchic layout algorithm.</summary>
      <remarks>
            Gets the cookie for the memento support of the hierarchic layout algorithm.
            If there was no memento support registered with this instance before,
            this call will instantiate the memento support, otherwise the existing
            instance will be returned.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MinimalEdgeDistance">
      <summary>The minimal distance between edges that run in parallel.</summary>
      <remarks>Specifies the minimal distance between edges that run in parallel.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MinimalFirstSegmentLength">
      <summary>
            The minimal length of first and last edge segments
            for edge routing.
            </summary>
      <remarks>
            Specifies the minimal length of first and last edge segments
            for edge routing. This will be used for orthogonal
            edge routing, self-loops, same layer edges and bus connectors.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
      <remarks>Specifies the minimal distance between two layers.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
      <remarks>Specifies the minimal distance between two nodes in the same layer.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.OptimizePortConstraints">
      <summary>
            Specifies whether the algorithm tries to optimize PortConstraints,
            that are either
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            or <see langword="null" />.
            </summary>
      <remarks>
            Specifies whether the algorithm should try to optimize PortConstraints,
            that are either
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            or <see langword="null" />.
            <p>
            Default is <see langword="false" />.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.OptimizeSameLayerEdgeRouting">
      <summary>
            Specifies whether the algorithm tries to optimize the routing of
            same layer edges whose PortConstraints don't impose the routing.
            </summary>
      <remarks>
            Setter:<br />
            Determines whether the algorithm should try to optimize the routing of
            same layer edges whose PortConstraints don't impose the routing.
            Default is <see langword="true" />.
            <para />
            Getter:<br />
            Returns whether the algorithm tries to optimize the routing of
            same layer edges whose PortConstraints don't impose the routing.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.RemoveFalseCrossings">
      <summary>Specifies whether or not false crossings should be removed from the layout.</summary>
      <remarks>
            Specifies whether or not false crossings should be removed from the layout.
            A false crossing is a crossing between two edges that connect
            to the same upper or lower node.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.RoutingStyle">
      <summary>The routing style being used.</summary>
      <remarks>
            Setter:<br />
            Sets the edge routing style. Possible values are
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.RoutingStyle.Polyline" />
            and
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.RoutingStyle.Orthogonal" />
            .
            By default
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.RoutingStyle.Polyline" />
            is set.
            <para />
            Getter:<br />
            Returns the routing style being used.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.IDrawer">
      <summary>Interface for the third phase of the Sugiyama algorithm.</summary>
      <remarks>
            Interface for the third phase of the Sugiyama algorithm.
            It assigns the coordinates to the nodes according to the defined
            range.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IDrawer.AssignCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the coordinates to the nodes.</summary>
      <remarks>This method assigns the coordinates to the nodes.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.DummyMap">
      <summary>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones.
            </summary>
      <remarks>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones. dummy stores the original edge for each dummy node or
            <see langword="null" /> for real nodes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
      <remarks>Sets the minimal distance between two edges in the same layer.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
      <remarks>Sets the minimal distance between two layers.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target (aka multi-edges) in the same layer.</summary>
      <remarks>Sets the minimal distance between two edges sharing source/target (aka multi-edges) in the same layer.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IDrawer.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
      <remarks>Sets the minimal distance between two nodes in the same layer.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ILayerer">
      <summary>This is the interface to the node layering  phase of the hierarchic layouter.</summary>
      <remarks>
            This is the interface to the node layering  phase of the hierarchic layouter.
            Implementations of this class must partition the nodes of the input graph
            in hierarchic layers.
            <dl>
            <dt>Implementing Classes:</dt>
            <dd>
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.AsIsLayerer" />
            ,
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.BFSLayerer" />
            ,
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ConstraintLayerer" />
            ,
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer" />
            ,
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer" />
            ,
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer" />
            </dd>
            </dl>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ILayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.<br /></summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
      <remarks>This method assigns the nodes in the graph to layers.<br /></remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.ILayerSequencer">
      <summary>
            Classes implementing this interface calculate the order of nodes within
            the different layers that the graph has been partitioned into.
            </summary>
      <remarks>
            Classes implementing this interface calculate the order of nodes within
            the different layers that the graph has been partitioned into.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.ILayerSequencer.GetLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Calculates the sequence of nodes within each layer.</summary>
      <param name="g">the graph being acted upon</param>
      <param name="layerID">
            provides for each node an integral number signifying the layer
            of that node. The first layer has the number 0.
            </param>
      <param name="maxLayer">the number of different layers</param>
      <returns>
            an array of length maxLayer containing node lists. Each node list
            contains the nodes of a corresponding layer. The order of the nodes
            within each node list represents the sequence of the nodes within their layer.
            </returns>
      <remarks>Calculates the sequence of nodes within each layer.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.IMementoSupport">
      <summary>This interface is a Cookie for the HierarchicLayouter's memento support.</summary>
      <remarks>This interface is a Cookie for the HierarchicLayouter's memento support.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IMementoSupport.CreateMemento">
      <summary>
            Creates a memento which can be held by the user, before using the support,
            a valid memento Object has to be set using the corresponding setter method.
            </summary>
      <remarks>
            Creates a memento which can be held by the user, before using the support,
            a valid memento Object has to be set using the corresponding setter method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IMementoSupport.GetMementoMode(yWorks.yFiles.Layout.Hierarchic.AlgorithmPhase)">
      <summary>
            Retrieves the current mode previously set by setMementoMode(byte, boolean)
            for the given phase of the algorithm.
            </summary>
      <remarks>
            Retrieves the current mode previously set by setMementoMode(byte, boolean)
            for the given phase of the algorithm.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IMementoSupport.Memento">
      <summary>The currently active memento Object</summary>
      <remarks>
            Setter:<br />
            Sets a previously created memento Object to be used for the next operation
            <para />
            Getter:<br />
            Gets the currently active memento Object
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IMementoSupport.SetMementoMode(yWorks.yFiles.Layout.Hierarchic.AlgorithmPhase,System.Boolean)">
      <summary>Sets the mode for each phase of the algorithm.</summary>
      <remarks>
            Sets the mode for each phase of the algorithm. <see langword="true" /> makes the
            algorithm use the
            values stored in the memento from a previous run, whereas <see langword="false" />
            makes the algorithm store the information in the memento after the next run.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter">
      <summary>
            This class is a variant of the classic
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter" />
            implementation.
            </summary>
      <remarks>
            This class is a variant of the classic
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter" />
            implementation. It serves as a facade to
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            .
            <p>
            Instances can be used to simply create hierarchic layouts from scratch or add
            new elements to the existing sketch drawing incrementally.<br />
            In order to add elements incrementally to the current sketch or let the algorithm
            optimize certain elements in the current sketch, set its mode to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental" />
            and
            add a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            (e.g. use
            <see cref="M:yWorks.yFiles.Algorithms.Util.Maps.CreateHashedDataMap" />
            ) using the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.IncrementalHintsDpKey" />
            DataProvider key to the graph and associate the marks
            obtained from the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory" />
            with the elements to be
            added incrementally. </p>
            <p>
            Many settings of the layout can be controlled using the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor" />
            instances. The ones that are used during the
            layout run can be obtained from
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.EdgeLayoutDescriptor" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.NodeLayoutDescriptor" />
            respectively. <br />
            If at the time of the invocation DataProvider instances are bound to the graph
            using either the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.EdgeLayoutDescriptorDpKey" />
            or
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.NodeLayoutDescriptorDpKey" />
            keys, they will be wrapped
            and whenever they do not provide values the ones set in this instance will be used as fall-back values.
            </p>
            <p>
            Here is a sample layout output:
            </p>
            <p>
            <center><img src="doc-files/y.layout.hierarchic.incremental.IncrementalHierarchicLayouter.general.gif" border="1" /></center>
            </p>
            <p>
            The following example shows the result of an incremental layout with lots of port constraints
            (For clarity colored layers have been added to the diagram):
            </p>
            <p>
            <center><img src="doc-files/y.layout.hierarchic.incremental.IncrementalHierarchicLayouter.ports1.gif" border="1" /></center>
            </p>
            <p>
            The last example shows the result of a layout run that considered swim lanes.
            Nodes with the same label have been placed into the same swim lane. Swim lanes
            have been ordered in ascending order of the label names.
            (For clarity lines have been added to the diagram that depict the bounds of the
            swim lanes):
            </p>
            <p>
            <center><img src="doc-files/y.layout.hierarchic.incremental.IncrementalHierarchicLayouter.swimlaneex1.gif" border="1" /></center>
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.#ctor">
      <summary>
            Creates a new IncrementalHierarchicLayouter instance which is
            set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch" />
            initially
            </summary>
      <remarks>
            Creates a new IncrementalHierarchicLayouter instance which is
            set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch" />
            initially
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.AutomaticEdgeGrouping">
      <summary>Whether or not automatic edge grouping should be applied.</summary>
      <remarks>
            Getter:<br />
            Whether or not automatic edge grouping should be applied.
            <para />
            Setter:<br />
            If this option is set, edges are grouped automatically. The automatic edge grouping tries to group a high number of edges without
            changing the semantic of the graph, i.e., it groups edges either at a common source node or a common target node.
            Edge groupings often allow more compact layouts since grouped edges are routed in a bus-style manner.
            Note: Edges are only grouped at their source (target) node if they do not have a port constraint/port candidates at this node.
            Furthermore, edges cannot be grouped at a node with specified port candidates (see class
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet" />
            ).
            User specified edge groups are not considered.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.BackloopRouting">
      <summary>Whether or not backloop routing should be applied.</summary>
      <remarks>
            Getter:<br />
            Whether or not backloop routing should be applied.
            <para />
            Setter:<br />
            If this option is set, reversed edges are routed in a backloop style, i.e., such that they attach to
            the same vertex sides as the other edges. Note that port constraints and port candidates are still considered.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Determines whether this layouter can perform the core layout on the given
            graph.
            </summary>
      <remarks>
            Determines whether this layouter can perform the core layout on the given
            graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CompactGroups">
      <summary>Specifies whether layer compaction for recursive group layering is active.</summary>
      <remarks>
            Getter:<br />
            Return whether layer compaction for recursive group layering is active.
            <para />
            Setter:<br />
            Set whether layer compaction for recursive group layering should be used.
            If set to <see langword="true" />, the recursive layering is compacted, i.e. node
            ranks are decreased if possible without reversing edge directions.
            This differs from non-recursive layering, where groups are ignored completely.
            The resulting layering tries to keep the layer span of a group node minimal,
            while minimizing the overall vertical space.
            <p>
            By default, this feature is disabled.
            </p>
            <p>
            <b>Note:</b><br />
            This feature works best when a instance of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer" />
            is used for layer assignment.
            If this feature is enabled, an alignment policy that is set with
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.GroupAlignmentPolicy" />
            is ignored.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.ComponentArrangementPolicy">
      <summary>The policy that is used to arrange connected components.</summary>
      <exception cref="T:System.ArgumentException">
            if the specified policy does not match
            one component arrangement policy constants.
            </exception>
      <remarks>
            Specifies the policy that is used to arrange connected components.
            <p>
            Defaults to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.ComponentArrangementPolicy.Topmost" />
            .
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.ConfigureCoreLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter)">
      <summary>Called before the actual layout is performed.</summary>
      <param name="graph">the graph to be laid out</param>
      <param name="ihl">the instance used for the core layout.</param>
      <remarks>
            Called before the actual layout is performed.
            Overwrite this to manually reconfigure the instance.
            If
            <see cref="F:yWorks.yFiles.Layout.PortCandidateSet.NodeDpKey" />
            is registered with the layout graph and
            there is no
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PortConstraintOptimizer" />
            registered,
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer" />
            will be temporarily configured with the instance.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.ConsiderNodeLabels">
      <summary>
            Specifies whether or not node labels are taken into account when calculating
            node positions (thereby preventing possible node/node label or
            node label/node label overlaps).
            </summary>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            .
            </exception>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            .
            </exception>
      <remarks>
            Setter:<br />
            Specifies whether or not to consider node labels when calculating node
            positions (thereby preventing possible node/node label or
            node label/node label overlaps).
            This method is a convenience method that assures that the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels" />
            is set
            to <see langword="true" />.
            Note that setting this option may overwrite the currently set label layouter. Hence, to combine this option with
            a generic edge labeling algorithm, the generic labeling has to be applied in an additional step after calculating the layout.
            <para />
            Getter:<br />
            Returns whether or not node labels are taken into account when calculating
            node positions (thereby preventing possible node/node label or
            node label/node label overlaps).
            This method is a convenience method checks whether the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels" />
            returns
            <see langword="true" />.
            <br />
            The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateEdgeLayoutDescriptor">
      <summary>Factory method that creates the default EdgeLayoutDescriptor.</summary>
      <returns>a new EdgeLayoutDescriptor (<c>new EdgeLayoutDescriptor()</c>)</returns>
      <remarks>Factory method that creates the default EdgeLayoutDescriptor.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateHierarchicLayouter">
      <summary>
            Factory method that creates the internally used
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            instance.
            </summary>
      <returns>
        <c>new y.layout.hierarchic.incremental.HierarchicLayouter()</c>
      </returns>
      <remarks>
            Factory method that creates the internally used
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateIncrementalHintsFactory">
      <summary>
            Returns a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory" />
            instance that must be used
            to obtain marks that can be associated with elements in the graph that
            will be laid out incrementally.
            </summary>
      <returns>the factory</returns>
      <remarks>
            Returns a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory" />
            instance that must be used
            to obtain marks that can be associated with elements in the graph that
            will be laid out incrementally. <br />
            Use this factory and a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that is bound to the graph
            using the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.IncrementalHintsDpKey" />
            DataProvider key to associate
            appropriate hints with the elements in the graph that should be laid out
            incrementally by the algorithm.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateLayerConstraintFactory(yWorks.yFiles.Algorithms.Graph)">
      <summary>
            Returns a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory" />
            instance that can be used to specify layer constraints for the given
            graph.
            </summary>
      <param name="graph">the given graph.</param>
      <returns>A LayerConstraintFactory instance for use with the given graph.</returns>
      <remarks>
            Returns a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory" />
            instance that can be used to specify layer constraints for the given
            graph.
            <p>
            <b>Note:</b>
            <c>LayerConstraintFactory</c> instances have to be
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.Dispose">disposed</see>
            after use. Disposing the factory will also remove all constraints
            previously specified for the factory's associated graph.
            </p>
            <p>
            Creating a new constraint factory for a graph will render all previously
            created factories (including any constraints specified) for that graph
            useless. Therefore a new constraint factory should only be created after
            previously used factories have been properly disposed.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateNodeLayoutDescriptor">
      <summary>Factory method that creates the default NodeLayoutDescriptor.</summary>
      <returns>a new NodeLayoutDescriptor (<c>new NodeLayoutDescriptor()</c>)</returns>
      <remarks>Factory method that creates the default NodeLayoutDescriptor.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateSequenceConstraintFactory(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory" />
            instance that can be used to specify sequence constraints for the given
            graph.
            </summary>
      <param name="graph" />
      <returns>A SequenceConstraintFactory instance for use with the given graph.</returns>
      <remarks>
            Returns a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory" />
            instance that can be used to specify sequence constraints for the given
            graph. For these sequence constraints to have any effect, the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer" />
            used to determine the
            in-layer node order (<em>sequence</em>) has to support constraints. Both,
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer">DefaultLayerSequencer</see>
            and the incremental sequencer used internally support sequence constraints.
            <p>
            <b>Note:</b>
            <c>SequenceConstraintFactory</c> instances have to be
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.Dispose">disposed</see>
            after use. Disposing the factory will also remove all constraints
            previously specified for the factory's associated graph.
            </p>
            <p>
            Creating a new constraint factory for a graph will render all previously
            created factories (including any constraints specified) for that graph
            useless. Therefore a new constraint factory should only be created after
            previously used factories have been properly disposed.
            </p>
            <p>
            You can create a SequenceConstraintFactory without binding it to a graph instance initially by passing a <see langword="null" />
            parameter. In that case, you <b>must</b> bind the returned instance to the graph instance before calculating a layering:
            <pre>
            IncrementalHierarchicLayouter ihl;
            SequenceConstraintFactory cf = ihl.createSequenceConstraintFactory(null);
            ...
            Graph g = ...;
            g.addDataProvider(SequenceConstraintFactory.SEQUENCE_CONSTRAINTS_MEMENTO_DPKEY,
            DataProviders.createConstantDataProvider(cf.getMemento()));
            //Calculate layout
            </pre>
            </p>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CriticalEdgeDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store the priority (integer values) for "critical" edges.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store the priority (integer values) for "critical" edges.
            The layouter tries to vertically align each node pair that is connected by a critical edge (integer value &gt; 0).
            This feature can for example be utilized to highlight different edge paths that are relevant for a user. Conflicts
            between different critical edges are always resolved in favor of the higher priority.
            Note: "critical" edges do no affect the result of the crossing minimization
            (
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer" />
            ) phase. Hence, there may be crossings between two "critical" edges.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.DefaultDrawingDistanceCalculator">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator" />
            that is registered
            with the layout algorithm by default.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            if the current instance returned
            by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DrawingDistanceCalculator" />
            is not an instance of <c>DefaultDrawingDistanceCalculator</c>.
            </exception>
      <remarks>
            Returns the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator" />
            that is registered
            with the layout algorithm by default.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Performs the actual layout using the currently set mode.</summary>
      <remarks>Performs the actual layout using the currently set mode.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.EdgeLayoutDescriptor">
      <summary>
            The <c>EdgeLayoutDescriptor</c> instance used for all those
            edges, that do not have a specific layout descriptor assigned.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the <c>EdgeLayoutDescriptor</c> instance used for all those
            edges, that do not have a specific layout descriptor assigned.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.EdgeToEdgeDistance">
      <summary>The minimum distance between two adjacent edges in one layer.</summary>
      <remarks>
            Specifies the minimum distance between two adjacent edges in one layer.
            See
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumDistance" />
            for related settings.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FixedElementsLayerer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            instance that is used to obtain the layering
            for those nodes that are not marked to be laid out incrementally
            if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental" />
            .
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            instance that is used to obtain the layering
            for those nodes that are not marked to be laid out incrementally
            if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FixedElementsSequencer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer" />
            instance that is used to calculated the sequence
            of the nodes that are not marked to be laid out incrementally
            if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental" />
            .
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer" />
            instance that is used to calculated the sequence
            of the nodes that are not marked to be laid out incrementally
            if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FromScratchLayerer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            instance that is used to obtain the layering
            for the nodes if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch" />
            .
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            instance that is used to obtain the layering
            for the nodes if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FromScratchLayeringStrategy">
      <summary>
            The currently set layering strategy for the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FromScratchLayerer">from scratch</see>
            layering.
            </summary>
      <remarks>
            Setter:<br />
            Convenience method that sets a predefined layering strategy for the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FromScratchLayerer">from scratch</see>
            layerer.
            The layouter assigns the nodes to separate layers. The nodes within each layer will be
            placed on the same horizontal layer.
            The layers will be arranged vertically starting with the small-numbered layers.
            The rank of a node is the number of the layer it belongs to.
            <p />
            An important layering strategy for the hierarchic layout style is called <i>Hierarchical Layering</i>.
            A hierarchical layering tries to assign nodes to layers in a way that as much as possible
            edges of the graph will point to the main layout direction, i.e. the start nodes of the edges will
            have a smaller rank than the corresponding end nodes. Also, a hierarchical layering
            will never put two connected nodes in the same layer.
            <p />
            By default the layering strategy
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalOptimal" />
            is set.
            <p />
            This method wraps the internal implementations into a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer" />
            instance so that it is possible to specify the behavior of the algorithm if the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouterEnabled">component layouter</see>
            is disabled.
            <para />
            Getter:<br />
            Returns the currently set layering strategy for the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FromScratchLayerer">from scratch</see>
            layering.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.FromScratchSequencer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer" />
            instance that is used to calculate the node
            sequence if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch" />
            .
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer" />
            instance that is used to calculate the node
            sequence if the layouter is set to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.GroupAlignmentPolicy">
      <summary>The group layer alignment strategy used for recursive group layering.</summary>
      <remarks>
            Specifies the group layer alignment strategy used for recursive group layering.
            <p>
            Default value is
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.GroupAlignmentPolicy.Center" />
            .
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.HierarchicLayouter">
      <summary>
            The internally used
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            instance.
            </summary>
      <remarks>
            Returns the internally used
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            instance.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.IncrementalHintsDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store incremental layout hints
            that can be retrieved from the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory" />
            which itself can be obtained from the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateIncrementalHintsFactory" />
            method.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store incremental layout hints
            that can be retrieved from the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory" />
            which itself can be obtained from the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateIncrementalHintsFactory" />
            method.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.IntegratedEdgeLabeling">
      <summary>Specifies whether integrated edge labeling is enabled.</summary>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            .
            </exception>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            .
            </exception>
      <remarks>
            Setter:<br />
            Specifies whether or not to use integrated edge labeling.
            This method is a convenience method that assures that the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels" />
            is set
            to <see langword="true" />
            <para />
            Getter:<br />
            Returns whether integrated edge labeling is enabled.
            This method is a convenience method that checks if the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels" />
            returns
            <see langword="true" />.
            <br />
            The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.LayerValueHolderDpKey">
      <summary>Used for publishing the final layering information.</summary>
      <remarks>
            Used for publishing the final layering information.
            If the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            associated to this key is also a
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            , the integer layer id of each node is stored
            using the acceptor's
            <see cref="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetInt(System.Object,System.Int32)">setInt</see>
            method.
            Otherwise, the provider's values should be of type
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder" />
            and the value holder's
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder.Value">setValue</see>
            method is used to store the integer layer ids of each node.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.LayoutMode">
      <summary>The layout mode this layouter is currently in.</summary>
      <exception cref="T:System.ArgumentException">if the mode is unknown</exception>
      <remarks>
            Getter:<br />
            Returns the layout mode this layouter is currently in.
            Depending on the mode the layout algorithm will use different
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer" />
            implementations. <br />
            Currently supported modes are:
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch" />
            </li>
            </ul>
            Defaults to
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch" />
            .
            <para />
            Setter:<br />
            Sets the layout mode this layouter should use for upcoming layouts.
            Depending on the mode the layout algorithm will use different
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer" />
            implementations. <br />
            Currently valid mode constants are:
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch" />
            </li>
            </ul>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.MaximalDuration">
      <summary>The time limit (in milliseconds) set for the layout algorithm.</summary>
      <remarks>
            Getter:<br />
            Returns the time limit (in milliseconds) set for the layout algorithm.
            <para />
            Setter:<br />
            Sets a preferred time limit (in milliseconds) for the layout algorithm.
            Note that restricting the maximal duration may result in a worse layout quality.
            Furthermore, the actual runtime may exceed the maximal duration since the layout algorithm
            still has to find a valid solution.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.MinimumLayerDistance">
      <summary>The minimum distance between two adjacent layers.</summary>
      <remarks>
            Specifies the minimum distance between two adjacent layers.
            The default is <c>20.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.MirrorMask">
      <summary>
            The
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.OrientationLayouter">orientation layouter</see>
            's mirror mask.
            </summary>
      <remarks>
            Returns the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.OrientationLayouter">orientation layouter</see>
            's mirror mask.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.NodeLayoutDescriptor">
      <summary>
            The <c>NodeLayoutDescriptor</c> instance used for all those
            nodes, that do not have a specific layout descriptor assigned.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the <c>NodeLayoutDescriptor</c> instance used for all those
            nodes, that do not have a specific layout descriptor assigned.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.NodePlacer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer" />
            instance that will be used to calculated the
            final node placement of the layout.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer" />
            instance that will be used to calculated the
            final node placement of the layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.NodeToEdgeDistance">
      <summary>The minimum distance between two adjacent nodes in one layer.</summary>
      <remarks>
            Setter:<br />
            Sets the minimum distance between an edge and an adjacent node in one layer.
            See
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.MinimumDistance" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumDistance" />
            for related settings.
            <para />
            Getter:<br />
            Returns the minimum distance between two adjacent nodes in one layer.
            The default is <c>15.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.NodeToNodeDistance">
      <summary>The minimum distance between two adjacent nodes in one layer.</summary>
      <remarks>
            Setter:<br />
            Sets the minimum distance between two adjacent nodes in one layer.
            See
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.MinimumDistance" />
            for related settings.
            <para />
            Getter:<br />
            Returns the minimum distance between two adjacent nodes in one layer.
            The default is <c>30.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.OrthogonalRouting">
      <summary>Specifies whether or not edges should be routed orthogonally.</summary>
      <remarks>
            Specifies whether or not edges should be routed orthogonally. Return value <see langword="true" />
            signals that all resulting edge paths will be composed of vertical and horizontal segments, only.
            Default is <see langword="false" />.
            Note that this is a convenience method delegates to
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.EdgeLayoutDescriptor" />
            .
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.OrthogonallyRouted" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.RecursiveGroupLayering">
      <summary>Specifies whether groups are respected during the layering stage.</summary>
      <remarks>
            Specifies whether groups are respected during the layering stage.
            <p>
            If set to <see langword="true" /> (and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CompactGroups">group compaction</see>
            is not enabled), groups are layered recursively, i.e.
            <ul>
            <li>nodes in the same group always occupy adjacent layers</li>
            <li>layer intervals spanned by different group nodes are either disjoint or are nested</li>
            </ul>
            If this feature is disabled, group information is ignored for the layering step.
            <br />
            If the graph is flat, this setting is ignored.
            </p>
            <p>
            By default, this feature is enabled.
            </p>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.SequenceConstraintsMementoDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" /> key to store the constraint graph for sequence constraints.</summary>
      <remarks>
            <c>DataProvider</c> key to store the constraint graph.
            A <c>v1 before v2</c> constraint is represented as an edge
            between the representatives of <c>v1</c> and <c>v2</c>
            in the constraint graph.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.SequenceValueHolderDpKey">
      <summary>Used for publishing the final sequencing information.</summary>
      <remarks>
            Used for publishing the final sequencing information.
            If the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            associated to this key is also a
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            , the sequence order number of each node is
            stored using the acceptor's
            <see cref="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetInt(System.Object,System.Int32)">setInt</see>
            method.
            Otherwise, the provider's values should be of type
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder" />
            and the value holder's
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder.Value">setValue</see>
            method is used to store the sequence order number of each node.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.SwimlaneDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor" />
            instances for each node in the graph.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor" />
            instances for each node in the graph. If this key is present during the layout.
            The layout algorithm will arrange nodes in swim lanes. The information about the
            swim lanes is finally written back into the descriptor instances.
            Instances can be shared among multiple nodes in the same lane, but don't have to be shared.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.UnconfigureCoreLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter)">
      <summary>Called after the actual layout is performed.</summary>
      <param name="graph">the graph to be laid out</param>
      <param name="ihl">the instance used for the core layout.</param>
      <remarks>
            Called after the actual layout is performed.
            Overwrite this to manually unconfigure the instance.
            If
            <see cref="F:yWorks.yFiles.Layout.PortCandidateSet.NodeDpKey" />
            is registered with the layout graph and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer" />
            was registered with the instance during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.ConfigureCoreLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter)" />
            it will be removed by this method.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy">
      <summary>Layering strategy specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalTopmost">
      <summary>
            Layering strategy specifier. A simple hierarchical layering variant.
            All nodes with indegree zero will be assigned to the topmost layer of the layout.
            The number of separate layers will be as small as possible.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalOptimal">
      <summary>
            Layering strategy specifier. An optimal hierarchical layering strategy.
            The layer distance of an edge is the absolute difference between the layer numbers
            of its source and target node.
            Layer assignment will be done in such a way that the overall sum of the layer distances
            of all edges in the layout is minimal.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalTightTree">
      <summary>
            Layering strategy specifier.  A heuristic that approximates the ranking done by
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalOptimal" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalDownshift">
      <summary>
            Layering strategy specifier. A fast heuristic that improves the
            the ranking done by
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.HierarchicalTopmost" />
            by down shifting
            some nodes in the layering. The quality is usually worse than the
            one produced by <i>Tight Tree Heuristic</i>.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.Bfs">
      <summary>
            Layering strategy specifier.
            Layering based on a breadth first search (bfs).
            All edges will span at most one layer in
            the resulting drawing. Edges between nodes that belong to the same layer are possible.
            The nodes that will be placed in the first layer can be provided by a
            data provider bound to the input graph using the key
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.BFSLayerer.CoreNodesDpKey" />
            .
            If this data provider is not given, then nodes that have no incoming edges are placed
            in the first layer.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.FromSketch">
      <summary>
            Layering strategy specifier. A layer assignment strategy
            that uses the initial y-coordinates of the nodes
            (x-coordinates when the layout orientation is horizontal)
            to determine a node layering. It tries to find a layering that is similar to the
            one in the input graph. When this layering strategy is used, the layouter
            may place nodes in the same layer, even though they are connected by an edge.
            These inner layer edges are always routed in an orthogonal style.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.UserDefined">
      <summary>
            Layering strategy specifier. The ranks of the nodes will be given by the user.
            The node ranks must be provided by a data provider bound to the input graph
            using the key
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.GivenLayersLayerer.LayerIdDpKey" />
            . Like
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.FromSketch" />
            this layering allows inner layer edges.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayeringStrategy.Unknown">
      <summary>
            Dummy layering strategy specifier. Returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.HierarchicLayouter.LayeringStrategy" />
            if the current strategy
            is not known.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.LayoutMode">
      <summary>
            Layout mode constant that can be used in
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.LayoutMode" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.Incremental">
      <summary>
            Layout mode constant that can be used in
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.LayoutMode" />
            .
            This constant sets the layout algorithm to incremental mode, i.e.
            fixed elements will be handled by the <c>fixedElementsSequencer</c>
            and <c>fixedElementsLayerer</c> and elements marked for incremental
            layout will be added to the drawing later.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutMode.FromScratch">
      <summary>
            Layout mode constant that can be used in
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.LayoutMode" />
            .
            This constant sets the layout algorithm to "from scratch mode", i.e.
            the algorithm will recompute the layout from scratch.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.LayoutStyle">
      <summary>Layout style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Pendulum">
      <summary>
            Layout style specifier. Draws the edges in a way
            that nodes are balanced nicely and the number
            of bends on an edge is kept small.
            <p />
            Note that this layout style is more time consuming than most of the
            other ones.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.LinearSegments">
      <summary>
            Layout style specifier. Draws the edges in a way
            that at most two bends are used per edge unless two edges cross.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Polyline">
      <summary>
            Layout style specifier. Draws the edges in a polyline
            fashion. The layout tends to be very compact but the
            number of edge bends may be high.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Tree">
      <summary>
            Layout style specifier. Gives nice layouts if the
            graph is a tree.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.Simplex">
      <summary>Layout style specifier. Gives tight layouts with rather few bends.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.LayoutStyle.MedianSimplex">
      <summary>
            Layout style specifier. Similar to SIMPLEX but more symmetric for the cost
            of a few more bends.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer">
      <summary>Still experimental.</summary>
      <remarks>Still experimental.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.<br /></summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList,System.Boolean)" />
    <member name="P:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.PreferredLayerWidth" />
    <member name="P:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.StartFromSketch" />
    <member name="P:yWorks.yFiles.Layout.Hierarchic.LeanLayersLayerer.UseEnhancedDistribution" />
    <member name="T:yWorks.yFiles.Layout.Hierarchic.LinearSegmentsDrawer">
      <summary>This class implements the third phase of the Sugiyama layout algorithm.</summary>
      <remarks>
            This class implements the third phase of the Sugiyama layout algorithm.
            Edges are represented as poly-lines with at most two bends.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LinearSegmentsDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.LinearSegmentsDrawer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.LinearSegmentsDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Overwrite this method to assign the final coordinates to the
            objects of he graph.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper">
      <summary>This class can be used to improve the results of different drawers.</summary>
      <remarks>
            This class can be used to improve the results of different drawers.
            It is designed as a wrapper to another drawer (especially SimplexDrawer).
            It will insert additional dummy nodes for each node that has an even number of
            incoming edges or outgoing edges. Dummy nodes will be inserted in the neighbor
            layer at the center of the other edges' opposite nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.#ctor(yWorks.yFiles.Layout.Hierarchic.IDrawer)">
      <summary>
            Creates a new instance of MedianDrawerWrapper using the delegate to
            perform the core work.
            </summary>
      <remarks>
            Creates a new instance of MedianDrawerWrapper using the delegate to
            perform the core work.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.AssignCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the coordinates to the nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.Delegate">
      <summary>The drawer to which the actual drawing will be delegated.</summary>
      <remarks>Specifies the drawer to which the actual drawing will be delegated.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.drawerDelegate">
      <summary>the delegate</summary>
      <remarks>the delegate</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.dummy">
      <summary>the dummyMap</summary>
      <remarks>the dummyMap</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.DummyMap">
      <summary>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target (aka multi-edges) in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.Postprocess(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Called as a hook after the actual drawing is performed by the delegate</summary>
      <remarks>Called as a hook after the actual drawing is performed by the delegate</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianDrawerWrapper.Preprocess(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Called as a hook before the actual drawing is performed by the delegate</summary>
      <remarks>Called as a hook before the actual drawing is performed by the delegate</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer">
      <summary>This class implements the third phase of the hierarchic layout algorithm.</summary>
      <remarks>
            This class implements the third phase of the hierarchic layout algorithm.
            Edges are represented as polylines with at most two bends.
            The algorithm has linear running time and is based on the article [BK01]:
            <p />
            U. Brandes and B. Koepf, Fast and Simple Horizontal Coordinate Assignment,
            Proceedings of 9th Symposium of Graph Drawing, LNCS, 2001.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Performs coordinate assignment.</summary>
      <remarks>Performs coordinate assignment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.Dispose">
      <summary>Frees held resources.</summary>
      <remarks>Frees held resources.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.HorizontalCompaction(yWorks.yFiles.Layout.LayoutGraph,System.Double[],yWorks.yFiles.Algorithms.NodeList[])">
      <summary>Calculate coordinates.</summary>
      <param name="g">the graph for which the layout is calculated.</param>
      <param name="x">the array where the result is stored.</param>
      <remarks>
            Calculate coordinates.
            This method corresponds to Algorithm 3 in [BK01].
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.Init(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>Initializes data structures for all runs.</summary>
      <remarks>Initializes data structures for all runs.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.MarkConflicts(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.INodeMap,System.Int32[])">
      <summary>Mark type 1 conflicts.</summary>
      <param name="layerLists">the list of layers.</param>
      <param name="conflictMark">used to mark the conflicting edges.</param>
      <param name="dummyMap">
            map which returns <see langword="true" /> for bends,
            <see langword="false" /> otherwise.
            </param>
      <param name="pos">
            is indexed by the index method of node and returns the rank of
            a node inside the layer which contains the node.
            </param>
      <remarks>
            Mark type 1 conflicts.
            This method corresponds to Algorithm 1 in [BK01].
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.PropagateCoordinates(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Writes the calculated x values in the layout graph.</summary>
      <remarks>Writes the calculated x values in the layout graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.Reinit(yWorks.yFiles.Algorithms.Graph,System.Double[])">
      <summary>Initializes data structures for one basic step.</summary>
      <param name="x">the array where the coordinates will be stored.</param>
      <remarks>Initializes data structures for one basic step.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.MedianLinearSegmentDrawer.VerticalAlignment(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>Calculates vertical alignment.</summary>
      <param name="g">the graph for which the layout is calculated.</param>
      <param name="layerLists">the list of layers.</param>
      <remarks>
            Calculates vertical alignment.
            This method corresponds to Algorithm 2 in [BK01].
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer">
      <summary>
            This class can be used to wrap
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IDrawer" />
            implementations.
            </summary>
      <remarks>
            This class can be used to wrap
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IDrawer" />
            implementations.
            It modifies the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderLeft" />
            and
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.DrawerKeys.NodeBorderRight" />
            DataProvider instances and delegates the
            actual drawing to the inner drawer.
            Actual space requirements are calculated in
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.GetHaloSpace(yWorks.yFiles.Algorithms.Node,System.Boolean)" />
            .
            This implementation uses the maximum left and right label overlaps as the halo values.
            Note that this will only work with Drawer implementations that respect the values
            provided through the DataProviders, e.g. MedianLinearSegmentsDrawer and SimplexDrawer.
            <br />
            Here is some example set up code.
            <pre>
            // create the Layouter
            HierarchicLayouter hl = new HierarchicLayouter();
            // set a suitable Drawer
            hl.setDrawer(new SimplexDrawer());
            // wrap the Drawer
            hl.setDrawer(new NodeLabelSpaceDrawer(hl.getDrawer()));
            </pre>
            <br />
            <b>
            This implementation uses
            <see cref="T:yWorks.yFiles.Layout.INodeLabelLayout" />
            s and can therefor not be
            used with layout orientations other than top to bottom.
            </b>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.#ctor(yWorks.yFiles.Layout.Hierarchic.IDrawer)">
      <summary>Creates a new instance of NodeLabelSpaceDrawer</summary>
      <remarks>Creates a new instance of NodeLabelSpaceDrawer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.AssignCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the coordinates to the nodes.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.DummyMap">
      <summary>
            Gives the drawer the opportunity to distinguish between dummy nodes
            and real ones.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.GetHaloSpace(yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>Calculates the horizontal space requirements for the given node.</summary>
      <param name="node">The node to calculate the halo for.</param>
      <param name="left">Whether to calculate the left (<see langword="true" />) or right (<see langword="false" />) halo.</param>
      <returns>The additional space needed by the given node at the given side.</returns>
      <remarks>
            Calculates the horizontal space requirements for the given node.
            This implementation uses the maximum left and right label overlaps as the halo values.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target (aka multi-edges) in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.NodeLabelSpaceDrawer.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.PendularDrawer" />
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.#ctor">
      <summary>empty constructor, does nothing</summary>
      <remarks>empty constructor, does nothing</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This is the main loop of this layout algorithm.</summary>
      <param name="layerLists">
            a list of all the nodes for each layer, to determine
            their relative positions
            </param>
      <remarks>
            This is the main loop of this layout algorithm. For now it does the following loop:
            <ul>
            <li> for each round do
            <ul>
            <li>top down phase, i.e. calling partitionLayer(layerList[i] , -1)
            and shakePartition(partition,-1) for each layer in top down order</li>
            <li>bottom up phase, i.e. calling partitionLayer(layerList[i] , -1)
            and shakePartition(partition,-1) for each layer in bottom up order</li>
            <li>criss cross phase, i.e. calling partitionLayer(layerList[i] , 0)
            and shakePartition(partition,0) for each layer in top down order</li>
            <li>performing minNode</li>
            </ul></li>
            <li> minPath phase, i.e. calling findChains() and minPath(chains)</li>
            </ul>
            Subclasses that wish to override this function to implement different behaviour should
            implement a call to initStructures() and
            initializePositions(layerLists) before using the provided methods.
            After the work is done, they should call disposeStructures(g).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.DisposeStructures">
      <summary>
            Cleans up previously allocated structures, that were constructed by a call to
            <c>initStructures</c></summary>
      <remarks>
            Cleans up previously allocated structures, that were constructed by a call to
            <c>initStructures</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.FindChains">
      <summary>Finds chains of nodes, i.e.</summary>
      <returns>a list of NodeLists containing each more than 1 nodes</returns>
      <remarks>
            Finds chains of nodes, i.e. maximum number of adjacent nodes (real ones and dummy nodes) have
            indegree and outdegree 1.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetEdgeWeight(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns a non-negative value for each Edge e.</summary>
      <param name="e">the edge</param>
      <returns>a non-negative value</returns>
      <remarks>
            Returns a non-negative value for each Edge e.
            In this implementation edges between two real nodes result in an edge weight of 1.
            Edges between one dummy and one real node result in an edge weight of
            <c>segmentEndFactor * 1</c>.
            Edges between two dummy nodes get an edge weight of <c>segmentFactor * 1</c>.
            One could implement edge weights by supplying an <c>EdgeMap</c> mapping a non-negative
            numeric value for each edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetMaximumExtent(yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Calculates the highest or lowest x-coordinate the Node n can be assigned to, without breaking
            the constraints.
            </summary>
      <param name="n">the node</param>
      <param name="toLeft">
        <see langword="true" /> if the minimum x-coordinate shall be calculated;
            <see langword="false" /> for the maximum x-coordinate
            </param>
      <returns>the maximum/minimum extent of the node's center x-coordinate</returns>
      <remarks>
            Calculates the highest or lowest x-coordinate the Node n can be assigned to, without breaking
            the constraints.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetMinimalLayerDistance(yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Returns the minimum distance between two Nodes on the same layer according to
            getMinimalNodeDistance(), getMinimalEdgeDistance() and getMinimalMultiEdgeDistance().
            </summary>
      <param name="n">the node</param>
      <param name="toLeft">
        <see langword="true" /> if the minimum x-coordinate shall be calculated;
            <see langword="false" /> for the maximum x-coordinate
            </param>
      <returns>the maximum/minimum extent of the node's center x-coordinate</returns>
      <remarks>
            Returns the minimum distance between two Nodes on the same layer according to
            getMinimalNodeDistance(), getMinimalEdgeDistance() and getMinimalMultiEdgeDistance().
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetPendulumForce(yWorks.yFiles.Algorithms.ICursor,System.Int32)">
      <summary>Helper method which calculates the force acting on all nodes given by the cursor.</summary>
      <param name="cursor">the nodes for which the force will be calculated</param>
      <param name="direction">
            -1 if nodes in higher layers should be used to calculate the forces, 1 if nodes
            in lower layers should be used, 0 if both surrounding layers should be used
            </param>
      <returns>
            a force, i.e. a signed value, which, if applied to the nodes in cursor, would minimize
            the force acting on them.
            </returns>
      <remarks>
            Helper method which calculates the force acting on all nodes given by the cursor.
            The force is calculated by the sum of the results of calls to getPendulumForce(Node, int)
            divided by the number of the nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetPendulumForce(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IEdgeCursor)">
      <summary>
            Helper method which calculates the force that all nodes given by
            EdgeCursor apply to v.
            </summary>
      <param name="v">the node for which the force will be calculated</param>
      <param name="ec">
            the EdgeCursor which determines which edges should be
            considered in the calculation
            </param>
      <returns>
            a force, i.e. a signed value, which (if added to the x-coordinate
            of v) would minimize the force on v if applied.
            </returns>
      <remarks>
            Helper method which calculates the force that all nodes given by
            EdgeCursor apply to v.
            The force is calculated by the sum of the weighted differences of the
            x-coordinates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.GetZ">
      <summary>Calculates the value of the function this algorithm should minimize.</summary>
      <returns>a positive value.</returns>
      <remarks>Calculates the value of the function this algorithm should minimize.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.InitializePositions(yWorks.yFiles.Algorithms.NodeList[])">
      <summary>Helper method which initializes the positions of the nodes in all layers.</summary>
      <param name="layerList">an array of NodeLists each corresponding to a single layer</param>
      <remarks>
            Helper method which initializes the positions of the nodes in all layers.
            This method respects getMinimalLayerDistance(Node,boolean)
            and compacts the graph to the leftmost position (0)
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.InitStructures">
      <summary>
            used to initialize internal structures such as <c>NodeMap right</c> and
            <c>NodeMap left</c><c>bendGridWidth</c> and <c>nodeGridWidth</c>.
            </summary>
      <remarks>
            used to initialize internal structures such as <c>NodeMap right</c> and
            <c>NodeMap left</c> <c>bendGridWidth</c> and <c>nodeGridWidth</c>.
            Note that the NodeMaps do not yet contain any values unless you call initializePositions()
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.IsSegmentNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Helper method that determines whether a node is a so-called segment node.</summary>
      <param name="n">the Node</param>
      <returns>
        <see langword="true" /> iff (inDegree == 1 &amp;&amp; outDegree &lt; 2) ||
            (outDegree == 1 &amp;&amp; inDegree &lt; 2)
            </returns>
      <remarks>Helper method that determines whether a node is a so-called segment node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.LayoutGraph" />
    <member name="F:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.left">
      <summary>map that maps the left node for each node in a layer or <see langword="null" /> if it is the leftmost</summary>
      <remarks>map that maps the left node for each node in a layer or <see langword="null" /> if it is the leftmost</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.MinNode">
      <summary>Performs the minNode phase.</summary>
      <remarks>
            Performs the minNode phase.
            It uses a queue, which is initially filled with all nodes in the
            layout graph.
            For each Node n that is popped off the queue it performs a call to
            <ul>
            <li>force = getPendulumForce(n, n.edges) </li>
            <li>force = verifyMovement(n,force)</li>
            <li>move(n, force)</li>
            </ul>
            If the node has changed its x-coordinate all its neighbors are requeued,
            if not already in the queue.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.MinPath(yWorks.yFiles.Algorithms.YList)">
      <summary>Performs the minPath phase.</summary>
      <param name="segments">a list of NodeList each containing a chain of nodes</param>
      <returns>
        <see langword="true" /> iff there was a change in any coordinate of the graph</returns>
      <remarks>
            Performs the minPath phase.
            It tries to straighten the chains given by a list of NodeLists, by sequentially assigning the same
            x- coordinate to as many adjacent nodes of each chain as possible, not violating the constraints and
            not changing coordinates of nodes in the neighborhood of each segment
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.Move(yWorks.yFiles.Algorithms.ICursor,System.Double)">
      <summary>Helper method which moves the nodes provided by the Cursor nodes by the given amount.</summary>
      <param name="nodes">the nodes</param>
      <param name="distance">the distance that shall be added to the nodes x-coordinate</param>
      <remarks>
            Helper method which moves the nodes provided by the Cursor nodes by the given amount.
            This one in turn calls move(Node,double) to delegate its work.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.Move(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>
            Helper method which moves a given node by a given amount
            if the useGrid is set to true, this method will snap the new node position to the
            appropriate grid, i.e.
            </summary>
      <param name="n">the node</param>
      <param name="distance">the distance that shall be added to the nodes x-coordinate</param>
      <remarks>
            Helper method which moves a given node by a given amount
            if the useGrid is set to true, this method will snap the new node position to the
            appropriate grid, i.e. it decides whether to use nodeGridWith or bendGridWith
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.PartitionLayer(yWorks.yFiles.Algorithms.NodeList,System.Int32)">
      <summary>
            Partitions a layer given by its NodeList by calculating the forces
            according to the given direction.
            </summary>
      <param name="layer">the layer which shall be partitioned</param>
      <param name="direction">
            -1 if nodes in higher layers should be used to calculate
            the forces, 1 if nodes in lower layers
            should be used, 0 if both surrounding layers should be used
            </param>
      <returns>
            a list of NodeLists each containing adjacent nodes in that layer,
            which can be treated as a single unit when moving
            </returns>
      <remarks>
            Partitions a layer given by its NodeList by calculating the forces
            according to the given direction.
            This one is intended for use with the shakePartition() method.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.right">
      <summary>map that maps the right node for each node in a layer or <see langword="null" /> if it is the rightmost</summary>
      <remarks>map that maps the right node for each node in a layer or <see langword="null" /> if it is the rightmost</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.ShakePartition(yWorks.yFiles.Algorithms.YList,System.Int32)">
      <summary>Shakes a given partition of a Layer, i.e.</summary>
      <param name="partition">
            a List of NodeLists each containing at least one node
            belonging to a single layer
            </param>
      <param name="direction">
            -1 if nodes in higher layers should be used to calculate
            the forces, 1 if nodes in lower layers should be used, 0 if both
            surrounding layers should be used
            </param>
      <remarks>
            Shakes a given partition of a Layer, i.e. it calculates the forces for
            each part of the partition
            and applies them if possible.
            It uses the functionality of these methods:
            <ul>
            <li>getPendulumForce(NodeCursor, int direction)</li>
            <li>verifyMovement(Node, double force)</li>
            <li>move(NodeCursor, double force)</li>
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.StraightenPath(yWorks.yFiles.Algorithms.ListCell,yWorks.yFiles.Algorithms.ListCell,System.Double[])">
      <summary>Helper method for use in <c>minPath</c>.</summary>
      <param name="firstCell">
            this determines the first Node in a NodeList
            which should be assigned a new x-coordinate
            </param>
      <param name="lastCell">
            this determines the last Node in a NodeList
            (which must be same List as the one for firstCell) which should
            be assigned a new x-coordinate
            </param>
      <param name="range">
            an interval providing information of the legal range,
            the Nodes x-coordinates could be set to.
            The values can can be smaller than (-Double.MAX_VALUE) for the left
            border and greater than Double.MAX_VALUE for the right one
            </param>
      <returns>
        <see langword="true" /> iff this method has done any change to the graphs
            coordinates
            </returns>
      <remarks>
            Helper method for use in <c>minPath</c>.
            It will assign the same x-coordinate to all the nodes
            given the first and the last cell in NodeList.
            Note that this method does not double-check whether the given
            range is valid for all nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.Touches(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Helper method which checks whether two adjacent nodes on a layer touch
            each other, i.e.
            </summary>
      <param name="v1">one node</param>
      <param name="v2">another node</param>
      <returns>
        <see langword="true" /> iff their distance is smaller than
            getMinimalLayerDistance+EPSILON
            </returns>
      <remarks>
            Helper method which checks whether two adjacent nodes on a layer touch
            each other, i.e. their
            distance is smaller than getMinimalLayerDistance(v1, ...)
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PendularDrawer.VerifyMovement(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Assures that if distance was applied to the n's x-coordinate no given constraint gets broken.</summary>
      <param name="n">the node to be moved</param>
      <param name="distance">the distance which shall be verified</param>
      <returns>the distance which can be applied to n without breaking any constraint</returns>
      <remarks>
            Assures that if distance was applied to the n's x-coordinate no given constraint gets broken.
            It makes extensive use of getMinimalLayerDistance(v1, ...)
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.PolylineDrawer">
      <summary>
            This class is an implementation of the third phase of the
            Sugiyama algorithm, which represents edges by  polylines.
            </summary>
      <remarks>
            This class is an implementation of the third phase of the
            Sugiyama algorithm, which represents edges by  polylines.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PolylineDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.PolylineDrawer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PolylineDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Overwrite this method to assign the final coordinates to the
            objects of he graph.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.PortAssignment">
      <summary>This class assigns port coordinates to the edges of a graph.</summary>
      <remarks>This class assigns port coordinates to the edges of a graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PortAssignment.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.PortAssignment" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PortAssignment.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,System.Collections.IComparer,System.Collections.IComparer)">
      <summary>Assigns port coordinates to the edges.</summary>
      <param name="g">graph whose edges need port assignment</param>
      <param name="dummyMark">
            provides boolean data about whether a node
            is a dummy node or not.
            </param>
      <param name="inComp">A Comparator that defines an ordering for edges. This comparator is used for ordering the edges entering a node.</param>
      <param name="outComp">A Comparator that defines an ordering for edges. This comparator is used for ordering the edges leaving a node</param>
      <remarks>
            Assigns port coordinates to the edges. It is assumed that all incoming edges
            of a node connect at the top side of that node and that all outgoing edges
            of a node leave at the bottom side of that node.
            Port assignment will be such that the ports will be spread evenly
            at top and bottom sides of the nodes. Ports will be assigned according to
            the given Comparators.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.PortAssignment.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Assigns port coordinates to the edges.</summary>
      <param name="g">graph whose edges need port assignment</param>
      <param name="layers">the layering of g</param>
      <param name="dummyMark">
            provides boolean data about whether a node
            is a dummy node or not.
            </param>
      <remarks>
            Assigns port coordinates to the edges. It is assumed that all incoming edges
            of a node connect at the top side of that node and that all outgoing edges
            of a node leave at the bottom side of that node.
            Port assignment will be such that the ports will be spread evenly
            at top and bottom sides of the nodes. Ports will be assigned such that
            no unnecessary edge crossings will be introduced.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.RankingPolicy">
      <summary>Ranking policy specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.RankingPolicy.NoReranking">
      <summary>
            Ranking policy specifier. Nodes do not get re-ranked after
            the initial topological layering step.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.RankingPolicy.DownShift">
      <summary>
            Ranking policy specifier. Nodes get re-ranked by an
            inexpensive downshift rule.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.RankingPolicy.TightTree">
      <summary>
            Ranking policy specifier. Nodes get re-ranked by
            finding a spanning tree that contains only tight
            (length 1) edges.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.RoutingStyle">
      <summary>Edge routing style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.RoutingStyle.Polyline">
      <summary>Edge routing style specifier. Routes the edges as polylines.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.RoutingStyle.Orthogonal">
      <summary>
            Edge routing style specifier. Routes the edges orthogonally, i.e.
            all edge segments are either vertically or horizontally aligned.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer">
      <summary>Drawer based on rank-assignment.</summary>
      <remarks>
            Drawer based on rank-assignment.
            The drawer works only with integer values and rounds double values to
            integers.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Assigns the coordinates to the nodes based on simplex-rank assignment.</summary>
      <param name="layerLists">The nodes in each layer.</param>
      <param name="layerID">Provides the layer ID for nodes.</param>
      <remarks>Assigns the coordinates to the nodes based on simplex-rank assignment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.GetCost(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.IEdgeMap,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Returns the overall edge cost of the result.</summary>
      <param name="result">The result to calculate the cost for.</param>
      <param name="weight">Provides the edge weights.</param>
      <param name="minLength">Provides the min length for edges.</param>
      <returns>The total cost given the parameters.</returns>
      <remarks>Returns the overall edge cost of the result.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.IsDummy(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether the given node is a dummy node.</summary>
      <remarks>Returns whether the given node is a dummy node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.MaximalDuration">
      <summary>The time limit (in milliseconds) set for the algorithm.</summary>
      <remarks>
            Getter:<br />
            Returns the time limit (in milliseconds) set for the algorithm.
            <para />
            Setter:<br />
            Sets a preferred time limit (in milliseconds) for the algorithm.
            Note that restricting the maximal duration may result in a worse layout quality.
            Furthermore, the real runtime may exceed the maximal duration since the algorithm
            still have to find a valid solution.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.SimplexDrawer.StraighteningFactor">
      <summary>The straightening factor.</summary>
      <remarks>Specifies the straightening factor. Higher values will result in longer straight line routings.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer">
      <summary>This class implements the first phase of the Sugiyama algorithm.</summary>
      <remarks>
            This class implements the first phase of the Sugiyama algorithm.
            It uses topological sorting to assign layers to the nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
      <remarks>This method assigns the nodes in the graph to layers.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TopologicalLayerer.RankingPolicy">
      <summary>
            The currently active ranking policy within
            this layerer.
            </summary>
      <remarks>
            Setter:<br />
            Sets the (re)ranking policy used within this layerer.
            By default
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.RankingPolicy.NoReranking" />
            is set.
            <para />
            Getter:<br />
            Returns the currently active ranking policy within
            this layerer.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.TreeDrawer">
      <summary>This class implements the third phase of the hierarchic layout algorithm for trees.</summary>
      <remarks>
            This class implements the third phase of the hierarchic layout algorithm for trees. If the input graph is not a tree,
            an alternative drawer is invoked.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.TreeDrawer" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.AlternativeDrawer">
      <summary>The drawer, which is called when graph is not a tree.</summary>
      <remarks>Sets the drawer, which is called when graph is not a tree.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.AssignCoordinates(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Overwrite this method to assign the final coordinates to the
            objects of he graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.MinimalEdgeDistance">
      <summary>The minimal distance between two edges in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.MinimalLayerDistance">
      <summary>The minimal distance between two layers.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.MinimalMultiEdgeDistance">
      <summary>The minimal distance between two edges sharing source/target in the same layer.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.MinimalNodeDistance">
      <summary>The minimal distance between two nodes in the same layer.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.HierarchicTreePlacer">
      <summary>
            places nodes in their given layers (does not change the y coordinates) for the TREE layout style of a
            HierarchicLayouter.
            </summary>
      <remarks>
            places nodes in their given layers (does not change the y coordinates) for the TREE layout style of a
            HierarchicLayouter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.HierarchicTreePlacer.#ctor(System.Double)">
      <summary>creates a new HierarchicTreePlacer.</summary>
      <param name="minimalNodeDistance">the minimal allowed distance between two nodes in the same layer</param>
      <remarks>creates a new HierarchicTreePlacer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.HierarchicTreePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.TreeDrawer.HierarchicTreePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main placeSubtree method that must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer">
      <summary>This class implements the first phase of the hierarchic layouter.</summary>
      <remarks>
            This class implements the first phase of the hierarchic layouter.
            It first makes the directed graph acyclic by topological sorting.
            It then assigns the layers such that edge weights are respected
            A weight defines a minimal distance between the two end points of
            an edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.#ctor">
      <summary>Creates a new weighted layerer.</summary>
      <remarks>Creates a new weighted layerer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.#ctor(System.Object)">
      <summary>Creates a new weighted layerer.</summary>
      <param name="k">the key to access the weights.</param>
      <remarks>Creates a new weighted layerer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignLayers(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Assigns the layers to the nodes.</summary>
      <remarks>Assigns the layers to the nodes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignLayersFast(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Assign the layers to the nodes.</summary>
      <remarks>Assign the layers to the nodes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignNodeLayer(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
      <remarks>This method assigns the nodes in the graph to layers.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
      <remarks>This method assigns the nodes in the graph to layers.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.AssignNodeLayer(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.INodeMap,yWorks.yFiles.Algorithms.EdgeList,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>This method assigns the nodes in the graph to layers.</summary>
      <param name="g">the graph for which the layers are determined.</param>
      <param name="layer">here the layers are stored</param>
      <param name="reversedEdges">here the edges are stored which had been reversed.</param>
      <returns>the number of layers</returns>
      <remarks>This method assigns the nodes in the graph to layers.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.DownShiftNodes(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.INodeMap,System.Int32)">
      <summary>Pushes the nodes down, drawings seems then to be nicer.</summary>
      <remarks>Pushes the nodes down, drawings seems then to be nicer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.GetWeight(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the edge weight of the specified edge for use with the weight
            based cycle removal heuristic.
            </summary>
      <param name="edge">the edge whose weight is returned.</param>
      <returns>the edge weight of the specified edge.</returns>
      <remarks>
            Returns the edge weight of the specified edge for use with the weight
            based cycle removal heuristic.
            <p>
            By default, all edges are considered to have weight <c>1.0</c>.
            </p>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.key">
      <summary>The key to access the weights.</summary>
      <remarks>The key to access the weights.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.MakeDFSAcyclic(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Uses dfs to remove cycles from the graph.</summary>
      <remarks>Uses dfs to remove cycles from the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.MakeDFSAcyclic(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>Uses dfs to remove cycles from the graph.</summary>
      <remarks>Uses dfs to remove cycles from the graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.MaximalDuration">
      <summary>The time limit (in milliseconds) set for the algorithm.</summary>
      <remarks>
            Getter:<br />
            Returns the time limit (in milliseconds) set for the algorithm.
            <para />
            Setter:<br />
            Sets a preferred time limit (in milliseconds) for the algorithm.
            Note that restricting the maximal duration may result in a worse layout quality.
            Furthermore, the real runtime may exceed the maximal duration since the algorithm
            still have to find a valid solution.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.weight">
      <summary>Provides the edge weights.</summary>
      <remarks>Provides the edge weights.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer.WeightedCycleRemoval">
      <summary>
        <see langword="true" /> if the edges that need to be reversed are
            determined using an edge weight based heuristic
            and <see langword="false" /> if a Depth First Search based approach should be
            used.
            </summary>
      <remarks>
            Getter:<br />
            Returns <see langword="true" /> if the edges that need to be reversed are
            determined using an edge weight based heuristic
            and <see langword="false" /> if a Depth First Search based approach should be
            used. The weight based approach may result in fewer reversed edges
            (especially for cases with many multi edges) whereas the DFS based
            approach is likely to be faster.
            <p>
            Defaults to <see langword="false" />.
            </p>
            <para />
            Setter:<br />
            Specifies if the edges that need to be reversed are determined using an
            edge weight based heuristic or using a Depth First Search based approach.
            The weight based approach may result in fewer reversed edges
            (especially for cases with many multi edges) whereas the DFS based
            approach is likely to be faster.
            <p>
            By default, the DFS based approach is used.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.WeightHeuristic">
      <summary>Weight assignment heuristic specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.WeightHeuristic.Barycenter">
      <summary>
            Weight assignment heuristic specifier. A node position within a layer
            will be determined by the barycenter of its
            successor (downward pass) and  predecessor (upward pass) nodes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.WeightHeuristic.Median">
      <summary>
            Weight assignment heuristic specifier. A node position within a layer
            will be determined by the median position of its
            successor (downward pass) and  predecessor (upward pass) nodes.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer">
      <summary>
            A partial implementation of the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer" />
            interface to minimize the effort required to modify
            the port assignment after the sequencing phase.
            </summary>
      <remarks>
            A partial implementation of the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer" />
            interface to minimize the effort required to modify
            the port assignment after the sequencing phase. In this class, the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.OptimizeAfterSequencing(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">callback method invoked after sequencing</see>
            temporarily restores all
            same layer edges which, otherwise, wouldn't be present in the layout graph at this time of the algorithm, then
            invokes the hook in which the custom port assignment should be done, and finally takes care to restore the original
            state of the layout graph by removing the temporary edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.#ctor">
      <summary>Creates a new AbstractPortConstraintOptimizer.</summary>
      <remarks>Creates a new AbstractPortConstraintOptimizer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.InsertSameLayerStructures(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Inserts a same layer edge structure for each same layer edge of the original graph.</summary>
      <param name="graph">the graph to work on.</param>
      <param name="layers">the layering information.</param>
      <param name="ldp">
            the LayoutDataProvider which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            .
            </param>
      <param name="itemFactory">the factory which can set the temporary port constraints.</param>
      <remarks>
            Inserts a same layer edge structure for each same layer edge of the original graph.
            Note that, in this phase of the layout,
            the graph does not contain any same layer edges. The structure for a same layer edge <c>(s,t)</c> consists of
            a temporary node <c>w</c> and the edges <c>(s,w)</c> and <c>(t,w)</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.LayoutOrientation">
      <summary>The currently set layout orientation for this class.</summary>
      <remarks>
            Setter:<br />
            Sets the layout orientation that is used by this class. This setting is necessary to correctly interpret the values
            provided in the
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s since the
            <see cref="T:yWorks.yFiles.Layout.OrientationLayouter" />
            cannot automatically
            adjust these values.
            <para />
            Getter:<br />
            Returns the currently set layout orientation for this class.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.MirrorMask">
      <summary>The mirror mask that defines which orientations should be mirrored.</summary>
      <remarks>
            Specifies the mirror mask that defines which orientations should be mirrored. Setting a layout orientation can be
            seen as rotating the graph 90, 180 or 270 degrees. Afterwards the graph can be mirrored at the x-Axis (for
            horizontal layout orientations) or y-Axis (for vertical layout orientations). Which directions are mirrored can be
            defined by the given mask.
            <p />
            By default a mirror mask is set, where
            <see cref="F:yWorks.yFiles.Layout.LayoutOrientation.BottomToTop" />
            will be mirrored at the
            y-Axis.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.OptimizeAfterLayering(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Called after the layering information has been determined.</summary>
      <param name="graph">the graph to work on</param>
      <param name="layers">the layering information</param>
      <param name="ldp">
            the implementation which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            instances
            </param>
      <param name="itemFactory">the factory to set the temporary port constraints with</param>
      <remarks>
            Called after the layering information has been determined. This method can be used to assign new temporary port
            constraints for the next phases of the algorithm. In this phase, it is possible to create back-loops by assigning
            in-edges to the south side or out-edges to the north side, respectively.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.OptimizeAfterSequencing(System.Collections.IComparer,System.Collections.IComparer,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Called after the sequence of the nodes has been determined to assign new temporary port constraints to all nodes.</summary>
      <param name="inEdgeOrder">
            a
            <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators.IPartialOrder" />
            which defines the preferred ordering of the in-edges from left to right.
            Note: to sort collections according to a PartialOrder, an appropriate method like
            <see cref="M:yWorks.yFiles.Algorithms.Util.Comparators.Sort(yWorks.yFiles.Util.IList,System.Collections.IComparer)" />
            or
            <see cref="M:yWorks.yFiles.Algorithms.YList.Sort" />
            must be used.
            </param>
      <param name="outEdgeOrder">
            a
            <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators.IPartialOrder" />
            which defines the preferred ordering of the out-edges from left to
            right. Note: to sort collections according to a PartialOrder, an appropriate method like
            <see cref="M:yWorks.yFiles.Algorithms.Util.Comparators.Sort(yWorks.yFiles.Util.IList,System.Collections.IComparer)" />
            or
            <see cref="M:yWorks.yFiles.Algorithms.YList.Sort" />
            must be used.
            </param>
      <param name="graph">the graph to work on.</param>
      <param name="ldp">
            the LayoutDataProvider which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            .
            </param>
      <param name="itemFactory">the factory which can set the temporary port constraints.</param>
      <remarks>
            Called after the sequence of the nodes has been determined to assign new temporary port constraints to all nodes.
            This method invokes
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.OptimizeAfterSequencing(yWorks.yFiles.Algorithms.Node,System.Collections.IComparer,System.Collections.IComparer,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)" />
            for every node of the original layout graph, and omits the nodes of the same layer structures.
            <p />
            Note that, in this phase, it's not allowed to create back-loops, that is, in-edges must not connect to the south
            side and out-edges must not connect to the north side.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.OptimizeAfterSequencing(yWorks.yFiles.Algorithms.Node,System.Collections.IComparer,System.Collections.IComparer,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called after the sequence of the nodes has been determined to assign new temporary port constraints to each
            original node.
            </summary>
      <param name="node">the original node to set temporary port constraints at.</param>
      <param name="inEdgeOrder">
            a
            <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators.IPartialOrder" />
            which defines the preferred ordering of the in-edges from left to right.
            Note: to sort collections according to a PartialOrder, an appropriate method like
            <see cref="M:yWorks.yFiles.Algorithms.Util.Comparators.Sort(yWorks.yFiles.Util.IList,System.Collections.IComparer)" />
            or
            <see cref="M:yWorks.yFiles.Algorithms.YList.Sort" />
            must be used.
            </param>
      <param name="outEdgeOrder">
            a
            <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators.IPartialOrder" />
            which defines the preferred ordering of the out-edges from left to
            right. Note: to sort collections according to a PartialOrder, an appropriate method like
            <see cref="M:yWorks.yFiles.Algorithms.Util.Comparators.Sort(yWorks.yFiles.Util.IList,System.Collections.IComparer)" />
            or
            <see cref="M:yWorks.yFiles.Algorithms.YList.Sort" />
            must be used.
            </param>
      <param name="graph">the graph to work on.</param>
      <param name="ldp">
            the LayoutDataProvider which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            .
            </param>
      <param name="itemFactory">the factory which can set the temporary port constraints.</param>
      <remarks>
            Called after the sequence of the nodes has been determined to assign new temporary port constraints to each
            original node.
            <p />
            Note that, in this phase, it's not allowed to create back-loops, that is, in-edges must not connect to the south
            side and out-edges must not connect to the north side.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.OptimizeAfterSequencing(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Called after the sequence of the nodes has been determined to assign new temporary port constraints.</summary>
      <param name="graph">the graph to work on.</param>
      <param name="layers">the layering information.</param>
      <param name="ldp">
            the LayoutDataProvider which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            .
            </param>
      <param name="itemFactory">the factory which can set the temporary port constraints.</param>
      <remarks>
            Called after the sequence of the nodes has been determined to assign new temporary port constraints. This method
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.InsertSameLayerStructures(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">inserts the same layer strucutres</see>
            , invokes
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.OptimizeAfterSequencing(yWorks.yFiles.Algorithms.Node,System.Collections.IComparer,System.Collections.IComparer,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">the hook</see>
            in which the custom port assignment should be done, and finally takes care to
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.RemoveSameLayerStructures(yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.SameLayerData,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">restore the original state</see>
            of the layout graph by removing the temporary edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.RemoveSameLayerStructures(yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.SameLayerData,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Removes the same layer edge structure created in
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.InsertSameLayerStructures(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)" />
            .
            </summary>
      <param name="sameLayerData">the information about the same layer structures.</param>
      <param name="graph">the graph to work on.</param>
      <param name="ldp">
            the LayoutDataProvider which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            .
            </param>
      <param name="itemFactory">the factory which can set the temporary port constraints.</param>
      <remarks>
            Removes the same layer edge structure created in
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.InsertSameLayerStructures(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.SameLayerData">
      <summary>
            Provides information about the same layer structures created by class
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer" />
            .
            </summary>
      <remarks>
            Provides information about the same layer structures created by class
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.SameLayerData.#ctor">
      <summary>Creates a new SameLayerData.</summary>
      <remarks>Creates a new SameLayerData.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.SameLayerData.AddDummyNode(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>Adds a new dummy node and associates it with the given original (same layer) edge.</summary>
      <param name="sameLayerDummy">a dummy node.</param>
      <param name="originalEdge">the original (same layer) edge associated to the sameLayerDummy.</param>
      <remarks>Adds a new dummy node and associates it with the given original (same layer) edge.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.SameLayerData.DummyNodes">
      <summary>All dummy nodes.</summary>
      <remarks>Returns all dummy nodes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AbstractPortConstraintOptimizer.SameLayerData.GetOriginalEdge(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the original (same layer) edge associated with the given dummy node.</summary>
      <param name="sameLayerDummy">a dummy node.</param>
      <returns>the original (same layer) edge associated with the given dummy node.</returns>
      <remarks>Returns the original (same layer) edge associated with the given dummy node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.AsIsSequencer">
      <summary>
            Sequencer implementation that returns a sequencing that
            corresponds to the current drawing.
            </summary>
      <remarks>
            Sequencer implementation that returns a sequencing that
            corresponds to the current drawing.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AsIsSequencer.#ctor">
      <summary>Creates a new AsIsSequencer</summary>
      <remarks>Creates a new AsIsSequencer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AsIsSequencer.SequenceNodeLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the second phase.
            </summary>
      <param name="graph">the graph that contains the elements from <c>layers</c></param>
      <param name="layers">the Layer implementation that holds the Layers for sequencing</param>
      <param name="ldp">
            the LayoutDataProvider that provides the necessary
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" /></param>
      <param name="itemFactory">
            an ItemFactory implementation that can be used to modify the
            graph consistently
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.AspectRatioComponentLayerer">
      <summary>
            Wrapper Layerer implementation that delegates the actual layering to a
            delegate Layerer.
            </summary>
      <remarks>
            Wrapper Layerer implementation that delegates the actual layering to a
            delegate Layerer. If the graph consists of multiple components, they will
            be identified and each of the components will be layered separately
            using the delegate Layerer instance. After that they will all be merged
            such that the desired aspect ratio is fulfilled best.
            Note that for grouped graphs the desired aspect ratio is also considered for each group node separately.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AspectRatioComponentLayerer.#ctor(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer)">
      <summary>
            Creates a new instance of AspectRatioComponentLayerer using the given
            delegate.
            </summary>
      <remarks>
            Creates a new instance of AspectRatioComponentLayerer using the given
            delegate.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.AspectRatioComponentLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.AspectRatioComponentLayerer.ConsiderNodeSize">
      <summary>Specifies whether the node size should be considered.</summary>
      <remarks>
            Getter:<br />
            Returns whether the node size should be considered.
            <para />
            Setter:<br />
            Whether or not the node size should be considered.
            If this option is disabled, all nodes are considered to be of equal size.
            Hence, the given aspect ratio specifies the ratio between the number of nodes within a layer and the overall number of layers.
            The default value is true.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.AspectRatioComponentLayerer.DesiredAspectRatio">
      <summary>The desired aspect ratio.</summary>
      <remarks>
            Specifies the desired aspect ratio. If the graph consists of multiple components, they will
            be identified and each of the components will be layered separately
            using the delegate Layerer instance. After that they will all be merged
            such that the desired aspect ratio is fulfilled best.
            Note that for grouped graphs the desired aspect ratio is also considered for each group node separately.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.AspectRatioComponentLayerer.SingleComponentLayerer">
      <summary>The Layerer instance that is used for delegation.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Getter:<br />
            Returns the Layerer instance that is used for delegation.
            <para />
            Setter:<br />
            Sets the new delegate Layerer instance.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor">
      <summary>
            This class represents a column of a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid" />
            .
            </summary>
      <remarks>
            This class represents a column of a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid" />
            .
            <br />
            The results of the calculation of the geometry of the column will be placed
            into the instances of this class after the layout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.CompareTo(System.Object)">
      <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
      <param name="obj">An object to compare with this instance. </param>
      <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj" />. Zero This instance is equal to <paramref name="obj" />. Greater than zero This instance is greater than <paramref name="obj" />. </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance. </exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.ComputedPosition">
      <summary>
            The computed position (smaller x-coordinate) of the column
            after the layout has been calculated.
            </summary>
      <remarks>
            Used to set the computed position (smaller x-coordinate) of the column
            after the layout has been calculated.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.ComputedWidth">
      <summary>
            The computed width of the column
            after the layout has been calculated.
            </summary>
      <remarks>
            Used to set the computed width of the column
            after the layout has been calculated.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.Index">
      <summary>The index of the column within the partition grid.</summary>
      <remarks>Returns the index of the column within the partition grid.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.IndexFixed">
      <summary>
            Specifies whether the index of this column is fixed or whether
            the algorithm should try to find the best possible position.
            </summary>
      <remarks>
            Getter:<br />
            Returns whether the index of this column is fixed or whether
            the algorithm should try to find the best possible position.
            The default is <see langword="true" />
            <para />
            Setter:<br />
            Specifies whether a column's index is fixed or whether the index should be chosen automatically in order
            to minimize edge lengths.
            <p>
            For all columns where this property is set to <see langword="true" />, the relative ordering given by the indices
            is preserved. The remaining columns may be resorted so that the overall edge lengths are minimized.
            </p>
            <p>
            By default, this feature is enabled. </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.LeftInset">
      <summary>
            The left column insets where no element
            will lie in the resulting drawing.
            </summary>
      <exception cref="T:System.ArgumentException">if leftInset is negative</exception>
      <remarks>
            Specifies the left column insets where no element
            will lie in the resulting drawing.
            The default is <c>0.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.MinimumWidth">
      <summary>The minimum column width.</summary>
      <exception cref="T:System.ArgumentException">if minimumWidth is negative</exception>
      <remarks>
            Getter:<br />
            Returns the minimum column width.
            The default is <c>0.0d</c>.
            <para />
            Setter:<br />
            Sets the minimum width of the column.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.OriginalPosition">
      <summary>The original position (smaller x-coordinate) of the column.</summary>
      <remarks>Specifies the original position (smaller x-coordinate) of the column.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.OriginalWidth">
      <summary>The original width of the column.</summary>
      <remarks>Specifies the original width of the column.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.RightInset">
      <summary>
            The right column insets where no element
            will lie in the resulting drawing.
            </summary>
      <exception cref="T:System.ArgumentException">if rightInset is negative</exception>
      <remarks>
            Specifies the right column insets where no element
            will lie in the resulting drawing.
            The default is <c>0.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.Tightness">
      <summary>The tightness factor of the column.</summary>
      <exception cref="T:System.ArgumentException">if tightness is out of the valid range</exception>
      <remarks>
            Getter:<br />
            Returns the tightness factor of the column.
            The default is <c>0.0d</c>.
            <para />
            Setter:<br />
            Sets the tightness factor of the column. The greater the value the
            more will the column to be forced to be of its minimal possible width.
            A value of <c>0.0d</c> will disable compression of the column.
            A value of <c>1.0d</c> will try to force the column to be of
            its
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.MinimumWidth">minimum width</see>
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ConstraintIncrementalLayerer">
      <summary>
            Layerer implementation that observes relative and absolute layering constraints defined by the layering constraint
            factory
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory" />
            .
            </summary>
      <remarks>
            Layerer implementation that observes relative and absolute layering constraints defined by the layering constraint
            factory
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory" />
            .
            For a given graph instance, this factory can be created with method
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateLayerConstraintFactory(yWorks.yFiles.Algorithms.Graph)" />
            .
            The Layerer can be used for both common layering and layering of incremental nodes.
            <p />
            Note: This layerer is always used automatically if the graph instance has constraints created with the layering
            constraint factory.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ConstraintIncrementalLayerer.#ctor(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ConstraintIncrementalLayerer" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ConstraintIncrementalLayerer.AllowSameLayerEdges">
      <summary>Specifies whether same layer edges can be created by this layerer instance.</summary>
      <remarks>
            Specifies whether same layer edges can be created by this layerer instance.
            <p>
            This only concerns edges between nodes that have no hard constraints that
            will force a same layer edge (i.e. a same layer constraint).
            </p><p>
            Default value is <see langword="false" />.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ConstraintIncrementalLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Calculates a layering for the given graph.</summary>
      <param name="g">the graph containing all nodes and edges.</param>
      <param name="layers">
            a structure that is filled by the layerer. If the layerer is used for layering incremental nodes,
            the layers structure already have to contain all non-incremental nodes.
            </param>
      <remarks>Calculates a layering for the given graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ConstraintIncrementalLayerer.CheckConstraints">
      <summary>Checks if the current set of strong constraints is consistent (i.e.</summary>
      <exception cref="T:System.ArgumentException">if the constraint network is inconsistent</exception>
      <remarks>Checks if the current set of strong constraints is consistent (i.e. has no cycles)</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.ConstraintIncrementalLayerer.EdgeWeightsDpKey">
      <summary>DataProvider key for additional edge weights of type <c>int</c>.</summary>
      <remarks>
            DataProvider key for additional edge weights of type <c>int</c>.
            <p>
            The Layerer tries to keep edges with higher weights short.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator">
      <summary>
            A default
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator" />
            implementation that is used
            by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            to configure the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer" />
            .
            </summary>
      <remarks>
            A default
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator" />
            implementation that is used
            by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            to configure the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.#ctor">
      <summary>
            Creates a new instance of DefaultDrawingDistanceCalculator
            with default settings.
            </summary>
      <remarks>
            Creates a new instance of DefaultDrawingDistanceCalculator
            with default settings.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.Dispose(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to dispose internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that was used</param>
      <param name="ldp">the LayoutDataProvider that was used to query information</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.Edge2EdgeDistance">
      <summary>The minimum distance between two edges.</summary>
      <remarks>
            Specifies the minimum distance between two edges.
            Default is <c>20.0d</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.GetMinDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Main interface method.</summary>
      <param name="graph">the graph that contains the nodes</param>
      <param name="layer">the layer object that contains the nodes</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
      <param name="left">
            the left one of the two nodes whose
            minimum distance is to be determined or <see langword="null" /> if only the left border of the right node is
            of interest.
            </param>
      <param name="right">
            the right one of the two nodes whose
            minimum distance is to be determined or <see langword="null" /> if only the right border of the left node is
            of interest.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.Initialize(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to initialize internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that will be used during subsequent calls</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.Node2EdgeDistance">
      <summary>The minimum distance between a node and an (non-adjacent) edge.</summary>
      <remarks>
            Specifies the minimum distance between a node and an (non-adjacent) edge.
            Default is <c>15.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.Node2NodeDistance">
      <summary>The minimum distance between two nodes.</summary>
      <remarks>
            Specifies the minimum distance between two nodes.
            Default is <c>30.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.OptimizeSwimLaneDistances">
      <summary>
            Specifies whether the optimized minimum distance calculation for swim lane layouts
            is enabled.
            </summary>
      <remarks>
            Specifies whether or not to use an optimized minimum distance calculation
            for swim lane layouts.
            If set to <see langword="true" /> this instance will report <c>0.0d</c>
            as the minimum distance between two nodes if they belong to different swim
            lanes. This avoids unwanted feedback between different swim lanes during
            node placement.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator.UseAdaptiveMinEdgeDistance">
      <summary>Specifies whether or not an adaptive minimum edge distance should be used.</summary>
      <remarks>
            Specifies whether or not an adaptive minimum edge distance should be used.
            If this option is enabled the minimum distance between two adjacent edges is the minimum of the set
            minimum edge distance and the distance of the edges' source/target points.
            By default this option is enabled.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger">
      <summary>
            A default implementation of a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger" />
            that provides
            simple default behaviors.
            </summary>
      <remarks>
            A default implementation of a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger" />
            that provides
            simple default behaviors. Instances of this class are used internally
            by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer" />
            e.g.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger.#ctor">
      <summary>
            Creates a new instance of DefaultLayeredComponentsMerger
            with default policy (
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddRightTopAligned" />
            )
            </summary>
      <remarks>
            Creates a new instance of DefaultLayeredComponentsMerger
            with default policy (
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddRightTopAligned" />
            )
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger.#ctor(yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy)">
      <summary>
            Creates a new instance of DefaultLayeredComponentsMerger
            using the given policy constant.
            </summary>
      <remarks>
            Creates a new instance of DefaultLayeredComponentsMerger
            using the given policy constant.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger.Merge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)">
      <summary>
            All nodes in srcLayers and targetLayers are part of graph at the moment of
            invocation.
            </summary>
      <param name="graph">
            the graph that contains the nodes in <c>srcLayers</c> and
            <c>targetLayers</c>.
            </param>
      <param name="ldp">the LayoutDataProvider that can be used to query the layer indices</param>
      <param name="srcLayers">
            the Layers implementation that contains the layers that
            will be merged into <c>targetLayers</c></param>
      <param name="targetLayers">
            the Layers that will be modified to contain the resulting
            layering
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger.Policy">
      <summary>The current policy constant.</summary>
      <remarks>
            Getter:<br />
            Returns the current policy constant.
            <para />
            Setter:<br />
            Sets the policy constant as defined in
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer">
      <summary>This class implements the second phase of the Sugiyama algorithm.</summary>
      <remarks>
            This class implements the second phase of the Sugiyama algorithm.
            It minimizes the crossings in the diagram by using either the
            barycentric or median heuristic.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.#ctor">
      <summary>Initializes a new instance of the DefaultLayerSequencer class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.GroupTranspositionEnabled">
      <summary>
            Specifies whether or not the group transposition heuristic should
            be used.
            </summary>
      <remarks>
            Setter:<br />
            Specifies whether or not an additional crossing minimization heuristic
            should be used in the presence of grouped graphs. Activating this heuristic can reduce the overall
            number of edge crossings in grouped graphs. On the other hand its activation
            increases running time.
            <p />
            By default the transposition rule is not active.
            <para />
            Getter:<br />
            Returns whether or not the group transposition heuristic should
            be used.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.MaximalDuration">
      <summary>The proposed maximal duration for the calculation of the sequence.</summary>
      <remarks>
            Getter:<br />
            Returns the proposed maximal duration for the calculation of the sequence.
            The default is <c>10000</c>
            <para />
            Setter:<br />
            Sets the maximum amount of time granted for
            this sequencer per execution.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.RandomizationRounds">
      <summary>
            The number of randomized rounds this algorithm will try
            if there was no optimal solution.
            </summary>
      <remarks>
            Getter:<br />
            Returns the number of randomized rounds this algorithm will try
            if there was no optimal solution.
            <para />
            Setter:<br />
            Sets the number of additional rounds the algorithm will restart with randomized
            solutions as long as there might be a better solution to the current best.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.SequenceNodeLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the second phase.
            </summary>
      <param name="graph">the graph that contains the elements from <c>layers</c></param>
      <param name="layers">the Layer implementation that holds the Layers for sequencing</param>
      <param name="ldp">
            the LayoutDataProvider that provides the necessary
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" /></param>
      <param name="itemFactory">
            an ItemFactory implementation that can be used to modify the
            graph consistently
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.TranspositionEnabled">
      <summary>
            Specifies whether or not the transposition crossing minimization heuristic
            should be used.
            </summary>
      <remarks>
            Setter:<br />
            Specifies whether or not an additional crossing minimization heuristic
            should be used. Activating this heuristic can reduce the overall
            number of edge crossings. On the other hand its activation
            increases running time.
            <p />
            By default the transposition rule is active.
            <para />
            Getter:<br />
            Returns whether or not the transposition crossing minimization heuristic
            should be used.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayerSequencer.WeightHeuristic">
      <summary>The currently set weight heuristic.</summary>
      <exception cref="T:System.ArgumentException">if the constant is unknown</exception>
      <remarks>
            Setter:<br />
            Sets the weight heuristic to be used.
            By default
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.WeightHeuristic.Barycenter" />
            is set.
            <para />
            Getter:<br />
            Returns the currently set weight heuristic.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator">
      <summary>Default implementation of the PortAllocator interface.</summary>
      <remarks>Default implementation of the PortAllocator interface.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.#ctor">
      <summary>Creates a new instance of DefaultPortAllocator with default settings</summary>
      <remarks>Creates a new instance of DefaultPortAllocator with default settings</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Assigns the port positions for the drawer.</summary>
      <param name="graph">the graph</param>
      <param name="layers">the layering</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
      <param name="itemFactory">the ItemFactory that can be used for temporarily altering the graph</param>
      <remarks>
            Assigns the port positions for the drawer.
            Assigns
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            ports to appropriate sides.
            Assigns
            <see cref="P:yWorks.yFiles.Layout.PortConstraint.Strong">weak</see>
            ports to appropriate positions between strong ones
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.DefaultPortBorderGapRatio">
      <summary>The default port to border gap ratio.</summary>
      <remarks>
            Getter:<br />
            Returns the default port to border gap ratio.
            <para />
            Setter:<br />
            Sets for default port to border gap ratio.
            This ratio determines the gap between a corner of the node and the first
            assigned port. A value of <c>0.0d</c> results in ports being
            placed directly on the corner of the node (if there is more than one port).
            The default value of <c>0.5d</c> results in ports being distributed
            along the side of the node so that the distance between the corner of the node
            and the first port is half as wide as the distance between two adjacent ports.
            A value of <c>Double.POSITIVE_INFINITY</c> results in all ports being
            centered at the side in one point.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.GetPortBorderGap(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,System.Int32,System.Double,System.Int32)">
      <summary>
            Callback method used to determine the port border gap for each node and
            side.
            </summary>
      <param name="graph">the graph</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information from</param>
      <param name="node">the node</param>
      <param name="sideIndex">the zero based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)</param>
      <param name="sideLength">the width/height of the side</param>
      <param name="edgeCount">the number of edges/port that connect to this side</param>
      <returns>the absolute gap to be used on both sides of the ports</returns>
      <remarks>
            Callback method used to determine the port border gap for each node and
            side.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.GetPortBorderGapRatio(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,System.Int32,System.Double,System.Int32)">
      <summary>Callback method used to determine the port border gap ratio.</summary>
      <param name="graph">the graph</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information from</param>
      <param name="node">the node</param>
      <param name="sideIndex">the zero based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)</param>
      <param name="sideLength">the width/height of the side</param>
      <param name="edgeCount">the number of edges/port that connect to this side</param>
      <returns>the ratio</returns>
      <remarks>
            Callback method used to determine the port border gap ratio.
            See
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.DefaultPortBorderGapRatio" />
            for an explanation.
            This implementation returns the same value as
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.DefaultPortBorderGapRatio" />
            does.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultPortAllocator.GetPortDistanceDelta(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,System.Int32,System.Double,System.Int32,System.Double)">
      <summary>Callback method used to determine the distance between two adjacent ports</summary>
      <param name="graph">the graph</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information from</param>
      <param name="node">the node</param>
      <param name="sideIndex">the zero based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)</param>
      <param name="sideLength">the width/height of the side</param>
      <param name="edgeCount">the number of edges/port that connect to this side</param>
      <param name="portBorderGap">the previously calculated port border gap</param>
      <returns>the absolute distance to be used between two adjacent ports</returns>
      <remarks>Callback method used to determine the distance between two adjacent ports</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType" />
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.Normal">
      <summary>Describes a normal edge.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.SourceGroupNodeConnector">
      <summary>Describes an edge that connects to a source group node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.TargetGroupNodeConnector">
      <summary>Describes an edge that connects to a target group node.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.GroupNodeInterconnector">
      <summary>Describes an edge that connects two group nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.DirectSameLayerEdge">
      <summary>Describes a same layer edge that connects two neighbouring nodes directly.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.NonDirectSameLayerEdge">
      <summary>Describes a same layer edge that connects two neighbouring nodes directly.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.BorderEdge">
      <summary>Describes an edge that connects group border nodes in adjacent layers</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor">
      <summary>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the various
            phases to determine the routing details of the graph's edges.
            </summary>
      <remarks>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the various
            phases to determine the routing details of the graph's edges. <br />
            Note: not all of these values will be used for all kinds of edges and
            any kind of algorithm.
            <br />
            This class is designed as a class to allow for future additions of new getter
            methods.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.#ctor">
      <summary>
            Creates a new instance of an EdgeLayoutDescriptor using the
            default values.
            </summary>
      <remarks>
            Creates a new instance of an EdgeLayoutDescriptor using the
            default values.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumDistance">
      <summary>The <i>preferred</i> minimum distance of the edge to obstacles.</summary>
      <remarks>
            Setter:<br />
            Sets the <i>preferred</i> minimum distance to obstacles.
            <para />
            Getter:<br />
            Returns the <i>preferred</i> minimum distance of the edge to obstacles.
            Default is <c>10.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumFirstSegmentLength">
      <summary>The minimum length of the first segment (at the source).</summary>
      <remarks>
            Specifies the minimum length of the first segment (at the source).
            If the value is <c>0.0d</c> the first segment does not need to be
            orthogonal.
            Default is <c>10.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumLastSegmentLength">
      <summary>The minimum length of the last segment (at the target).</summary>
      <remarks>
            Specifies the minimum length of the last segment (at the target).
            If the value is <c>0.0d</c> the last segment does not need to be
            orthogonal.
            Default is <c>15.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumLength">
      <summary>
            The minimum length of the edge if the edge does not contain any
            This is used for polyline routing.
            </summary>
      <remarks>
            Setter:<br />
            Sets the minimum length of the edge.
            This is used for polyline routing. It describes the minimum vertical length
            of the mid segment (the one that may be routed non-orthogonally).
            <para />
            Getter:<br />
            Returns the minimum length of the edge if the edge does not contain any
            This is used for polyline routing. It describes the minimum vertical length
            of the mid segment (the one that may be routed non-orthogonally).
            Default is <c>20.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.MinimumSlope">
      <summary>
            The minimum slope this edge's mid-segments should have if the edge
            is routed polygonal in vertical layouts.
            </summary>
      <remarks>
            Specifies the minimum slope this edge's mid-segments should have if the edge
            is routed polygonal in vertical layouts.
            <p>
            Default is <c>0.3d</c>.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.OrthogonallyRouted">
      <summary>Determines whether this edge should be routed orthogonally.</summary>
      <remarks>
            Determines whether this edge should be routed orthogonally.
            Default is <see langword="false" />.
            This does not affect the routing of bus-like structures.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.SourcePortOptimizationEnabled">
      <summary>Specifies whether source port optimization is enabled, i.e.</summary>
      <remarks>
            Specifies whether source port optimization is enabled, i.e. whether
            the algorithm should try to find a better source
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            if the current constraint is <see langword="null" /> or
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            .
            Default is <see langword="false" />, which will result in ports being placed at the side of
            the node which lies closest to the target of the edge in terms of layering.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor.TargetPortOptimizationEnabled">
      <summary>Specifies whether target port optimization is enabled, i.e.</summary>
      <remarks>
            Specifies whether target port optimization is enabled, i.e. whether
            the algorithm should try to find a better target
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            if the current constraint is <see langword="null" /> or
            <see cref="F:yWorks.yFiles.Layout.PortSide.Any" />
            .
            Default is <see langword="false" />, which will result in ports being placed at the side of
            the node which lies closest to the source of the edge in terms of layering.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.GivenSequenceSequencer">
      <summary>
            This LayerSequencer implementation returns a sequencing that satisfies
            a comparator constraint.
            </summary>
      <remarks>
            This LayerSequencer implementation returns a sequencing that satisfies
            a comparator constraint.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GivenSequenceSequencer.#ctor">
      <summary>Creates a new instance of GivenSequenceSequencer</summary>
      <remarks>Creates a new instance of GivenSequenceSequencer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GivenSequenceSequencer.#ctor(System.Collections.IComparer)">
      <summary>
            Creates a new instance of GivenSequenceSequencer using the specified
            comparator for the sequencing.
            </summary>
      <remarks>
            Creates a new instance of GivenSequenceSequencer using the specified
            comparator for the sequencing.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.GivenSequenceSequencer.SequenceComparator">
      <summary>The comparator used by this <c>GivenSequenceSequencer</c>.</summary>
      <remarks>Specifies the comparator used by this <c>GivenSequenceSequencer</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GivenSequenceSequencer.SequenceNodeLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the second phase.
            </summary>
      <param name="graph">the graph that contains the elements from <c>layers</c></param>
      <param name="layers">the Layer implementation that holds the Layers for sequencing</param>
      <param name="ldp">
            the LayoutDataProvider that provides the necessary
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" /></param>
      <param name="itemFactory">
            an ItemFactory implementation that can be used to modify the
            graph consistently
            </param>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupCompactionPolicy">
      <summary>
            Compaction strategy specifier for use with
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GroupCompactionStrategy" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupCompactionPolicy.None">
      <summary>
            Compaction strategy specifier for use with
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GroupCompactionStrategy" />
            .
            This specifies no horizontal group compaction, i.e. group node contents will occupy nearly the same horizontal positions as when not grouped at all.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupCompactionPolicy.Maximal">
      <summary>
            Compaction strategy specifier for use with
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GroupCompactionStrategy" />
            .
            This specifies maximal horizontal group compaction, i.e. the node placer will try to minimize the horizontally occupied space for a group node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport">
      <summary>Helper class that is used to manage hierarchically grouped graphs.</summary>
      <remarks>Helper class that is used to manage hierarchically grouped graphs.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.Active">
      <summary>Specifies whether or not groupingSupport is active.</summary>
      <remarks>
            Returns whether or not groupingSupport is active. All return values of the methods of this
            class will be invalid if groupingSupport is inactive.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.AssignEdgeGroupNodesToGroups(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)" />
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.AssignLabelNodesToGroups(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)" />
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.GetChildren(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the direct children of the given group node.</summary>
      <remarks>Returns the direct children of the given group node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.GetDecendants(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns all direct and indirect children of the given group node.</summary>
      <remarks>Returns all direct and indirect children of the given group node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.GetParentNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the parent group node of the given node, or <see langword="null" /> if the given node is a top-level node.</summary>
      <remarks>Returns the parent group node of the given node, or <see langword="null" /> if the given node is a top-level node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.HideGroupNodes">
      <summary>Hides the group nodes and adjacent edges from the graph.</summary>
      <remarks>Hides the group nodes and adjacent edges from the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.IsDescendant(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is a direct or indirect child of the given group node.</summary>
      <remarks>Returns whether or not the given node is a direct or indirect child of the given group node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.IsGroupNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns whether or not the given node is a non-empty group node.</summary>
      <remarks>Returns whether or not the given node is a non-empty group node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.MinimumGroupDistance" />
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.RemoveEdgeGroupAssignment(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)" />
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.UnhideGroupNodes">
      <summary>Unhides all previously hidden group nodes and adjacent edges</summary>
      <remarks>Unhides all previously hidden group nodes and adjacent edges</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.VisitDecendants(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.IVisitor)">
      <summary>Visits all descendants of the given group node.</summary>
      <remarks>Visits all descendants of the given group node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.IVisitor">
      <summary>Visitor interface that can be used to traverse the descendants of a group node</summary>
      <remarks>Visitor interface that can be used to traverse the descendants of a group node</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.GroupingSupport.IVisitor.Visit(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)" />
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter">
      <summary>This class can be used to create hierarchical layouts of graphs.</summary>
      <remarks>
            This class can be used to create hierarchical layouts of graphs.
            It has built-in support for incrementally adding elements to a previously
            calculated layout or optimizing existing elements
            of a previously calculated layout.
            <p />
            In order to customize this layout algorithm, modify the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.Layerer">Layerer</see>
            ,
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.Sequencer">Sequencer</see>
            ,
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PortAllocator">PortAllocator</see>
            ,
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DrawingDistanceCalculator">DrawingDistanceCalculator</see>
            , and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.NodePlacer">NodePlacer</see>
            instances.
            <p />
            Use the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHintsDpKey" />
            
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key to
            associate incremental hints with the elements in the graph.
            <br />
            Incremental Hints can be obtained from the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateIncrementalHintsFactory">IncrementalHintsFactory</see>
            .
            They are used by the algorithm to determine which elements in the graph
            have to be inserted/updated incrementally.
            <p />
            This layout algorithm respects
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            s, that are bound to
            the graph using the
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
            as well as
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
            DataProviders that can be used
            to create bus-like edge routings.
            <p />
            Fine-grained configuration of the layout style
            is supported via DataProviders that are bound to the graph using the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.EdgeLayoutDescriptorDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.NodeLayoutDescriptorDpKey" />
            DataProvider keys.
            <br />
            They can be used to associate
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor" />
            instances with each element in the graph. These
            may be shared.
            <p />
            This algorithm sets a
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            instance as the current
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter" />
            and configures it so that
            the node labels are passed to by setting
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels" />
            to <see langword="true" />.
            <br />
            In order to enable integrated edge labeling of this algorithm, make sure
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            is registered and edge labels are being translated
            and written back after the layout.
            <p />
            This algorithm also support swimlane style drawings. This can be enabled by
            associating
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor" />
            instances with the nodes in the graph
            using the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.SwimlaneDescriptorDpKey" />
            DataProvider key.
            <p />
            Moreover, this algorithm supports sequence constraints. These constraints
            can be specified using a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory" />
            .
            <p />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.#ctor">
      <summary>Creates a new instance of HierarchicLayouter with default settings.</summary>
      <remarks>Creates a new instance of HierarchicLayouter with default settings.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Always returns true.</summary>
      <param name="graph">the graph to check</param>
      <returns>
        <see langword="true" />
      </returns>
      <remarks>Always returns true.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateDrawingDistanceCalculator">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>a default implementation (<c>new DefaultDrawingDistanceCalculator()</c>)</returns>
      <remarks>Factory method that is called lazily upon first usage.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateEdgeReverser">
      <summary>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <returns>an implementation</returns>
      <remarks>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            Creates an appropriate EdgeReverser implementation
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateGrouping(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <param name="graph">the graph to obtain the grouping information from.</param>
      <returns>a Grouping or <see langword="null" /> if there is no grouping information associated with the graph.</returns>
      <remarks>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateIncrementalHintsFactory">
      <summary>
            Returns an
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory" />
            implementation that can be used to obtain hint objects that can be
            associated with nodes and edges in the graph prior to the invocation of the layout algorithm using an appropriate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            implementation and the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHintsDpKey" />
            DataProvider key.
            </summary>
      <returns>an instance that can be used with this layouter instance</returns>
      <remarks>
            Returns an
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory" />
            implementation that can be used to obtain hint objects that can be
            associated with nodes and edges in the graph prior to the invocation of the layout algorithm using an appropriate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            implementation and the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHintsDpKey" />
            DataProvider key.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateIncrementalLayerer">
      <summary>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <returns>an implementation</returns>
      <remarks>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            Creates an appropriate IncrementalLayerer implementation
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateItemData(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <param name="g">the graph to obtain the grouping information from.</param>
      <param name="itemFactory">the ItemFactory to use</param>
      <remarks>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            . This method creates the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            instances and binds them to the elements using the itemFactory.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateLabelLayouter">
      <summary>
            Factory method for the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            used by this layouter.
            </summary>
      <returns>
            a new <c>LabelLayoutTranslator</c> with node translation enabled
            and "node label write back" disabled.
            </returns>
      <remarks>
            Factory method for the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            used by this layouter.
            In order to use the the integrated node label awareness feature one has to
            use an
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            instance with
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels" />
            set to <see langword="true" />. <br />
            Likewise in order to make use of the integrated edge labeling
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels" />
            must
            be set to <see langword="true" /> and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.WriteBackEdgeLabels" />
            must
            be set to <see langword="true" /> also (which is the default).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateLayerConstraintFactory(yWorks.yFiles.Algorithms.Graph)" />
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateLayerer">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>a default implementation (<c>new MultiComponentLayerer(new OldLayererWrapper(new WeightedLayerer()))</c>)</returns>
      <remarks>Factory method that is called lazily upon first usage.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateLayers(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <param name="ldp">provides the layout data</param>
      <returns>a Layers implementation</returns>
      <remarks>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            Creates an appropriate Layers implementation using the LayoutDataProvider
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateNodePlacer">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>a default implementation (<c>new SimplexNodePlacer</c>)</returns>
      <remarks>Factory method that is called lazily upon first usage.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreatePortAllocator">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>a default implementation (<c>new DefaultPortAllocator()</c>)</returns>
      <remarks>Factory method that is called lazily upon first usage.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreatePortConstraintOptimizer">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>
        <see langword="null" />
      </returns>
      <remarks>Factory method that is called lazily upon first usage.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateSequenceConstraintFactory(yWorks.yFiles.Algorithms.Graph)" />
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateSequencer">
      <summary>Factory method that is called lazily upon first usage.</summary>
      <returns>a default implementation (<c>new DefaultLayerSequencer()</c>)</returns>
      <remarks>Factory method that is called lazily upon first usage.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateSubgraphLayerSequencer">
      <summary>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <returns>a Sequencer implementation that can sequence subgraphs incrementally.</returns>
      <remarks>
            Factory method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Layouts the given graph.</summary>
      <param name="graph">the graph to layout</param>
      <remarks>Layouts the given graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DrawingDistanceCalculator">
      <summary>The current DrawingDistanceCalculator instance.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Setter:<br />
            Sets the DrawingDistanceCalculator implementation that is used in the next run.
            For the default see
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateDrawingDistanceCalculator" />
            .
            <para />
            Getter:<br />
            Returns the current DrawingDistanceCalculator instance.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.EdgeLayoutDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor" />
            instances for each edge in the graph.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeLayoutDescriptor" />
            instances for each edge in the graph. Different settings will affect the
            routing of the edges during the layout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.GetAlgorithmProperty(System.Object)">
      <summary>
            Provides access to implementation specific
            properties of the algorithms used.<br />
            Used for internal purposes.
            </summary>
      <param name="key">the key to a property</param>
      <returns>the associated value or <see langword="null" /></returns>
      <remarks>
            Provides access to implementation specific
            properties of the algorithms used.<br />
            Used for internal purposes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.GetEdgeLayoutDescriptors(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <param name="graph">the graph to obtain the information from.</param>
      <returns>a DataProvider instance or <see langword="null" /></returns>
      <remarks>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            This method returns a DataProvider that holds the EdgeLayoutDescriptor information.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.GetIncrementalHints(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <param name="graph">the graph to obtain the information from.</param>
      <returns>a DataProvider instance or <see langword="null" /></returns>
      <remarks>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            This method returns a DataProvider that holds the incremental hint information.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.GetNodeLayoutDescriptors(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <param name="graph">the graph to obtain the information from.</param>
      <returns>a DataProvider instance or <see langword="null" /></returns>
      <remarks>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            This method returns a DataProvider that holds the NodeLayoutDescriptor information.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.GetSwimLaneDescriptors(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </summary>
      <param name="graph">the graph to obtain the information from.</param>
      <returns>a DataProvider instance or <see langword="null" /></returns>
      <remarks>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            This method returns a DataProvider that holds the SwimLaneDescriptor information.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHintsDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve incremental layout hint
            objects that have been set using the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory" />
            which itself can be obtained from the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateIncrementalHintsFactory" />
            method.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve incremental layout hint
            objects that have been set using the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory" />
            which itself can be obtained from the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateIncrementalHintsFactory" />
            method.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalNodesDpKey">
      <summary>
            DataProvider key used to hold boolean values for each node in the graph that indicate whether
            the node has to be added incrementally.
            </summary>
      <remarks>
            DataProvider key used to hold boolean values for each node in the graph that indicate whether
            the node has to be added incrementally.
            This key is used by the incremental versions of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            , such as
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer" />
            to determine which nodes need to be
            inserted incrementally, as well as the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer" />
            implementation
            that determines incrementally sequenced nodes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.Layerer">
      <summary>The current Layerer instance.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Setter:<br />
            Sets the Layerer implementation that is used in the next run.
            For the default see
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateLayerer" />
            .
            <para />
            Getter:<br />
            Returns the current Layerer instance.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.LayerValueHolderDpKey">
      <summary>Used for publishing the final layering information.</summary>
      <remarks>
            Used for publishing the final layering information.
            If the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            associated to this key is also a
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            , the integer layer id of each node is stored using
            the acceptor's
            <see cref="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetInt(System.Object,System.Int32)">setInt</see>
            method.
            Otherwise, the provider's values should be of type
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder" />
            and the value holder's
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder.Value">setValue</see>
            method is used to store the
            integer layer ids of each node.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.MaximalDuration">
      <summary>The time limit (in milliseconds) set for the layout algorithm.</summary>
      <remarks>
            Getter:<br />
            Returns the time limit (in milliseconds) set for the layout algorithm.
            <para />
            Setter:<br />
            Sets a preferred time limit (in milliseconds) for the layout algorithm.
            Note that restricting the maximal duration may result in a worse layout quality.
            Furthermore, the real runtime may exceed the maximal duration since the layout algorithm
            still have to find a valid solution.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.NodeLayoutDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor" />
            instances for each node in the graph.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor" />
            instances for each node in the graph. Different settings will affect node
            placement and port assignment during the layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.NodePlacer">
      <summary>The current NodePlacer instance.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Setter:<br />
            Sets the NodePlacer implementation that is used in the next run.
            For the default see
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateNodePlacer" />
            .
            <para />
            Getter:<br />
            Returns the current NodePlacer instance.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PortAllocator">
      <summary>The current PortAllocator instance.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Setter:<br />
            Sets the PortAllocator implementation that is used in the next run.
            For the default see
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreatePortAllocator" />
            .
            <para />
            Getter:<br />
            Returns the current PortAllocator instance.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PortConstraintOptimizer">
      <summary>The current PortConstraintOptimizer instance.</summary>
      <remarks>
            Setter:<br />
            Sets the PortConstraintOptimizer implementation that is used in the next run.
            For the default see
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreatePortConstraintOptimizer" />
            .
            <para />
            Getter:<br />
            Returns the current PortConstraintOptimizer instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PublishLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)">
      <summary>Callback method that publishes the layering information</summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layers">the Layers implementation to get the layering information from</param>
      <remarks>Callback method that publishes the layering information</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PublishSequences(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Callback method that publishes the sequencing information</summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layers">the Layers implementation to get the layering information from</param>
      <param name="ldp">
            the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider" />
            to get the node information from
            </param>
      <remarks>Callback method that publishes the sequencing information</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.ReduceBendCount(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Removes bends from the edges which are obviously not necessary.</summary>
      <param name="graph">the graph to obtain the edges from</param>
      <remarks>
            Removes bends from the edges which are obviously not necessary.
            This method removes bends from the graph that are collinear.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.Sequencer">
      <summary>The current Sequencer instance.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Setter:<br />
            Sets the Sequencer implementation that is used in the next run.
            For the default see
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.CreateSequencer" />
            .
            <para />
            Getter:<br />
            Returns the current Sequencer instance.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.SequenceValueHolderDpKey">
      <summary>Used for publishing the final sequencing information.</summary>
      <remarks>
            Used for publishing the final sequencing information.
            If the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            associated to this key is also a
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            , the sequence order number of each node is stored
            using the acceptor's
            <see cref="M:yWorks.yFiles.Algorithms.IDataAcceptor.SetInt(System.Object,System.Int32)">setInt</see>
            method.
            Otherwise, the provider's values should be of type
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder" />
            and the value holder's
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder.Value">setValue</see>
            method is used to store the
            sequence order number of each node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.SetAlgorithmProperty(System.Object,System.Object)">
      <summary>
            Provides access to implementation specific
            properties of the algorithms used internally.
            </summary>
      <param name="key">the key to a property</param>
      <param name="value">the value to associate with the key</param>
      <remarks>
            Provides access to implementation specific
            properties of the algorithms used internally. <br />
            Used for internal purposes.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.SwimlaneDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor" />
            instances for each node in the graph.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor" />
            instances for each node in the graph. If this key is present during the layout.
            The layout algorithm will arrange nodes in swim lanes. The information about the
            swim lanes is finally written back into the descriptor instances.
            Instances can be shared among multiple nodes in the same lane, but don't have to be shared.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHint">
      <summary>
            Hint objects used internally by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter">this</see>
            layout algorithm implementation.
            </summary>
      <remarks>
            Hint objects used internally by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter">this</see>
            layout algorithm implementation.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHint.None">
      <summary>
            Convenience singleton instance of type
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.None" /></summary>
      <remarks>
            Convenience singleton instance of type
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.None" />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHint.Type">
      <summary>The type constant for this hint.</summary>
      <remarks>Returns the type constant for this hint.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator">
      <summary>
            Interface for a helper class used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during
            the node placement phase.
            </summary>
      <remarks>
            Interface for a helper class used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during
            the node placement phase.
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer" />
            uses instances that implement
            this interface to determine the minimum distances between elements in one layer.
            The default implementation used in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            is
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultDrawingDistanceCalculator" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator.Dispose(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to dispose internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that was used</param>
      <param name="ldp">the LayoutDataProvider that was used to query information</param>
      <remarks>
            Called to dispose internal data structures. Implementations should
            release internally held data structures here.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator.GetMinDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Main interface method.</summary>
      <param name="graph">the graph that contains the nodes</param>
      <param name="layer">the layer object that contains the nodes</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
      <param name="left">
            the left one of the two nodes whose
            minimum distance is to be determined or <see langword="null" /> if only the left border of the right node is
            of interest.
            </param>
      <param name="right">
            the right one of the two nodes whose
            minimum distance is to be determined or <see langword="null" /> if only the right border of the left node is
            of interest.
            </param>
      <remarks>
            Main interface method. Queried by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer" />
            instances to determine
            the minimum distances between elements in one layer. Note that either of the Node
            arguments may be <see langword="null" />. In that case only the border of the non-<see langword="null" />
            node should be considered.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator.Initialize(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to initialize internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that will be used during subsequent calls</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
      <remarks>
            Called to initialize internal data structures. Implementations may
            cache lengthy calculations in the initialization phase.
            It is guaranteed that the graph will not be changed during subsequent
            calls to
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator.GetMinDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData">
      <summary>Multi-purpose edge descriptor for each edge in the graph during the layout.</summary>
      <remarks>
            Multi-purpose edge descriptor for each edge in the graph during the layout.
            Used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during all stages to keep the state of
            the edges.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.AssociatedEdge">
      <summary>A possibly associated edge</summary>
      <remarks>Returns a possibly associated edge</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.AssociatedNode">
      <summary>A possibly associated node</summary>
      <remarks>Returns a possibly associated node</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.EdgeLayoutDescriptor">
      <summary>
            The EdgeLayoutDescriptor instance that was initially bound to this edge
            or <see langword="null" />.
            </summary>
      <remarks>
            Returns the EdgeLayoutDescriptor instance that was initially bound to this edge
            or <see langword="null" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.FallbackUpperSameLayerEdge">
      <summary>
            Specifies whether this edge should be an upper same layer edge if it is a
            same layer edge and it can be freely determined whether it should
            be routed above or below the layer.
            </summary>
      <remarks>
            Specifies whether this edge should be an upper same layer edge if it is a
            same layer edge and it can be freely determined whether it should
            be routed above or below the layer.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.Group">
      <summary>The group that is represented by this edge</summary>
      <remarks>Returns the group that is represented by this edge</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.Reversed">
      <summary>Specifies whether the edge has been reversed.</summary>
      <remarks>Returns whether the edge has been reversed.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.SourceCandidates">
      <summary>
            The Collection of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s for the
            source port as obtained from the DataProvider bound to the graph via
            the
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.SourcePcListDpKey" />
            data provider key
            bound to the original edge.
            </summary>
      <remarks>
            Returns the Collection of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s for the
            source port as obtained from the DataProvider bound to the graph via
            the
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.SourcePcListDpKey" />
            data provider key
            bound to the original edge.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.SourceGroup">
      <summary>The source group id object if any</summary>
      <remarks>Returns the source group id object if any</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.Spc">
      <summary>The current source port constraint</summary>
      <remarks>Returns the current source port constraint</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.TargetCandidates">
      <summary>
            The Collection of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s for the
            source port as obtained from the DataProvider bound to the graph via
            the
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.TargetPcListDpKey" />
            data provider key
            bound to the original edge.
            </summary>
      <remarks>
            Returns the Collection of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s for the
            source port as obtained from the DataProvider bound to the graph via
            the
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.TargetPcListDpKey" />
            data provider key
            bound to the original edge.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.TargetGroup">
      <summary>The target group id object if any</summary>
      <remarks>Returns the target group id object if any</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.Tpc">
      <summary>The current target port constraint</summary>
      <remarks>Returns the current target port constraint</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.Type">
      <summary>The type constant of the edge.</summary>
      <remarks>Returns the type constant of the edge.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData.UpperSameLayerEdge">
      <summary>
            Specifies whether the edge is an upper same layer edge
            (in case it is a same layer edge).
            </summary>
      <remarks>
            Returns whether the edge is an upper same layer edge
            (in case it is a same layer edge).
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeReverser">
      <summary>Interface for implementations that perform their work after the first phase.</summary>
      <remarks>Interface for implementations that perform their work after the first phase.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeReverser.NormalizeEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called at the beginning of the layout algorithm.</summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="ldp">
            the LayoutDataProvider that can be queried to receive the
            layering information
            </param>
      <remarks>
            Called at the beginning of the layout algorithm.
            This method should reverse all edges which point into the wrong direction.
            I.e. if the layer index of the source node is greater than the layer index
            of the target node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeReverser.RestoreEdgeDirections(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called at the end of the layout algorithm.</summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="ldp">
            the LayoutDataProvider that can be queried to receive the
            layering information
            </param>
      <remarks>
            Called at the end of the layout algorithm. This method should reverse all
            edges which have been marked as reversed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeReverser.Reverse(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Edge)">
      <summary>May be called by the incremental parts of the layout algorithm.</summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="ldp">
            the LayoutDataProvider that can be queried to receive the
            layering information
            </param>
      <param name="edge">the edge to reverse</param>
      <remarks>
            May be called by the incremental parts of the layout algorithm.
            This method should reverse the given edge which points into the wrong direction.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory">
      <summary>
            Factory interface for
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter" />
            .
            </summary>
      <remarks>
            Factory interface for
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter" />
            .
            Use this factory to obtain hints that will be interpreted by the layouter if
            they are bound to a DataProvider instance that is registered with the LayoutGraph
            using the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.IncrementalHintsDpKey" />
            
            key.<br />
            An instance of a class implementing this interface can be obtained through
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.CreateIncrementalHintsFactory" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory.CreateLayerIncrementallyHint(System.Object)">
      <summary>
            Creates a hint object for a node that should be inserted incrementally
            during the layering phase.
            </summary>
      <param name="forNodeId">
            the node to be layered and sequenced incrementally together
            with its adjacent edges and possibly marked neighboring nodes.
            </param>
      <returns>
            an Object that can be interpreted by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" /></returns>
      <remarks>
            Creates a hint object for a node that should be inserted incrementally
            during the layering phase. This will place the node in a suitable layer,
            thus possibly creating new layers.
            Neighbors of this node may be marked as to be laid out incrementally, too.
            This makes it possible to incrementally add whole subgraphs to the current
            layout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory.CreateSequenceIncrementallyHint(System.Object)">
      <summary>
            Creates a hint object for a node or edge that should be inserted incrementally
            after the sequencing phase.
            </summary>
      <param name="forItemId">the node or edge to be sequenced/inserted incrementally.</param>
      <returns>
            an Object that can be interpreted by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" /></returns>
      <remarks>
            Creates a hint object for a node or edge that should be inserted incrementally
            after the sequencing phase. This will prevent the layering from being changed.
            The node will be placed into an already existing layer that is determined
            by the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.Layerer" />
            implementation, i.e. "from sketch".
            Adjacent edges will automatically be be rerouted optimally.
            Creates a hint object for an edge that should be routed incrementally
            after the sequencing phase.
            This will prevent the layering from being changed.
            The edge will be rerouted in a locally optimal fashion.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory.CreateUseExactCoordinatesHint(System.Object)">
      <summary>
            Creates a hint object for a node that should be inserted incrementally
            into the graph at its exact current position.
            </summary>
      <param name="forNodeId">the node to be placed at its exact current position.</param>
      <returns>
            an Object that can be interpreted by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" /></returns>
      <remarks>
            Creates a hint object for a node that should be inserted incrementally
            into the graph at its exact current position.
            The node will be placed into an already existing layer that is determined
            by the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.Layerer">layerer</see>
            implementation. The position within its layer
            will be determined by its current position.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory.CreateUseExactLayerCoordinatesHint(System.Object)">
      <summary>
            Creates a hint object for a node that should be inserted incrementally
            into the graph at its exact current layer position.
            </summary>
      <param name="forNodeId">the node to be placed at its exact current layer position.</param>
      <returns>
            an Object that can be interpreted by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" /></returns>
      <remarks>
            Creates a hint object for a node that should be inserted incrementally
            into the graph at its exact current layer position.
            The node will be placed into an already existing layer that is determined
            by the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.Layerer">layerer</see>
            at the position that it occupies initially. The position within its layer
            will be determined by the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIncrementalHintsFactory.CreateUseExactSequenceCoordinatesHint(System.Object)">
      <summary>
            Creates a hint object for a node that should be inserted incrementally
            into the graph at its exact current sequence position.
            </summary>
      <param name="forNodeId">the node to be placed at its exact current sequence position.</param>
      <returns>
            an Object that can be interpreted by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" /></returns>
      <remarks>
            Creates a hint object for a node that should be inserted incrementally
            into the graph at its exact current sequence position.
            The node will be placed into an already existing layer that is determined
            by the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.Layerer">layerer</see>
            at the position that is deemed best for its layer. The position within the sequence of its layer
            will be determined by its current coordinates.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder">
      <summary>
            Used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            to write back layering information.
            </summary>
      <remarks>
            Used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            to write back layering information.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder.ProvidesValue">
      <summary>Returns whether the current context provides a value.</summary>
      <returns>whether meaningful value can be queried from the current context.</returns>
      <remarks>Returns whether the current context provides a value.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder.Value">
      <summary>The value of the current context.</summary>
      <remarks>Specifies the value of the current context.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory">
      <summary>
            Factory that consistently creates and destroys helper structures in the
            graph during layout.
            </summary>
      <remarks>
            Factory that consistently creates and destroys helper structures in the
            graph during layout.
            An implementation of this interface is provided by the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the layout for the different sub modules.
            <br />
            It is mainly for internal use.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.ConvertToLabelNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Converts a node to a label node</summary>
      <remarks>Converts a node to a label node</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateBendNode(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates a bend node in the layer for the given edge</summary>
      <remarks>Creates a bend node in the layer for the given edge</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateBendNode(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor)">
      <summary>Creates a bend node in the layer for the given edge and assigns it to the given lane descriptor</summary>
      <remarks>Creates a bend node in the layer for the given edge and assigns it to the given lane descriptor</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateBendNodeData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates bend node data for a bend node and associates it with the node</summary>
      <remarks>Creates bend node data for a bend node and associates it with the node</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateBendNodeData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor)">
      <summary>Creates bend node data for a bend node and associates it with the node.</summary>
      <remarks>
            Creates bend node data for a bend node and associates it with the node.
            The bend is assigned to the given laneDescriptor
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateConnectorProxyForGroup(yWorks.yFiles.Algorithms.Node,System.Object,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Edge)">
      <summary>Create a dummy edge that mimics a connector to a group node.</summary>
      <remarks>Create a dummy edge that mimics a connector to a group node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateDistanceNode(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Util.Geom.Rectangle2D.Double,yWorks.yFiles.Algorithms.Edge[])">
      <summary>Creates a spacer node for the drawing phase using the given bounds</summary>
      <remarks>Creates a spacer node for the drawing phase using the given bounds</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateDummyEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Boolean)">
      <summary>Creates a dummy edge using the given data.</summary>
      <remarks>Creates a dummy edge using the given data.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateEdgeGroupNode(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,System.Object)">
      <summary>Creates an edge group node</summary>
      <remarks>Creates an edge group node</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateEdgeGroupNodeData(yWorks.yFiles.Algorithms.Node,System.Object,System.Boolean)">
      <summary>Creates an edge group node data for an edge group node and associates it with the node</summary>
      <remarks>Creates an edge group node data for an edge group node and associates it with the node</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateGroupBorderEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an edge that connects two group border nodes.</summary>
      <remarks>Creates an edge that connects two group border nodes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateGroupBorderNode(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,System.SByte)">
      <summary>Creates a group boundary node for a group node.</summary>
      <remarks>Creates a group boundary node for a group node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateGroupLayerDummyNode">
      <summary>Create a dummy node for the group layer.</summary>
      <remarks>Create a dummy node for the group layer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateGroupNodeConnectorEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates a group node connector edge between two group nodes.</summary>
      <remarks>Creates a group node connector edge between two group nodes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateNormalEdgeData(yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates edge data for a normal edge and associates it with the edge</summary>
      <remarks>Creates edge data for a normal edge and associates it with the edge</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateNormalNodeData(yWorks.yFiles.Algorithms.Node)">
      <summary>Creates node data for a normal node and associates it with the node</summary>
      <remarks>Creates node data for a normal node and associates it with the node</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateProxyNode(yWorks.yFiles.Algorithms.Edge,System.Boolean)">
      <summary>
            Creates a proxy node for an edge during the drawing phase,
            changing the edge to end/start at the proxy
            </summary>
      <returns>the proxy</returns>
      <remarks>
            Creates a proxy node for an edge during the drawing phase,
            changing the edge to end/start at the proxy
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateProxyNode(yWorks.yFiles.Algorithms.Edge,System.Boolean,yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor)">
      <summary>
            Creates a proxy node for an edge during the drawing phase,
            changing the edge to end/start at the proxy.
            </summary>
      <returns>the proxy</returns>
      <remarks>
            Creates a proxy node for an edge during the drawing phase,
            changing the edge to end/start at the proxy.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateProxyNodeData(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates proxy node data for a proxy node and associates it with the node</summary>
      <remarks>Creates proxy node data for a proxy node and associates it with the node</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateReverseDummyEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,System.Boolean,System.Boolean)">
      <summary>Creates a reversed dummy edge using the given data</summary>
      <remarks>Creates a reversed dummy edge using the given data</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSameLayerEdgeData(yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates edge data for a same layer edge and associates it with the edge</summary>
      <remarks>Creates edge data for a same layer edge and associates it with the edge</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSameLayerProxy(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates a same layer proxy node.</summary>
      <remarks>Creates a same layer proxy node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSameLayerSideProxy(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Creates a proxy node for a same layer edge during the drawing phase that
            ends at the side of a node.
            </summary>
      <returns>the proxy</returns>
      <remarks>
            Creates a proxy node for a same layer edge during the drawing phase that
            ends at the side of a node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSameLayerSideProxy(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor)">
      <summary>
            Creates a proxy node for a same layer edge during the drawing phase that
            ends at the side of a node.
            </summary>
      <returns>the proxy</returns>
      <remarks>
            Creates a proxy node for a same layer edge during the drawing phase that
            ends at the side of a node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSameLayerSwitchProxy(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Creates a same layer switch proxy (switching between two same layer edges on two different sides
            of the layer).
            </summary>
      <remarks>
            Creates a same layer switch proxy (switching between two same layer edges on two different sides
            of the layer).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateSelfLoopEdgeData(yWorks.yFiles.Algorithms.Edge)">
      <summary>Creates edge data for a self loop edge and associates it with the edge</summary>
      <remarks>Creates edge data for a self loop edge and associates it with the edge</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroyDistanceNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Destroys a previously created spacer node for the drawing phase.</summary>
      <remarks>Destroys a previously created spacer node for the drawing phase.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroyLabelNodeLayer(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,System.Boolean)">
      <summary>Destroys a previously created label layer</summary>
      <param name="layer">the layer to destroy</param>
      <param name="useInEdges">
            whether the incoming edges should be used
            as the resulting edges
            </param>
      <remarks>Destroys a previously created label layer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroyProxyNode(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Destroys a proxy node that has been created using
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateProxyNode(yWorks.yFiles.Algorithms.Edge,System.Boolean)" />
            for the drawing phase
            </summary>
      <remarks>
            Destroys a proxy node that has been created using
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateProxyNode(yWorks.yFiles.Algorithms.Edge,System.Boolean)" />
            for the drawing phase
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroySameLayerProxy(yWorks.yFiles.Algorithms.Edge)">
      <summary>Destroy a previously created same layer edge proxy</summary>
      <remarks>Destroy a previously created same layer edge proxy</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroySameLayerSideProxy(yWorks.yFiles.Algorithms.Node)">
      <summary>Destroys a proxy node that has been created using.</summary>
      <remarks>
            Destroys a proxy node that has been created using.
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.CreateProxyNode(yWorks.yFiles.Algorithms.Edge,System.Boolean)" />
            for the drawing phase
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.DestroySameLayerSwitchProxy(yWorks.yFiles.Algorithms.Node)">
      <summary>Destroys a previously generated same layer switch proxy</summary>
      <remarks>Destroys a previously generated same layer switch proxy</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.InsertEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Inserts a same layer edge or an edge that may span multiple layers into the
            data structure.
            </summary>
      <remarks>
            Inserts a same layer edge or an edge that may span multiple layers into the
            data structure. Returns the list of edges that has been created if this edge
            spans multiple layers.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.InsertGroupNodeLayer(System.Boolean,System.Int32)">
      <summary>Inserts an edge group node layer</summary>
      <remarks>Inserts an edge group node layer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.InsertLabelNodeLayer(System.Boolean,System.Int32)">
      <summary>Inserts a layer for label nodes group node layer</summary>
      <remarks>Inserts a layer for label nodes group node layer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.RegisterSameLayerEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>Registers an edge as a same layer edge appropriately into all data structures.</summary>
      <remarks>Registers an edge as a same layer edge appropriately into all data structures.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.SetDirectlyConnectSameLayerEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Converts a normal edge to a
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.DirectSameLayerEdge" />
            .
            </summary>
      <remarks>
            Converts a normal edge to a
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.EdgeDataType.DirectSameLayerEdge" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.SetTemporaryEdgeGroups(yWorks.yFiles.Algorithms.Edge,System.Object,System.Object)">
      <summary>Sets a edge group constraint for an edge.</summary>
      <remarks>Sets a edge group constraint for an edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.SetTemporaryPortConstraint(yWorks.yFiles.Algorithms.Edge,System.Boolean,yWorks.yFiles.Layout.PortConstraint)">
      <summary>Sets a port constraint for an edge at the given side.</summary>
      <remarks>Sets a port constraint for an edge at the given side.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.UnconvertToLabelNode(yWorks.yFiles.Algorithms.Node)">
      <summary>Reverts a label node to the previous kind of node</summary>
      <remarks>Reverts a label node to the previous kind of node</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer">
      <summary>
            Describes a single layer in a hierarchical drawing
            with all its nodes and associated same layer edges.
            </summary>
      <remarks>
            Describes a single layer in a hierarchical drawing
            with all its nodes and associated same layer edges.
            A layer has a type and an index.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Add(yWorks.yFiles.Algorithms.Node)">
      <summary>Adds a newly created node to this layer</summary>
      <remarks>Adds a newly created node to this layer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.AddSameLayerEdge(yWorks.yFiles.Algorithms.Edge)">
      <summary>Adds a same layer edge to this layer.</summary>
      <remarks>Adds a same layer edge to this layer.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Index">
      <summary>The index of this layer in the list of all layers.</summary>
      <remarks>Returns the index of this layer in the list of all layers.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.List">
      <summary>The nodes in this layer.</summary>
      <remarks>Returns the nodes in this layer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Remove">
      <summary>Removes the current layer from the Layers structure.</summary>
      <remarks>Removes the current layer from the Layers structure.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Remove(yWorks.yFiles.Algorithms.Node)">
      <summary>Removes a node from this layer.</summary>
      <remarks>Removes a node from this layer.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Row">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor" />
            associated with this layer.
            </summary>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor" />
            associated with this layer.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.SameLayerEdges">
      <summary>All same layer edges in this layer.</summary>
      <remarks>Returns all same layer edges in this layer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.SetNodeOrder(yWorks.yFiles.Algorithms.YList)">
      <summary>Adjusts the order of the nodes in this list according to the given order.</summary>
      <remarks>Adjusts the order of the nodes in this list according to the given order.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.Type">
      <summary>The main type of this layer.</summary>
      <remarks>Returns the main type of this layer.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraint">
      <summary>This class represents a layering constraint.</summary>
      <remarks>
            This class represents a layering constraint.
            Such constraints can be given as additional input to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraint.Priority">
      <summary>The priority of a constraint.</summary>
      <remarks>
            Specifies the priority of a constraint.
            This value is used for resolving conflicting constraints.
            A constraint with a higher priority (int value) is more likely to be considered.
            The lowest (and default) priority is 1.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory">
      <summary>Interface specification for classes that can create layering constraints.</summary>
      <remarks>
            Interface specification for classes that can create layering constraints.
            <p />
            If you manually register a DataProvider under
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.NodeIdDpKey" />
            on the graph, you must use the
            corresponding node ids stored in this DataProvider as arguments for all methods that create a constraint. Otherwise,
            you can just use the node instances themselves.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object)">
      <summary>Add a constraint that forces the node <c>above</c> to lie above the node <c>reference</c>.</summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="aboveId">the id of the node that should lie above</param>
      <returns>a LayerConstraint object that represents the constraint.</returns>
      <remarks>Add a constraint that forces the node <c>above</c> to lie above the node <c>reference</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object,System.Int32)">
      <summary>
            Add a constraint that forces the node with id <c>above</c> to lie at least <c>minDistance</c> layers
            above the node with id <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="aboveId">the id of the node that should lie above</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
      <returns>a LayerConstraint object that represents the constraint.</returns>
      <remarks>
            Add a constraint that forces the node with id <c>above</c> to lie at least <c>minDistance</c> layers
            above the node with id <c>reference</c>.
            <p />
            The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
            layer difference may be smaller than <c>minDistance</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object,System.Int32,System.Int32)">
      <summary>
            Add a constraint that forces the node  with id <c>above</c> to lie at least <c>minDistance</c> layers
            above the node  with id <c>reference</c> with a given weight penalty for larger  layer differences.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="aboveId">the id of the node that should lie above</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
      <param name="weight">the weight penalty for larger layer differences</param>
      <returns>a LayerConstraint object that represents the constraint.</returns>
      <remarks>
            Add a constraint that forces the node  with id <c>above</c> to lie at least <c>minDistance</c> layers
            above the node  with id <c>reference</c> with a given weight penalty for larger  layer differences.
            <p />
            The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
            layer difference may be smaller than <c>minDistance</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.AddPlaceNodeAtBottomConstraint(System.Object)">
      <summary>Add a constraint that places a node in the bottom layer</summary>
      <param name="nodeId">the id of the node that should lie at the bottom</param>
      <returns>a LayerConstraint object that represents the constraint.</returns>
      <remarks>Add a constraint that places a node in the bottom layer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.AddPlaceNodeAtTopConstraint(System.Object)">
      <summary>Add a constraint that places a node in the topmost layer</summary>
      <param name="nodeId">the id of the node that should lie at the top</param>
      <returns>a LayerConstraint object that represents the constraint.</returns>
      <remarks>Add a constraint that places a node in the topmost layer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object)">
      <summary>
            Add a constraint that forces the node with id with id <c>below</c> to lie below the node with id
            <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="belowId">the id of the node that should lie below</param>
      <returns>a LayerConstraint object that represents the constraint.</returns>
      <remarks>
            Add a constraint that forces the node with id with id <c>below</c> to lie below the node with id
            <c>reference</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object,System.Int32)">
      <summary>
            Add a constraint that forces the node with id <c>below</c> to lie at least <c>minDistance</c> layers
            below the node with id <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="belowId">the id of the node that should lie below</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
      <returns>a LayerConstraint object that represents the constraint.</returns>
      <remarks>
            Add a constraint that forces the node with id <c>below</c> to lie at least <c>minDistance</c> layers
            below the node with id <c>reference</c>.
            <p />
            The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
            layer difference may be smaller than <c>minDistance</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object,System.Int32,System.Int32)">
      <summary>
            Add a constraint that forces the node with id <c>below</c> to lie at least <c>minDistance</c> layers
            below the node with id <c>reference</c> with a given weight penalty for larger layer differences.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="belowId">the id of the node that should lie below</param>
      <param name="minDistance">the minimal layer distance between the node and its reference node</param>
      <param name="weight">the weight penalty for larger layer differences</param>
      <returns>a LayerConstraint object that represents the constraint.</returns>
      <remarks>
            Add a constraint that forces the node with id <c>below</c> to lie at least <c>minDistance</c> layers
            below the node with id <c>reference</c> with a given weight penalty for larger layer differences.
            <p />
            The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
            layer difference may be smaller than <c>minDistance</c>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.AddPlaceNodeInSameLayerConstraint(System.Object,System.Object)">
      <summary>
            Add a constraint that forces the node with id <c>sameLayer</c> to lie in the same layer as the node with id
            <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="sameLayerId">the id of the node that should lie in the same layer</param>
      <returns>a LayerConstraint object that represents the constraint.</returns>
      <remarks>
            Add a constraint that forces the node with id <c>sameLayer</c> to lie in the same layer as the node with id
            <c>reference</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.Dispose">
      <summary>Disposes the ConstraintFactory.</summary>
      <remarks>
            Disposes the ConstraintFactory. <p> This method should be called when the factory is not needed anymore, i.e.
            after the layout has been calculated. Calling this method also clears all constraints. </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.Memento">
      <summary>A token that allows to bind a constraint factory to a graph instance after creation.</summary>
      <remarks>
            Get a token that allows to bind a constraint factory to a graph instance after creation.
            <p />
            This method should only be used if the constraint factory is not bound to a graph instance initially. It allows to
            bind the ConstraintFactory to a graph instance after creation. Please see the factory methods that create
            instances of this interface for a description.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerConstraintFactory.RemoveConstraints(System.Object)">
      <summary>Clears all constraints for a given node</summary>
      <param name="nodeId">the id of the node for which all constraints should be cleared</param>
      <remarks>Clears all constraints for a given node</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger">
      <summary>
            Merges two
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instances, whose nodes reside in the same graph.
            </summary>
      <remarks>
            Merges two
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instances, whose nodes reside in the same graph.
            Implementations of this interface may provide different strategies for merging.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger.Merge(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)">
      <summary>
            All nodes in srcLayers and targetLayers are part of graph at the moment of
            invocation.
            </summary>
      <param name="graph">
            the graph that contains the nodes in <c>srcLayers</c> and
            <c>targetLayers</c>.
            </param>
      <param name="ldp">the LayoutDataProvider that can be used to query the layer indices</param>
      <param name="srcLayers">
            the Layers implementation that contains the layers that
            will be merged into <c>targetLayers</c></param>
      <param name="targetLayers">
            the Layers that will be modified to contain the resulting
            layering
            </param>
      <remarks>
            All nodes in srcLayers and targetLayers are part of graph at the moment of
            invocation. The state of srcLayers is discarded after this call and need not
            be updated to reflect the changes. targetLayers must be updated accordingly.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer">
      <summary>
            This interface is used by classes that are capable of generating a layer
            assignment.
            </summary>
      <remarks>
            This interface is used by classes that are capable of generating a layer
            assignment. Layer assignment takes place during the first part of the
            algorithm in hierarchic layout algorithms.
            Each node in the graph is assigned to a layer.
            <br />
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.OldLayererWrapper" />
            class can be used to wrap existing implementations
            of the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ILayerer">ILayerer</see>
            interface
            from the <c>y.layout.hierarchic</c> package.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
      <remarks>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance. In order to create new layers, the factory
            method
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.Insert(yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType,System.Int32)" />
            must be used.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers">
      <summary>
            Container class that manages multiple
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer" />
            instances.
            </summary>
      <remarks>
            Container class that manages multiple
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer" />
            instances.
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            creates instances of this class and passes them
            to the instances that handle the various subtasks of the layout process during
            automatic layout. Method
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.CreateInstance" />
            can be used like a factory
            method to obtain temporary <c>Layers</c> instances.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.CreateInstance">
      <summary>
            Creates a new and empty Layers instance that can be used on the same graph
            instance for temporary results.
            </summary>
      <returns>
            an instance of the same type as the current instance. It will be
            empty initially.
            </returns>
      <remarks>
            Creates a new and empty Layers instance that can be used on the same graph
            instance for temporary results.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.GetLayer(System.Int32)">
      <summary>Returns a layer by index</summary>
      <param name="i">the zero-based index</param>
      <returns>the layer at the given index</returns>
      <remarks>Returns a layer by index</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.Insert(yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType,System.Int32)">
      <summary>Creates, inserts and returns a layer of a given type.</summary>
      <param name="type">
            a type constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer" />
            interface
            </param>
      <param name="position">the position where this layer will be inserted</param>
      <returns>a newly created read-to-use layer instance</returns>
      <remarks>Creates, inserts and returns a layer of a given type.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.Remove(System.Int32)">
      <summary>Removes a layer by index.</summary>
      <param name="index">the zero-based index of the layer</param>
      <remarks>Removes a layer by index.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers.Size">
      <summary>Returns the number of layers in this instance</summary>
      <returns>the number of layers</returns>
      <remarks>Returns the number of layers in this instance</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider">
      <summary>
            Interface for retrieving
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            instances
            for elements in the current layout graph.
            </summary>
      <remarks>
            Interface for retrieving
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            instances
            for elements in the current layout graph.
            Instances of this interface are provided by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            for
            instances implementing subtasks during the layout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider.GetEdgeData(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the associated
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            instance.
            </summary>
      <param name="edge">the edge for which the data will be returned</param>
      <returns>the instance</returns>
      <remarks>
            Returns the associated
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider.GetNodeData(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the associated
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            instance.
            </summary>
      <param name="node">the node for which the data will be returned</param>
      <returns>the instance</returns>
      <remarks>
            Returns the associated
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            instance.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType" />
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.None">
      <summary>
            Type specifier that is used as a dummy. This hint actually tells the algorithm that the corresponding
            element should not be treated as an incrementally added element.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.LayerIncrementally">
      <summary>Type specifier that is used for nodes that shall be inserted into the drawing incrementally.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.SequenceIncrementally">
      <summary>Type specifier that is used for edges that shall be inserted into the drawing incrementally.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.PlaceUsingExactCoordinates">
      <summary>
            Type specifier that is used for nodes that shall be placed into the drawing from sketch using the exact current
            coordinates for both the position within the layer and the position in the sequence.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.PlaceUsingExactSequenceCoordinates">
      <summary>
            Type specifier that is used for nodes that shall be placed into the drawing from sketch using
            the exact current coordinates for the position within the
            sequence in the layer.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.IncrementalHintType.PlaceUsingExactLayerCoordinates">
      <summary>
            Type specifier that is used for nodes that shall be placed into the drawing from sketch using
            the exact current coordinates for the position within the layer.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData">
      <summary>
            Multi-purpose node descriptor for each node in the graph during the
            hierarchic layout used internally by the algorithm implementations.
            </summary>
      <remarks>
            Multi-purpose node descriptor for each node in the graph during the
            hierarchic layout used internally by the algorithm implementations.
            Instances of this interface can be obtained during the layout from instances
            of the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider" />
            interface.
            NodeData typically carries a node's type and depending on the type an
            optional
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.AssociatedEdge">associated Edge</see>
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.AssociatedNode">associated Node</see>
            . Optionally they may carry
            a geometric description of the Node's borders and descriptors for various
            aspects of the layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.AssociatedEdge">
      <summary>The associated edge (in case of e.g.</summary>
      <remarks>Returns the associated edge (in case of e.g. bend or same layer center node)</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.AssociatedNode">
      <summary>The associated node (in case of e.g.</summary>
      <remarks>Returns the associated node (in case of e.g. backloop proxy and side proxy)</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.CreateBorderLine(System.Int32,yWorks.yFiles.Layout.INodeLayout)">
      <summary>
            Creates, stores, and returns a BorderLine for the given side or returns the currently
            set BorderLine if it already exists.
            </summary>
      <param name="side">
            the side as defined in
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.GetNormalizedBorderLine(System.Int32)" /></param>
      <param name="nl">
            the NodeLayout of the current node, the initial Borderline will
            be initialize from this instance
            </param>
      <exception cref="T:System.NotSupportedException">
            if this type of node does not support node
            borders
            </exception>
      <remarks>
            Creates, stores, and returns a BorderLine for the given side or returns the currently
            set BorderLine if it already exists.
            Not every type of node supports this operation.
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Normal" />
            supports borderlines.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.FirstSameLayerEdgeCell">
      <summary>The first same layer edge ListCell of all same layer edges.</summary>
      <remarks>Returns the first same layer edge ListCell of all same layer edges.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.GetNormalizedBorderLine(System.Int32)">
      <summary>
            Returns a borderline for the given side which is treated as if the node's position
            was at (0,0).
            </summary>
      <param name="side">
            the index of the side where <c>0</c> means top, <c>1</c>
            means right, <c>2</c> means bottom, and <c>3</c> means left.
            </param>
      <returns>a BorderLine instance if the node was at (0,0) or <see langword="null" /></returns>
      <remarks>
            Returns a borderline for the given side which is treated as if the node's position
            was at (0,0). Clients may modify this instance but should always reset it to the
            original position, since this is a shared instance.
            May return <see langword="null" /> to indicate that the borderline can be determined
            through the node's NodeLayout
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.GroupId">
      <summary>Group id of this node if it is a bus group node.</summary>
      <remarks>Returns group id of this node if it is a bus group node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.GroupLayers">
      <summary>The inner layers of this group node.</summary>
      <remarks>
            Returns the inner layers of this group node.
            If this node is of type
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Group" />
            , this method returns the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            object that describes the layering in the subgraph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.GroupNode">
      <summary>The group node this node belongs to.</summary>
      <remarks>Returns the group node this node belongs to.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.IncrementalHint">
      <summary>
            The hint of the incremental mode of this node if this node is of type
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Normal" />
            and a corresponding hint has been set via the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHintsDpKey" />
            DataProvider.
            </summary>
      <remarks>
            Returns the hint of the incremental mode of this node if this node is of type
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Normal" />
            and a corresponding hint has been set via the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.IncrementalHintsDpKey" />
            DataProvider.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer">
      <summary>The layer index this node resides in</summary>
      <remarks>Returns the layer index this node resides in</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.NodeLayoutDescriptor">
      <summary>
            The <c>NodeLayoutDescriptor</c> instance that was initially
            bound to this node or <see langword="null" />.
            </summary>
      <remarks>
            Returns the <c>NodeLayoutDescriptor</c> instance that was initially
            bound to this node or <see langword="null" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.ParentGroupNode">
      <summary>The parent group node if any</summary>
      <remarks>Returns the parent group node if any</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position">
      <summary>The current position of this node in its layer.</summary>
      <remarks>
            Returns the current position of this node in its layer.
            Note: this may not always be up to date depending on which phase the layout
            algorithm is currently in
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.SameLayerEdgeCount">
      <summary>Returns the number of same layer edges that are associated with this node</summary>
      <returns>the number</returns>
      <remarks>Returns the number of same layer edges that are associated with this node</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.SwimLaneDescriptor">
      <summary>
            The <c>SwimLaneDescriptor</c> instance that was initially
            bound to this node or <see langword="null" />.
            </summary>
      <remarks>
            Returns the <c>SwimLaneDescriptor</c> instance that was initially
            bound to this node or <see langword="null" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type">
      <summary>The type constant for this node</summary>
      <remarks>Returns the type constant for this node</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer">
      <summary>
            Responsible for the x (sequence) and preliminary y coordinate assignments of
            a drawing.
            </summary>
      <remarks>
            Responsible for the x (sequence) and preliminary y coordinate assignments of
            a drawing.
            Implementations of this interface are used during the last phases of the algorithm
            of the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            . They determine preliminary y coordinates
            (which may be adjusted during the final edge routing) and the x coordinates
            of all the elements that are part of the graph during the node placement phase.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)">
      <summary>
            Invoked by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            before the ports get assigned.
            </summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layoutDataProvider">
            the LayoutDataProvider that contains information about
            the elements
            </param>
      <param name="layers">the Layers that shall be calculated by this method</param>
      <remarks>
            Invoked by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            before the ports get assigned.
            This method is used to assign preliminary y coordinates for each layer.
            The distance between two layers will be adjusted later by the edge routing
            algorithm. This method is responsible for assigning the relative positions
            of the nodes within each layer.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.INodePlacer.AssignSequenceCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator)">
      <summary>
            Invoked by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            to determine the resulting x coordinates.
            </summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layoutDataProvider">
            the LayoutDataProvider that contains information about
            the elements
            </param>
      <param name="layers">the Layers that shall be calculated by this method</param>
      <param name="drawingDistanceCalculator">
            an instance that can be queried to determine
            the minimum distance between each pair of nodes in the graph
            </param>
      <remarks>
            Invoked by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            to determine the resulting x coordinates.
            This method is invoked after all ports have been assigned their final relative
            coordinates and nodes have been given relative coordinates within each layer.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter">
      <summary>
            Adapter class that uses a
            <see cref="T:yWorks.yFiles.Algorithms.IDataMap" />
            ,
            <see cref="T:yWorks.yFiles.Algorithms.INodeMap" />
            , or
            <see cref="T:yWorks.yFiles.Algorithms.IEdgeMap" />
            implementation and wraps it as a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder" />
            instances for each element.
            </summary>
      <remarks>
            Adapter class that uses a
            <see cref="T:yWorks.yFiles.Algorithms.IDataMap" />
            ,
            <see cref="T:yWorks.yFiles.Algorithms.INodeMap" />
            , or
            <see cref="T:yWorks.yFiles.Algorithms.IEdgeMap" />
            implementation and wraps it as a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            that provides
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IIntValueHolder" />
            instances for each element.
            See
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.LayerValueHolderDpKey" />
            for a typical use case
            of this class.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.#ctor(yWorks.yFiles.Algorithms.IDataAcceptor,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Creates a new instance of IntValueHolderAdapter using a pair
            of DataAcceptor and DataProvider instances for storage and retrieval.
            </summary>
      <remarks>
            Creates a new instance of IntValueHolderAdapter using a pair
            of DataAcceptor and DataProvider instances for storage and retrieval.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.#ctor(yWorks.yFiles.Algorithms.IDataMap)">
      <summary>Creates a new instance of IntValueHolderAdapter using a DataMap</summary>
      <remarks>Creates a new instance of IntValueHolderAdapter using a DataMap</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.#ctor(yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Creates a new instance of IntValueHolderAdapter using an EdgeMap</summary>
      <remarks>Creates a new instance of IntValueHolderAdapter using an EdgeMap</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.#ctor(yWorks.yFiles.Algorithms.INodeMap)">
      <summary>Creates a new instance of IntValueHolderAdapter using a NodeMap</summary>
      <remarks>Creates a new instance of IntValueHolderAdapter using a NodeMap</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.Get(System.Object)">
      <summary>Returns an object value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.GetBool(System.Object)">
      <summary>Returns a boolean value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.GetDouble(System.Object)">
      <summary>Returns a double value associated with the given data holder.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IntValueHolderAdapter.GetInt(System.Object)">
      <summary>Returns an integer value associated with the given data holder.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortAllocator">
      <summary>
            Interface used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the layout.
            </summary>
      <remarks>
            Interface used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the layout.
            Instances of this class are responsible for assigning port coordinates to
            the adjacent edges of each node in the graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortAllocator.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            before the actual node placing takes
            place (phase three).
            </summary>
      <param name="graph">the graph which contains all the elements</param>
      <param name="layers">the layers object that contains the elements in the layering</param>
      <param name="ldp">
            the LayoutDataProvider that can be queried for the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            instances
            </param>
      <param name="itemFactory">
            the ItemFactory that can be used to temporarily modify
            the graph instance
            </param>
      <remarks>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            before the actual node placing takes
            place (phase three).
            This method must assign each edge in the graph a source port and target
            port coordinate pair.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer">
      <summary>
            This interface serves as a callback for
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            after the layering and sequencing phases.
            </summary>
      <remarks>
            This interface serves as a callback for
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            after the layering and sequencing phases.
            Implementations of this interface may modify the port constraints (
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            ) information
            via
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory.SetTemporaryPortConstraint(yWorks.yFiles.Algorithms.Edge,System.Boolean,yWorks.yFiles.Layout.PortConstraint)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer.OptimizeAfterLayering(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Called after the layering information has been determined.</summary>
      <param name="graph">the graph to work on</param>
      <param name="layers">the layering information</param>
      <param name="ldp">
            the implementation which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            instances
            </param>
      <param name="itemFactory">the factory to set the temporary port constraints with</param>
      <remarks>
            Called after the layering information has been determined. This method can be used to assign
            new temporary port constraints for the next phases of the algorithm.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer.OptimizeAfterSequencing(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Called after the sequence of the nodes has been determined.</summary>
      <param name="graph">the graph to work on</param>
      <param name="layers">the layering information</param>
      <param name="ldp">
            the implementation which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            instances
            </param>
      <param name="itemFactory">the factory to set the temporary port constraints with</param>
      <remarks>
            Called after the sequence of the nodes has been determined. This method can be used to assign
            new temporary port constraints for the next phases of the algorithm.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory">
      <summary>
            Specifies the general contract for factory classes that can be used
            to associate sequence constraints to a graph.
            </summary>
      <remarks>
            Specifies the general contract for factory classes that can be used
            to associate sequence constraints to a graph. Sequence constraints
            affect the per layer sequence calculated in hierarchical layouts.
            <p>
            A <c>SequenceConstraintFactory</c> has to be
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.Dispose">disposed</see>
            after use. Disposing the factory will also remove
            all constraints previously specified for the factory's associated graph.
            </p>
            Notes:
            <ul>
            <li>Sequence constraints can't be used together with swimlanes currently.</li>
            <li>Sequence constraints that are specified for a group child node will be applied to the parent node instead</li>
            <li>If you manually register a DataProvider under
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.NodeIdDpKey" />
            on the graph, you must use the corresponding node ids stored in this DataProvider as arguments for
            all methods that create a constraint. Otherwise, you can just use the node instances themselves.</li>
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.AddPlaceNodeAfterConstraint(System.Object,System.Object)">
      <summary>
            Add a constraint that forces the node with id <c>after</c> to lie after
            the node with id <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="afterId">the id of the node that should be placed after the reference</param>
      <remarks>
            Add a constraint that forces the node with id <c>after</c> to lie after
            the node with id <c>reference</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.AddPlaceNodeAtHeadConstraint(System.Object)">
      <summary>Add a constraint that places a node at the start of the sequence.</summary>
      <param name="nodeId">the id of the node that should be placed at the start</param>
      <remarks>Add a constraint that places a node at the start of the sequence.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.AddPlaceNodeAtTailConstraint(System.Object)">
      <summary>Add a constraint that places a node at the end of the sequence.</summary>
      <param name="nodeId">the id of the node that should be placed at the end</param>
      <remarks>Add a constraint that places a node at the end of the sequence.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.AddPlaceNodeBeforeConstraint(System.Object,System.Object)">
      <summary>
            Add a constraint that forces the node with id <c>before</c> to lie before
            the node with id <c>reference</c>.
            </summary>
      <param name="referenceId">the id of the reference node</param>
      <param name="beforeId">the id of the node that should be placed before the reference</param>
      <remarks>
            Add a constraint that forces the node with id <c>before</c> to lie before
            the node with id <c>reference</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.Dispose">
      <summary>Disposes the SequenceConstraintFactory.</summary>
      <remarks>
            Disposes the SequenceConstraintFactory.
            <p>
            This method should be called when the factory is not needed anymore, i.e.
            after the layout has been calculated.
            Calling this method also clears all constraints.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequenceConstraintFactory.Memento">
      <summary>A token that allows to bind a constraint factory to a graph instance after creation.</summary>
      <remarks>
            Get a token that allows to bind a constraint factory to a graph instance after creation.
            This method should only be used if the constraint factory is not bound to a graph instance initially. It allows
            to bind the ConstraintFactory to a graph instance after creation. Please see the factory methods that create
            instances of this interface for a description.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer">
      <summary>
            This interface is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            to calculate the node
            orders of nodes within the layers in a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            object.
            </summary>
      <remarks>
            This interface is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            to calculate the node
            orders of nodes within the layers in a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            object.
            Implementations are used during the second phase of the hierarchic layout
            process.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ISequencer.SequenceNodeLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the second phase.
            </summary>
      <param name="graph">the graph that contains the elements from <c>layers</c></param>
      <param name="layers">the Layer implementation that holds the Layers for sequencing</param>
      <param name="ldp">
            the LayoutDataProvider that provides the necessary
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" /></param>
      <param name="itemFactory">
            an ItemFactory implementation that can be used to modify the
            graph consistently
            </param>
      <remarks>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the second phase.
            Calculates a sequence of the nodes in <c>layers</c> and finally
            writes back the calculated sequence using the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer.SetNodeOrder(yWorks.yFiles.Algorithms.YList)" />
            method.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerConstraintFactoryCompanion" />
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerConstraintFactoryCompanion.LayerConstraintsMementoDpKey">
      <summary>
        <c>DataProvider</c> key to store the constraints.</summary>
      <remarks>
        <c>DataProvider</c> key to store the constraints.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType" />
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.Normal">
      <summary>Describes a normal layer consisting mainly of normal nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.Label">
      <summary>Describes a layer consisting mainly of label nodes or dummy nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.SourceGroupNodes">
      <summary>Describes a layer consisting of source group nodes and dummy nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.TargetGroupNodes">
      <summary>Describes a layer consisting of target group nodes and dummy nodes.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy">
      <summary>Constant for merging policy.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddBelow">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering below the
            layers in the target layering.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddAbove">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering above the
            layers in the target layering.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddRightTopAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the right of
            the layers in the target layering.
            Both layerings will be top aligned before the merge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddRightBottomAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the right of
            the layers in the target layering.
            Both layerings will be bottom aligned before the merge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddRightCenterAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the right of
            the layers in the target layering.
            Both layerings will be center aligned before the merge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddLeftTopAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the left of
            the layers in the target layering.
            Both layerings will be top aligned before the merge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddLeftBottomAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the left of
            the layers in the target layering.
            Both layerings will be bottom aligned before the merge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.MergingPolicy.AddLeftCenterAligned">
      <summary>
            Constant for merging policy.
            This policy adds new layers from the source layering to the left of
            the layers in the target layering.
            Both layerings will be center aligned before the merge.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer">
      <summary>
            Wrapper Layerer implementation that delegates the actual layering to a
            delegate Layerer.
            </summary>
      <remarks>
            Wrapper Layerer implementation that delegates the actual layering to a
            delegate Layerer. If the graph consists of multiple components, they will
            be identified and sorted and each of the components will be layered separately
            using the delegate Layerer instance. After that they will all be merged
            in order using the specified
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger" />
            instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.#ctor(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer)">
      <summary>
            Creates a new instance of MultiComponentLayerer using the given
            delegate and a new instance of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger" />
            as the merger and no component comparator.
            </summary>
      <remarks>
            Creates a new instance of MultiComponentLayerer using the given
            delegate and a new instance of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger" />
            as the merger and no component comparator.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.#ctor(yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger,System.Collections.IComparer)">
      <summary>
            Creates a new instance of MultiComponentLayerer using the given
            delegates.
            </summary>
      <remarks>
            Creates a new instance of MultiComponentLayerer using the given
            delegates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.ComponentComparator">
      <summary>The current component Comparator or <see langword="null" />.</summary>
      <remarks>
            Getter:<br />
            Returns the current component Comparator or <see langword="null" />.
            <para />
            Setter:<br />
            Sets the component Comparator instance, may be <see langword="null" />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.Merger">
      <summary>The merger.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Getter:<br />
            Returns the merger.
            <para />
            Setter:<br />
            Sets the new merger instance.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.SingleComponentLayerer">
      <summary>The Layerer instance that is used for delegation.</summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Getter:<br />
            Returns the Layerer instance that is used for delegation.
            <para />
            Setter:<br />
            Sets the new delegate Layerer instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.Sort(yWorks.yFiles.Algorithms.NodeList[],yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)" />
            .
            </summary>
      <param name="nodeLists">
            the array of NodeLists each containing all nodes that belong
            to the same component
            </param>
      <param name="componentIndexProvider">
            a DataProvider that can be used to query the
            nodes' component indices via
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetInt(System.Object)" />
            and/or
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)" />
            .
            </param>
      <remarks>
            Callback method that is called during
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)" />
            .
            It is responsible for sorting an array consisting of
            <see cref="T:yWorks.yFiles.Algorithms.NodeList" />
            s, each
            containing nodes that belong to a different component. By default this method
            uses the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.MultiComponentLayerer.ComponentComparator">ComponentComparator</see>
            to sort the list
            or does nothing if that instance is <see langword="null" />.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Normal">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A normal node - may have any degree, any size and any number of connected
            same layer edges.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Bend">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A bend node - has degree 2, small size and no same layer edges.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.SideProxy">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A side proxy node in case port constraints are used for the drawing phase
            - has degree 1, small size and no same layer edges.
            The associated node is the node this node is the proxy of.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.SameLayerSideProxy">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A side proxy node for drawing same layer edges - has degree 0, small size
            and one same layer edge.
            The associated node is the node this node is the proxy of.
            The associated edge is the same layer edge this node is the proxy of.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Label">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A label node for drawing - has degree 2, size of the labels and no same layer edges.
            The borders of this node describe the layout of the labels
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.Group">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A group node if nested graph layouts are calculated.
            Carries additional
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            information.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.SourceGroupNode">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A source group node for bus edges. This node serves as a dummy node
            in a
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.SourceGroupNodes" />
            layer.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.TargetGroupNode">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A target group node for bus edges. This node serves as a dummy node
            in a
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.LayerType.TargetGroupNodes" />
            layer.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.SourceBackloopProxy">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A backloop proxy that belongs to the source of an edge
            - has degree 2, small size and exactly one same layer edge
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.TargetBackloopProxy">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A backloop proxy that belongs to the target of an edge
            - has degree 2, small size and exactly one same layer edge
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.SameLayerCenterNode">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A same layer edge crossing dummy node - has degree 2,
            small size and exactly two same layer edges.
            Is used to mark the crossing of the layer if source and target port
            are at opposite layer sides.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.DistanceNode">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A node used for the drawing phase to keep the distance between two nodes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.GroupBegin">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A node used for the drawing phase to mark the beginning of a node group interval.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.GroupEnd">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A node used for the drawing phase to mark the ending of a node group interval.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.GroupLayerDummy">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A node used for the the sequencing and drawing phase to mark a dummy node inserted to guarantee that a group
            is non-empty on each layer that it is defined on.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeDataType.ProxyForEdgeAtGroup">
      <summary>
            Node type constant as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            .
            A node used for the the sequencing and drawing phase to mark a dummy node that has been inserted
            as a legal end point of an edge connecting to a group node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode">
      <summary>
            Byte constant used by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.Never">
      <summary>
            Byte constant used by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode" />
            . This mode prevents node labels from being
            considered during the layout at all.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForSelfLoops">
      <summary>
            Byte constant used by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode" />
            . This mode makes the algorithm consider
            node labels for self-loops, node placement, and routing.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForDrawing">
      <summary>
            Byte constant used by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode" />
            . This mode makes the algorithm consider
            node labels for node placement and routing but not for self loops.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForRouting">
      <summary>
            Byte constant used by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode" />
            . This mode makes the algorithm consider
            node labels during routing only.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor">
      <summary>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the various
            phases to determine the drawing details of the graph's nodes.
            </summary>
      <remarks>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the various
            phases to determine the drawing details of the graph's nodes.
            <br />
            Note: not all of these values will be used for all kinds of nodes and
            any kind of algorithm used.
            <br />
            This class is designed as a class to allow for future additions of new getter
            methods.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.#ctor">
      <summary>
            Creates a new instance of a NodeLayoutDescriptor using the
            default values.
            </summary>
      <remarks>
            Creates a new instance of a NodeLayoutDescriptor using the
            default values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.GetPortBorderGapRatio(System.Int32)">
      <summary>
            Returns the port border gap ratio for the port distribution at the given
            side.
            </summary>
      <param name="side">the 0-based clockwise side index for top-to-bottom layouts</param>
      <returns>the ratio</returns>
      <remarks>
            Returns the port border gap ratio for the port distribution at the given
            side.
            Default is <c>0.5d</c> for all sides.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.LayerAlignment">
      <summary>
            The alignment of the node within its layer
            Default is <c>0.5d</c> which results in center-aligned nodes.
            </summary>
      <exception cref="T:System.ArgumentException">if the alignment is not within [0.0d .. 1.0d]</exception>
      <remarks>
            Setter:<br />
            Sets the alignment of the node within its layer.
            A value of <c>0.0d</c> means nodes are aligned at the top of the layer
            (for top-down drawing). A value of <c>0.5d</c> results in center-aligned nodes
            and <c>1.0d</c> leads to bottom-aligned nodes.
            <para />
            Getter:<br />
            Returns the alignment of the node within its layer
            Default is <c>0.5d</c> which results in center-aligned nodes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.MinimumDistance">
      <summary>The <i>preferred</i> minimum distance of the node to obstacles.</summary>
      <remarks>
            Setter:<br />
            Sets the <i>preferred</i> minimum distance to obstacles.
            <para />
            Getter:<br />
            Returns the <i>preferred</i> minimum distance of the node to obstacles.
            Default is <c>5.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.MinimumLayerHeight">
      <summary>The minimum height of the layer this node will be assigned to.</summary>
      <remarks>
            Specifies the minimum height of the layer this node will be assigned to.
            Note, that this will only affect the drawing if different
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.LayerAlignment">layerAlignments</see>
            are present.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.NodeLabelMode">
      <summary>
            The mode that determines the consideration of node labels during the
            layout.<br />
            This can be one of
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.Never" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForSelfLoops" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForDrawing" />
            , or
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForRouting" />
            .
            </summary>
      <exception cref="T:System.ArgumentException">if the constant is unknown.</exception>
      <remarks>
            Setter:<br />
            Sets the mode that determines the consideration of node labels during the
            layout. Note that in order to get this feature working the algorithm must be provided
            information about the layout of the node labels. If
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter" />
            is used for the layout
            the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.ConsiderNodeLabels" />
            should be set to <see langword="true" />. Otherwise one has to assure that
            e.g. via an instanceof
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            the algorithm
            receives the appropriate information.
            The mode constant can be one of
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.Never" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForSelfLoops" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForDrawing" />
            , or
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForRouting" />
            .
            <para />
            Getter:<br />
            Returns the mode that determines the consideration of node labels during the
            layout.<br />
            This can be one of
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.Never" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForSelfLoops" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForDrawing" />
            , or
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForRouting" />
            . <br />
            The default is
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLabelMode.ConsiderForDrawing" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.PortBorderGapRatios">
      <summary>
            The port border gap ratio for the port distribution on all sides of
            the node.
            </summary>
      <remarks>
            Sets the port border gap ratio for the port distribution on all sides of
            the node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.NodeLayoutDescriptor.SetPortBorderGapRatio(System.Int32,System.Double)">
      <summary>
            Sets the port border gap ratio for the port distribution at the given
            side.
            </summary>
      <param name="side">the side</param>
      <param name="ratio">the new ratio</param>
      <remarks>
            Sets the port border gap ratio for the port distribution at the given
            side.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.OldLayererWrapper">
      <summary>
            Wraps a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ILayerer" />
            implementation from the <c>y.layout.hierarchic</c>
            package to behave like a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            implementation from the
            <c>y.layout.hierarchic.incremental</c> package.
            </summary>
      <remarks>
            Wraps a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.ILayerer" />
            implementation from the <c>y.layout.hierarchic</c>
            package to behave like a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            implementation from the
            <c>y.layout.hierarchic.incremental</c> package.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.OldLayererWrapper.#ctor(yWorks.yFiles.Layout.Hierarchic.ILayerer)">
      <summary>Creates a new instance of OldLayererWrapper, wrapping the given layerer.</summary>
      <param name="oldLayerer">the old layerer implementation</param>
      <remarks>Creates a new instance of OldLayererWrapper, wrapping the given layerer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.OldLayererWrapper.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>
            This method assigns all nodes in the graph to layers and registers them
            in the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers" />
            instance.
            </summary>
      <param name="graph">
            the graph that contains the nodes that should be distributed
            into the layers
            </param>
      <param name="layers">
            the object that will be filled with the results of the
            calculation
            </param>
      <param name="ldp">
            LayoutDataProvider that can be used to query information about
            the nodes - note that positional information
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Position" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Layer" />
            ) cannot
            be available at any time.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.OldLayererWrapper.OldLayerer">
      <summary>
            The <c>y.layout.hierarchic.Layerer</c>
            instance that is used for delegation.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Getter:<br />
            Returns the <c>y.layout.hierarchic.Layerer</c>
            instance that is used for delegation.
            <para />
            Setter:<br />
            Sets the new delegate Layerer instance.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId">
      <summary>Represents an identifier for partition cells of the partition grid.</summary>
      <remarks>Represents an identifier for partition cells of the partition grid.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId.Cells">
      <summary>A collection of elements of type Pair.</summary>
      <remarks>
            Returns a collection of elements of type Pair. Each pair consists of a column and a row defining a single partition cell.
            Note: a partition cell id that covers more than one partition cell can only be assigned to group nodes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId.Column">
      <summary>The first column associated with this partition cell id.</summary>
      <remarks>Returns the first column associated with this partition cell id.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId.Equals(System.Object)">
      <summary>Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.</summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
      <returns>true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId.IsSpanning">
      <summary>
            True if the partition cell id represents a multi-cell, i.e., whether or not it was created with method
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(yWorks.yFiles.Util.ICollection,yWorks.yFiles.Util.ICollection)" />
            ,
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor)" />
            ,
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(System.Int32,System.Int32,System.Int32,System.Int32)" />
            ,
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateColumnSpanId(System.Int32)" />
            or
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateRowSpanId(System.Int32)" />
            .
            </summary>
      <remarks>
            Returns true if the partition cell id represents a multi-cell, i.e., whether or not it was created with method
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(yWorks.yFiles.Util.ICollection,yWorks.yFiles.Util.ICollection)" />
            ,
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor)" />
            ,
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(System.Int32,System.Int32,System.Int32,System.Int32)" />
            ,
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateColumnSpanId(System.Int32)" />
            or
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateRowSpanId(System.Int32)" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId.Row">
      <summary>The first row associated with this partition cell id.</summary>
      <remarks>Returns the first row associated with this partition cell id.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId.Pair">
      <summary>Represents a single partition cell, i.e., a row-column pair.</summary>
      <remarks>Represents a single partition cell, i.e., a row-column pair.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId.Pair.Column">
      <summary>The ColumnDescriptor associated with this partition cell.</summary>
      <remarks>Returns the ColumnDescriptor associated with this partition cell.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId.Pair.CompareTo(System.Object)">
      <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
      <param name="obj">An object to compare with this instance. </param>
      <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj" />. Zero This instance is equal to <paramref name="obj" />. Greater than zero This instance is greater than <paramref name="obj" />. </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance. </exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId.Pair.Row">
      <summary>The RowDescriptor associated with this partition cell.</summary>
      <remarks>Returns the RowDescriptor associated with this partition cell.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid">
      <summary>Class for creating a partition grid, i.e., a grid that partitions the drawing area into rectangular partition cells.</summary>
      <remarks>
            Class for creating a partition grid, i.e., a grid that partitions the drawing area into rectangular partition cells.
            The grid consists of rows and columns that are created using the corresponding constructors of this class or method
            #addColumn or #addRow. The PartitionGrid object has to be registered to the graph using DataProvider PARTITION_DPKEY;
            <p>
            Each node element can be assigned to a partition cell which consists of a row and a column.
            Therefore the user can create partition cell identifiers using method
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellId(yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor)" />
            or
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellId(System.Int32,System.Int32)" />
            . These cell identifiers have to be assigned to nodes using DataProvider PARTITION_CELL_DPKEY.
            </p><p>
            Group nodes can also be mapped to a partition cell identifier that represents a multi-cell, i.e., a cell spanning multiple columns and rows.
            These identifiers can be created using methods
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor)" />
            ,
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(System.Int32,System.Int32,System.Int32,System.Int32)" />
            ,
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(yWorks.yFiles.Util.ICollection,yWorks.yFiles.Util.ICollection)" />
            ,
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateColumnSpanId(System.Int32)" />
            , and
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateRowSpanId(System.Int32)" />
            .
            A group node mapped to such a identifier represents the corresponding multi-cell, i.e., its boundary corresponds
            to the smallest rectangle containing all partition cells specified by the multi-cell.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.#ctor">
      <summary>Constructs an empty partition grid.</summary>
      <remarks>Constructs an empty partition grid.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.#ctor(System.Int32,System.Int32)">
      <summary>Constructs a partition grid with rowCount rows and columnCount columns.</summary>
      <param name="rowCount">the number of rows</param>
      <param name="columnCount">the number of columns</param>
      <remarks>Constructs a partition grid with rowCount rows and columnCount columns.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double)">
      <summary>Constructs a partition grid with rowCount rows and columnCount columns as well as the given insets and min sizes.</summary>
      <param name="rowCount">the number of rows</param>
      <param name="columnCount">the number of columns</param>
      <param name="rowInsets">the top and bottom insets of the rows</param>
      <param name="columnInsets">the left and right insets of the columns</param>
      <param name="minRowSize">the minimum row height</param>
      <param name="minColumnSize">the minimum column width</param>
      <remarks>Constructs a partition grid with rowCount rows and columnCount columns as well as the given insets and min sizes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.AddColumn">
      <summary>Adds a new column to the partition grid.</summary>
      <returns>the new column.</returns>
      <remarks>
            Adds a new column to the partition grid.
            The index of the column (as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.Index" />
            ) is set to the size of the list returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.Columns" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.AddRow">
      <summary>Adds a new row to the partition grid.</summary>
      <returns>the new row.</returns>
      <remarks>
            Adds a new row to the partition grid.
            The index of the row (as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.Index" />
            ) is set to the size of the list returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.Rows" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.Columns">
      <summary>The columns of the partition grid.</summary>
      <remarks>Returns the columns of the partition grid.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellId(System.Int32,System.Int32)">
      <summary>Creates a partition cell identifier that represents the cell defined by the given column and row.</summary>
      <param name="rowIndex">the row index of the row defining the cell</param>
      <param name="columnIndex">the column index of the column defining the cell</param>
      <returns>the partition cell identifier</returns>
      <remarks>Creates a partition cell identifier that represents the cell defined by the given column and row.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellId(yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor)">
      <summary>Creates a partition cell identifier that represents the cell defined by the given column and row.</summary>
      <param name="rd">the row defining the cell</param>
      <param name="cd">the column defining the cell</param>
      <returns>the partition cell identifier</returns>
      <remarks>Creates a partition cell identifier that represents the cell defined by the given column and row.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Creates a partition cell identifier that represents a multi-cell spanning multiple columns and rows.</summary>
      <param name="fromRowIndex">the row index of the topmost row defining the cell</param>
      <param name="fromColIndex">the column index of the leftmost column defining the cell</param>
      <param name="toRowIndex">the row index of the bottommost row defining the cell</param>
      <param name="toColIndex">the column index of the rightmost column defining the cell</param>
      <returns>the partition cell identifier</returns>
      <remarks>
            Creates a partition cell identifier that represents a multi-cell spanning multiple columns and rows.
            Note: this identifier can only be used for group nodes. A group node mapped to such a partition cell identifier
            represents the multi-cell, i.e., its boundary corresponds to the smallest rectangle containing
            all partition cells specified by the partition cell identifier.
            <p>
            The partition cell identifier represents all cells defined by a
            row with index between fromRow and toRow (both including) and
            a column with index between fromCol and toCol (both including).
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor,yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor)">
      <summary>Creates a partition cell identifier that represents a multi-cell spanning multiple columns and rows.</summary>
      <param name="fromRow">the topmost row defining the cell</param>
      <param name="fromCol">the leftmost column defining the cell</param>
      <param name="toRow">the bottommost row defining the cell</param>
      <param name="toCol">the rightmost column defining the cell</param>
      <returns>the partition cell identifier</returns>
      <remarks>
            Creates a partition cell identifier that represents a multi-cell spanning multiple columns and rows.
            Note: this identifier can only be used for group nodes. A group node mapped to such a partition cell identifier
            represents the multi-cell, i.e., its boundary corresponds to the smallest rectangle containing
            all partition cells specified by the partition cell identifier.
            <p>
            The partition cell identifier represents all cells defined by a
            row between fromRow and toRow (both including) and
            a column between fromCol and toCol (both including).
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateCellSpanId(yWorks.yFiles.Util.ICollection,yWorks.yFiles.Util.ICollection)">
      <summary>Creates a partition cell identifier that represents a multi-cell spanning multiple columns and rows.</summary>
      <param name="rowList">the rows defining the cell</param>
      <param name="columnList">the columns defining the cell</param>
      <returns>the partition cell identifier</returns>
      <remarks>
            Creates a partition cell identifier that represents a multi-cell spanning multiple columns and rows.
            Note: this identifier can only be used for group nodes. A group node mapped to such a partition cell identifier
            represents the multi-cell, i.e., its boundary corresponds to the smallest rectangle containing
            all partition cells specified by the partition cell identifier.
            <p>
            The partition cell identifier represents all cells defined by a
            column of columnList and a row of rowList.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateColumnSpanId(System.Int32)">
      <summary>Creates a partition cell identifier that represents a cell spanning a whole column.</summary>
      <param name="columnIndex">the column index of the column defining the cell</param>
      <returns>the partition cell identifier</returns>
      <remarks>
            Creates a partition cell identifier that represents a cell spanning a whole column.
            Note: this identifier can only be used for group nodes. A group node mapped to such a partition cell identifier
            represents the column, i.e., its enclosing boundary corresponds to that of the column.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.CreateRowSpanId(System.Int32)">
      <summary>Creates a partition cell identifier that represents a cell spanning a whole row.</summary>
      <param name="rowIndex">the row index of the row defining the cell</param>
      <returns>the partition cell identifier</returns>
      <remarks>
            Creates a partition cell identifier that represents a cell spanning a whole row.
            Note: this identifier can only be used for group nodes. A group node mapped to such a partition cell identifier
            represents the row, i.e., its enclosing boundary corresponds to that of the row.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.FinalizeOrientationChange(yWorks.yFiles.Layout.OrientationLayouter,yWorks.yFiles.Layout.OrientationLayouter.Transformer)">
      <summary>
            A method that is called at the end of the
            <see cref="T:yWorks.yFiles.Layout.OrientationLayouter" />
            stage.
            </summary>
      <param name="orientationLayouter">the instance of the orientation layouter</param>
      <param name="transformer">provides a method for transferring a point to its final position</param>
      <remarks>
            A method that is called at the end of the
            <see cref="T:yWorks.yFiles.Layout.OrientationLayouter" />
            stage.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.GetColumn(System.Int32)">
      <summary>Returns the column with the given index.</summary>
      <param name="index">the index of the column to be returned</param>
      <returns>the column with the given index or null if there is no such column</returns>
      <remarks>Returns the column with the given index.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.GetPartitionGrid(yWorks.yFiles.Algorithms.Graph)">
      <summary>Returns the partition grid associated with the given graph.</summary>
      <param name="graph">the graph</param>
      <returns>the partition grid of the graph or null if the graph has no associated partition grid</returns>
      <remarks>Returns the partition grid associated with the given graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.GetRow(System.Int32)">
      <summary>Returns the row with the given index.</summary>
      <param name="index">the index of the row to be returned</param>
      <returns>the row with the given index or null if there is no such row</returns>
      <remarks>Returns the row with the given index.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.HasAtLeastTwoNonEmptyRows(yWorks.yFiles.Algorithms.Graph)">
      <summary>Checks whether the nodes of the graph are assigned to at least two different partition rows.</summary>
      <param name="graph">the input graph</param>
      <returns>true, if the nodes of the graph are assigned to at least two different partition rows.</returns>
      <remarks>Checks whether the nodes of the graph are assigned to at least two different partition rows.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.OptimizeColumnOrder">
      <summary>Specifies whether the order of the columns should be chosen automatically.</summary>
      <remarks>
            Getter:<br />
            Returns whether the order of the columns should be chosen automatically.
            The default is <see langword="true" />.
            <para />
            Setter:<br />
            Specifies whether the order of the columns should be chosen automatically to minimize edge lengths.
            <p>
            For all columns where
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.ColumnDescriptor.IndexFixed" />
            is set to <see langword="true" />, the relative ordering given by the indices
            is preserved. The remaining columns may be resorted so that the overall edge lengths are minimized.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.OptimizeRowOrder">
      <summary>Specifies whether the order of the rows should be chosen automatically.</summary>
      <remarks>
            Getter:<br />
            Returns whether the order of the rows should be chosen automatically.
            The default is <see langword="true" />.
            <para />
            Setter:<br />
            Specifies whether the order of the rows should be chosen automatically to minimize edge lengths.
            <p>
            For all rows where
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.IndexFixed" />
            is set to <see langword="true" />, the relative ordering given by the indices
            is preserved. The remaining rows may be resorted so that the overall edge lengths are minimized.
            </p>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.PartitionCellDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId" />
            instances for nodes of the graph.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionCellId" />
            instances for nodes of the graph. Each node is placed inside the columns/rows defined by the corresponding partition cell identifier.
            Instances can be shared among multiple nodes, but don't have to be shared.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.PartitionGridDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid" />
            structure.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid" />
            structure.
            The incremental hierarchic layouter uses the graph instance to access the data provider. If the provider contains a partition grid structure
            this structure will be considered during layout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.PrepareOrientationChange(yWorks.yFiles.Layout.OrientationLayouter,yWorks.yFiles.Layout.OrientationLayouter.Transformer)">
      <summary>
            A method that is called at the beginning of the
            <see cref="T:yWorks.yFiles.Layout.OrientationLayouter" />
            stage.
            </summary>
      <param name="orientationLayouter">the instance of the orientation layouter</param>
      <param name="transformer">provides a method for transferring an original point to its temporary position</param>
      <remarks>
            A method that is called at the beginning of the
            <see cref="T:yWorks.yFiles.Layout.OrientationLayouter" />
            stage.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.Rows">
      <summary>The rows of the partition grid.</summary>
      <remarks>Returns the rows of the partition grid.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGridLayoutStage">
      <summary>
            Layout stage that is used for handling a given partition grid structure (
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid" />
            ) that is
            attached to a graph with DataProvider
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.PartitionGridDpKey" />
            .
            </summary>
      <remarks>
            Layout stage that is used for handling a given partition grid structure (
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid" />
            ) that is
            attached to a graph with DataProvider
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid.PartitionGridDpKey" />
            .
            <p />
            Note: the IncrementalHierarchicLayouter automatically uses this stage if needed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGridLayoutStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGridLayoutStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGridLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGridLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer">
      <summary>
            This class is an implementation of the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer" />
            interface which can be registered
            with the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            instance using it's
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PortConstraintOptimizer" />
            method.
            </summary>
      <remarks>
            This class is an implementation of the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IPortConstraintOptimizer" />
            interface which can be registered
            with the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            instance using it's
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.PortConstraintOptimizer" />
            method.
            It will query the graph's DataProvider repository for
            the
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.SourcePcListDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.TargetPcListDpKey" />
            keys and expects them to hold
            <see cref="T:yWorks.yFiles.Util.ICollection" />
            instances of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s for each edge.
            Additionally it will query the DataProvider associated with
            <see cref="F:yWorks.yFiles.Layout.PortCandidateSet.NodeDpKey" />
            and expects
            <see cref="T:yWorks.yFiles.Layout.PortCandidateSet" />
            instances associated with each node in the input graph.
            <p />
            This implementation will then <b>try</b> to assign each edge one of the PortCandidates without creating too many
            crossings or violating the cost constraints for each PortCandidate.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.BackloopPenalty">
      <summary>The penalty cost that is associated with each backloop.</summary>
      <remarks>
            Specifies the penalty cost that is associated with each backloop.
            The default value is <c>1.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.CrossingPenalty">
      <summary>
            The penalty cost that is associated with each generated crossing that would be generated
            if a given combination of PortCandidates would be chosen.
            </summary>
      <remarks>
            Specifies the penalty cost that is associated with each generated crossing that would be generated
            if a given combination of PortCandidates would be chosen.
            The default value is <c>10.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.Deterministic">
      <summary>Determines whether this implementation should use a deterministic algorithm to assign the PortCandidates.</summary>
      <remarks>Determines whether this implementation should use a deterministic algorithm to assign the PortCandidates.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.GetPortCandidateSetDataProvider(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns the data provider that provides the port candidate sets for nodes.</summary>
      <param name="graph">The graph that stores the data provider</param>
      <remarks>Returns the data provider that provides the port candidate sets for nodes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.OptimizeAfterLayering(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>Called after the layering information has been determined.</summary>
      <param name="graph">the graph to work on</param>
      <param name="layers">the layering information</param>
      <param name="ldp">
            the implementation which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            instances
            </param>
      <param name="itemFactory">the factory to set the temporary port constraints with</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.OptimizeAfterSequencing(yWorks.yFiles.Algorithms.Node,System.Collections.IComparer,System.Collections.IComparer,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.IItemFactory)">
      <summary>
            Called after the sequence of the nodes has been determined to assign new temporary port constraints to each
            original node.
            </summary>
      <param name="node">the original node to set temporary port constraints at.</param>
      <param name="inEdgeOrder">
            a
            <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators.IPartialOrder" />
            which defines the preferred ordering of the in-edges from left to right.
            Note: to sort collections according to a PartialOrder, an appropriate method like
            <see cref="M:yWorks.yFiles.Algorithms.Util.Comparators.Sort(yWorks.yFiles.Util.IList,System.Collections.IComparer)" />
            or
            <see cref="M:yWorks.yFiles.Algorithms.YList.Sort" />
            must be used.
            </param>
      <param name="outEdgeOrder">
            a
            <see cref="T:yWorks.yFiles.Algorithms.Util.Comparators.IPartialOrder" />
            which defines the preferred ordering of the out-edges from left to
            right. Note: to sort collections according to a PartialOrder, an appropriate method like
            <see cref="M:yWorks.yFiles.Algorithms.Util.Comparators.Sort(yWorks.yFiles.Util.IList,System.Collections.IComparer)" />
            or
            <see cref="M:yWorks.yFiles.Algorithms.YList.Sort" />
            must be used.
            </param>
      <param name="graph">the graph to work on.</param>
      <param name="ldp">
            the LayoutDataProvider which provides access to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData" />
            and
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.IEdgeData" />
            .
            </param>
      <param name="itemFactory">the factory which can set the temporary port constraints.</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.PCListOptimizer.OverUsagePenalty">
      <summary>
            The penalty cost that is associated with each edge being assigned to a port which has no
            capacity left.
            </summary>
      <remarks>
            Specifies the penalty cost that is associated with each edge being assigned to a port which has no
            capacity left.
            The default value is <c>100.0d</c>.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor">
      <summary>
            This class represents a row of a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid" />
            .
            </summary>
      <remarks>
            This class represents a row of a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.PartitionGrid" />
            .
            <br />
            The results of the calculation of the geometry of the row will be placed
            into the instances of this class after the layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.BottomInset">
      <summary>
            The bottom row insets where no element
            will lie in the resulting drawing.
            </summary>
      <exception cref="T:System.ArgumentException">if bottomInset is negative</exception>
      <remarks>
            Specifies the bottom row insets where no element
            will lie in the resulting drawing.
            The default is <c>0.0d</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.CompareTo(System.Object)">
      <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
      <param name="obj">An object to compare with this instance. </param>
      <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj" />. Zero This instance is equal to <paramref name="obj" />. Greater than zero This instance is greater than <paramref name="obj" />. </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance. </exception>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.ComputedHeight">
      <summary>
            The computed height of the row
            after the layout has been calculated.
            </summary>
      <remarks>
            Used to set the computed height of the row
            after the layout has been calculated.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.ComputedPosition">
      <summary>
            The computed position (smaller y-coordinate) of the row
            after the layout has been calculated.
            </summary>
      <remarks>
            Used to set the computed position (smaller y-coordinate) of the row
            after the layout has been calculated.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.Index">
      <summary>The index of the row within the partition grid.</summary>
      <remarks>Returns the index of the row within the partition grid.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.IndexFixed">
      <summary>
            Specifies whether the index of this row is fixed or whether
            the algorithm should try to find the best possible position.
            </summary>
      <remarks>
            Getter:<br />
            Returns whether the index of this row is fixed or whether
            the algorithm should try to find the best possible position.
            The default is <see langword="true" />
            <para />
            Setter:<br />
            Specifies whether a row's index is fixed or whether the index should be chosen automatically in order
            to minimize edge lengths.
            <p>
            For all rows where this property is set to <see langword="true" />, the relative ordering given by the indices
            is preserved. The remaining rows may be resorted so that the overall edge lengths are minimized.
            </p>
            <p>
            By default, this feature is enabled. </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.MinimumHeight">
      <summary>The minimum row height.</summary>
      <exception cref="T:System.ArgumentException">if minimumHeight is negative</exception>
      <remarks>
            Getter:<br />
            Returns the minimum row height.
            The default is <c>0.0d</c>.
            <para />
            Setter:<br />
            Sets the minimum height of the row.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.OriginalHeight">
      <summary>The original height of the row.</summary>
      <remarks>Specifies the original height of the row.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.OriginalPosition">
      <summary>The original position (smaller y-coordinate) of the row.</summary>
      <remarks>Specifies the original position (smaller y-coordinate) of the row.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.Tightness">
      <summary>The tightness factor of the row.</summary>
      <exception cref="T:System.ArgumentException">if tightness is out of the valid range</exception>
      <remarks>
            Getter:<br />
            Returns the tightness factor of the row.
            The default is <c>0.0d</c>.
            <para />
            Setter:<br />
            Sets the tightness factor of the row. The greater the value the
            more will the row to be forced to be of its minimal possible height.
            A value of <c>0.0d</c> will disable compression of the row.
            A value of <c>1.0d</c> will try to force the column to be of
            its
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.MinimumHeight">minimum height</see>
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.RowDescriptor.TopInset">
      <summary>
            The top row insets where no element
            will lie in the resulting drawing.
            </summary>
      <exception cref="T:System.ArgumentException">if topInset is negative</exception>
      <remarks>
            Specifies the top row insets where no element
            will lie in the resulting drawing.
            The default is <c>0.0d</c>.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator">
      <summary>
            This class can be used to calculate bend points for orthogonally routed
            self loops.
            </summary>
      <remarks>
            This class can be used to calculate bend points for orthogonally routed
            self loops. It is used during the layout phase of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            , but
            can be used as a stand-alone tool.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.#ctor(System.Double,System.Double)">
      <summary>
            Creates a new instance of SelfloopCalculator using the given
            parameters for minimum first segment length and minimum distance between
            each pair of edges.
            </summary>
      <param name="minFirstSegmentLength">
            the minimum length of the first and last segment
            of an orthogonally routed self loop
            </param>
      <param name="minEdgeDistance">the minimum distance between a pair of self loops</param>
      <remarks>
            Creates a new instance of SelfloopCalculator using the given
            parameters for minimum first segment length and minimum distance between
            each pair of edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.CalculateSelfLoops(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Calculates all self loops at the given node the given graph.</summary>
      <param name="graph">the graph that contains the node</param>
      <param name="node">the node whose self loops will be routed</param>
      <param name="spc">
            a DataProvider that contains
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            information
            for the source ports of the edges
            </param>
      <param name="tpc">
            a DataProvider that contains
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            information
            for the target ports of the edges
            </param>
      <remarks>
            Calculates all self loops at the given node the given graph.
            The current port positions will be used to determine the start and end ports.
            The DataProvider instances can be used to specify the direction of first
            and last segments.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.CalculateSelfLoops(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Convenience method that calculates a list of self-loops that belong to a given node.</summary>
      <param name="graph">the graph that contains the node</param>
      <param name="node">the node whose self loops will be routed</param>
      <param name="selfLoops">
            a list of
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            s that will be routed
            </param>
      <param name="spc">
            a DataProvider that contains
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            information
            for the source ports of the edges
            </param>
      <param name="tpc">
            a DataProvider that contains
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            information
            for the target ports of the edges
            </param>
      <remarks>Convenience method that calculates a list of self-loops that belong to a given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.GetMinimumDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the minimum length between two edges.</summary>
      <remarks>
            Returns the minimum length between two edges.
            The value is fetched from the corresponding data provider.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.GetMinimumFirstSegmentLength(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the minimum length for the first segment of an edge.</summary>
      <remarks>
            Returns the minimum length for the first segment of an edge.
            The value is fetched from the corresponding data provider.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.GetMinimumLastSegmentLength(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the minimum length for the last segment of an edge.</summary>
      <remarks>
            Returns the minimum length for the last segment of an edge.
            The value is fetched from the corresponding data provider.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.GetMinimumNodeDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the minimum length between two nodes.</summary>
      <remarks>
            Returns the minimum length between two nodes.
            The value is fetched from the corresponding data provider.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.MinimumEdgeDistanceDpKey">
      <summary>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            bound to the graph that
            yields for each edge a minimum distance to the next edge or node side.
            </summary>
      <remarks>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            bound to the graph that
            yields for each edge a minimum distance to the next edge or node side.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.MinimumFirstSegmentLengthDpKey">
      <summary>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            bound to the graph that
            yields for each edge a minimum length of its first segment.
            </summary>
      <remarks>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            bound to the graph that
            yields for each edge a minimum length of its first segment.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.MinimumLastSegmentLengthDpKey">
      <summary>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            bound to the graph that
            yields for each edge a minimum length of its last segment.
            </summary>
      <remarks>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            bound to the graph that
            yields for each edge a minimum length of its last segment.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Hierarchic.Incremental.SelfloopCalculator.MinimumNodeDistanceDpKey">
      <summary>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            bound to the graph that
            yields for each node a minimum distance to the self loop edges.
            </summary>
      <remarks>
            A key used for a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            bound to the graph that
            yields for each node a minimum distance to the self loop edges.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer">
      <summary>
            NodePlacer implementation based on
            <see cref="T:yWorks.yFiles.Algorithms.RankAssignments">rank-assignment</see>
            .
            </summary>
      <remarks>
            NodePlacer implementation based on
            <see cref="T:yWorks.yFiles.Algorithms.RankAssignments">rank-assignment</see>
            .
            The drawer works with integer values and rounds double values to
            integers using sophisticated quantizing.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)">
      <summary>
            Invoked by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            before the ports get assigned.
            </summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layoutDataProvider">
            the LayoutDataProvider that contains information about
            the elements
            </param>
      <param name="layers">the Layers that shall be calculated by this method</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignSequenceCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator)">
      <summary>
            Invoked by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            to determine the resulting x coordinates.
            </summary>
      <param name="graph">the graph that contains the elements</param>
      <param name="layoutDataProvider">
            the LayoutDataProvider that contains information about
            the elements
            </param>
      <param name="layers">the Layers that shall be calculated by this method</param>
      <param name="drawingDistanceCalculator">
            an instance that can be queried to determine
            the minimum distance between each pair of nodes in the graph
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.BaryCenterMode">
      <summary>Specifies whether or not to use the barycenter drawing mode.</summary>
      <remarks>
            Specifies whether or not to use the barycenter drawing mode.
            If this mode is enabled the resulting drawing is likely to have more bends
            but may be more symmetric.
            <p>
            By default this mode is turned off.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.BendReductionEnabled">
      <summary>Specifies whether or not an optimization step should be applied that tries to further reduce the number of bends.</summary>
      <remarks>
            Specifies whether or not an optimization step should be applied that tries to further reduce the number of bends.
            By default this option is enabled.
            Note: using this option may increase runtime. If the runtime exceeds the maximal duration
            (see
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.MaximalDuration" />
            ) the number of bends is not reduced.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.BreakLongSegments">
      <summary>Specifies whether this instance may break long edge segments in favor of a more compact layout.</summary>
      <remarks>Specifies whether this instance may break long edge segments in favor of a more compact layout.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.ExactPlacementEnforced">
      <summary>
            Specifies whether this instance should enforce the placement of nodes at
            their exact current position, even if this violates minimum distance
            constraints.
            </summary>
      <remarks>
            Specifies whether this instance should enforce the placement of nodes at
            their exact current position, even if this violates minimum distance
            constraints.
            <p>
            The default is <see langword="true" />.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.FromSketchLayerAssignment">
      <summary>
            Specifies whether this instance tries to use the coordinates given from the current sketch for
            the determination of the layer coordinates.
            </summary>
      <remarks>
            Specifies whether this instance should try to use the coordinates given from the current sketch for
            the determination of the layer coordinates.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GetLayerAlignment(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,System.Int32,System.Double)">
      <summary>
            Callback method used by
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)" />
            to determine the alignment of the node inside the layer
            </summary>
      <remarks>
            Callback method used by
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)" />
            to determine the alignment of the node inside the layer
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GetMinDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Determines the minimum allowed distance between two nodes in a given layer</summary>
      <param name="graph">the graph that contains the nodes</param>
      <param name="layer">the layer that contains the nodes</param>
      <param name="predNode">the node to the left of the other one, may be <see langword="null" /> to indicate a border line</param>
      <param name="succ">the node to the right of the other one, may be <see langword="null" /> to indicate a border line</param>
      <returns>the minimum distance allowed between those two nodes ( &gt;=0 )</returns>
      <remarks>Determines the minimum allowed distance between two nodes in a given layer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GetMinimumLayerHeight(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer)">
      <summary>
            Callback method used by
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)" />
            to determine the minimum height of a layer.
            </summary>
      <remarks>
            Callback method used by
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)" />
            to determine the minimum height of a layer.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.GroupCompactionStrategy">
      <summary>
            The strategy that is used to control the horizontal compactness
            of group nodes.
            </summary>
      <remarks>
            Specifies the strategy that is used to control the horizontal compactness
            of group nodes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.HorizontalCompaction">
      <summary>Specifies whether this instance tries to create a maximally compact horizontal layout at the cost of more bends.</summary>
      <remarks>
            Determines whether this instance tries to create a maximally compact horizontal layout at the cost of more bends.
            <p>
            For best results,
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.BreakLongSegments" />
            should also be enabled.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.IsFixedNode(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,System.Boolean)">
      <summary>
            Callback used by both
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)" />
            and
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignSequenceCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator)" />
            to determine whether the given node should be treated as a node with fixed (given) coordinates.
            </summary>
      <param name="graph">the graph that contains the node</param>
      <param name="provider">the current LayoutDataProvider</param>
      <param name="node">the node</param>
      <param name="inLayer">
            whether the nodes' layer coordinate is queried or the sequence coordinate.
            Iff <c>inLayer</c> is <see langword="true" /> this method is called from within the
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)" />
            method
            </param>
      <returns>whether the node should be treated as fixed</returns>
      <remarks>
            Callback used by both
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignLayerCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers)" />
            and
            <see cref="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.AssignSequenceCoordinates(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.IDrawingDistanceCalculator)" />
            to determine whether the given node should be treated as a node with fixed (given) coordinates.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.MaximalDuration">
      <summary>The time limit (in milliseconds) set for the algorithm.</summary>
      <remarks>
            Getter:<br />
            Returns the time limit (in milliseconds) set for the algorithm.
            <para />
            Setter:<br />
            Sets a preferred time limit (in milliseconds) for the algorithm.
            Note that restricting the maximal duration may result in a worse layout quality.
            Furthermore, the real runtime may exceed the maximal duration since the algorithm
            still have to find a valid solution.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.StraightenEdges">
      <summary>Specifies whether a postprocessing step should be applied that tries to remove some bends.</summary>
      <remarks>
            Getter:<br />
            Returns whether a postprocessing step should be applied that tries to remove some bends.
            <para />
            Setter:<br />
            Whether or not a postprocessing step should be applied that tries to remove some bends.
            Note that enabling this option may violate some minimum distances specified by the user.
            Furthermore, the edge distribution is no longer uniform.
            <p>
            The default is <see langword="false" />.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SimplexNodePlacer.SwimLaneCrossingWeight">
      <summary>
            The relative weight of edges crossing a swim lane relative to edges that stay
            in their lane.
            </summary>
      <remarks>
            Specifies the relative weight of edges crossing a swim lane relative to edges that stay
            in their lane.
            <p>
            A value of <c>0.0d</c> will effectively make the algorithm
            ignore edges crossing a swim lane border.
            </p>
            <p>
            Defaults to <c>0.0d</c>.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor">
      <summary>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the various
            phases to associate swim lanes with each node.
            </summary>
      <remarks>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter" />
            during the various
            phases to associate swim lanes with each node.
            Each node should be associated with a SwimLaneDescriptor instance;
            nodes in the same lane may share one instance.
            <br />
            The results of the calculation of the geometry of the swim lanes will be placed
            into the instances of this class after the layout.
            <br />
            It can be bound to the layout algorithm using the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.Incremental.HierarchicLayouter.SwimlaneDescriptorDpKey" />
            
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key.
            <br />
            This class is designed as a class to allow for future additions of new getter
            methods.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.#ctor(System.IComparable)">
      <summary>Creates a new swim lane descriptor with an associated client object.</summary>
      <param name="clientObject">
            an object provided by the client that will be used
            for determining the order of the lanes.
            </param>
      <exception cref="T:System.ArgumentNullException">
            if the specified client object is
            <see langword="null" />.
            </exception>
      <remarks>Creates a new swim lane descriptor with an associated client object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.#ctor(System.Object,System.Collections.IComparer)">
      <summary>
            Creates a new swim lane descriptor using the given
            client object and comparator.
            </summary>
      <param name="clientObject">a client object used for sorting the lanes</param>
      <param name="cmp">a Comparator used for comparing the client objects.</param>
      <exception cref="T:System.ArgumentNullException">
            if the specified client object is
            <see langword="null" /> or the specified comparator is <see langword="null" /> but the
            specified client object is not a
            <see cref="T:System.IComparable" />
            instance.
            </exception>
      <remarks>
            Creates a new swim lane descriptor using the given
            client object and comparator.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ClientObject">
      <summary>The client object.</summary>
      <exception cref="T:System.ArgumentException">
            if there is currently no comparator set and
            the specified object is not a
            <see cref="T:System.IComparable" />
            instance.
            </exception>
      <remarks>Specifies the client object.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.Comparator">
      <summary>The comparator that is used for sorting the lanes.</summary>
      <exception cref="T:System.ArgumentNullException">
            if the specified comparator is
            <see langword="null" />.
            </exception>
      <remarks>Specifies the comparator that is used for sorting the lanes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.CompareTo(System.Object)">
      <summary>
            Implements the Comparable interface using the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.Comparator" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ClientObject" />
            fields.
            </summary>
      <remarks>
            Implements the Comparable interface using the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.Comparator" />
            and
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ClientObject" />
            fields.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ComputedLaneIndex">
      <summary>
            The computed zero-based index of the lane
            after the layout has been calculated.
            </summary>
      <remarks>
            Returns the computed zero-based index of the lane
            after the layout has been calculated.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ComputedLanePosition">
      <summary>
            The computed position (smaller coordinate) of the lane
            after the layout has been calculated.
            </summary>
      <remarks>
            Returns the computed position (smaller coordinate) of the lane
            after the layout has been calculated.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.ComputedLaneWidth">
      <summary>
            The computed width of the lane
            after the layout has been calculated.
            </summary>
      <remarks>
            Returns the computed width of the lane
            after the layout has been calculated.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.IndexFixed">
      <summary>
            Specifies whether the index of this swim lane is fixed or whether
            the algorithm should try to find the best possible position.
            </summary>
      <remarks>
            Getter:<br />
            Returns whether the index of this swim lane is fixed or whether
            the algorithm should try to find the best possible position.
            The default is <see langword="true" />
            <para />
            Setter:<br />
            Specifies whether a swim lane's index is fixed (based on the result of the comparison
            with the other swim lanes) or whether the index should be chosen automatically in order
            to minimize edge lengths.
            <p>
            For all swim lanes where this property is set to <see langword="true" />, the relative ordering given by the client objects
            is preserved. The remaining swim lanes may be resorted so that the overall edge lengths are minimized.
            </p>
            <p>
            By default, this feature is enabled. </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.LaneTightness">
      <summary>The tightness factor of the lane.</summary>
      <exception cref="T:System.ArgumentException">if tightness is out of the valid range</exception>
      <remarks>
            Setter:<br />
            Sets the tightness factor of the lane. The greater the value the
            more will the lane to be forced to be of its minimal possible width.
            A value of <c>0.0d</c> will disable compression of the lane.
            A value of <c>1.0d</c> will try to force the lane to be of
            its
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.MinimumLaneWidth">minimum width</see>
            .
            <para />
            Getter:<br />
            Returns the tightness factor of the lane.
            The default is <c>0.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.LeftLaneInset">
      <summary>
            The left lane insets where no element
            will lie in the resulting drawing.
            </summary>
      <exception cref="T:System.ArgumentException">
            if the specified value is less than
            <c>0</c>.
            </exception>
      <remarks>
            Specifies the left lane insets where no element
            will lie in the resulting drawing.
            The default is <c>0.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.MinimumLaneWidth">
      <summary>The minimum lane width.</summary>
      <exception cref="T:System.ArgumentException">
            if the specified value is less than
            <c>0</c>.
            </exception>
      <remarks>
            Getter:<br />
            Returns the minimum lane width.
            The default is <c>0.0d</c>.
            <para />
            Setter:<br />
            Sets the minimum width of the lane.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor.RightLaneInset">
      <summary>
            The right lane insets where no element
            will lie in the resulting drawing.
            </summary>
      <exception cref="T:System.ArgumentException">
            if the specified value is less than
            <c>0</c>.
            </exception>
      <remarks>
            Specifies the right lane insets where no element
            will lie in the resulting drawing.
            The default is <c>0.0d</c>.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage">
      <summary>
            This layout stage can be used to automatically assign
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor" />
            instances to nodes using the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.SwimlaneDescriptorDpKey" />
            by treating top-level group nodes as swimlanes.
            </summary>
      <remarks>
            This layout stage can be used to automatically assign
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.SwimLaneDescriptor" />
            instances to nodes using the
            <see cref="F:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter.SwimlaneDescriptorDpKey" />
            by treating top-level group nodes as swimlanes.
            This stage will modify the hierarchy by removing the top level group nodes and assign corresponding
            descriptors to the remaining nodes. After running the core layout, the nodes will be arranged to function as swim
            lanes. This class allows for using the current coordinates of the group nodes
            to
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.OrderSwimlanesFromSketch">arrange the swim lanes from sketch</see>
            .
            Also the
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.Spacing">spacing</see>
            between swim lanes may be specified.<p />
            This stage can be
            <see cref="M:yWorks.yFiles.Layout.CanonicMultiStageLayouter.AppendStage(yWorks.yFiles.Layout.ILayoutStage)">appended</see>
            to the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.IncrementalHierarchicLayouter" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.OrderSwimlanesFromSketch">
      <summary>Determines whether the order of the swimlanes should be read from the current sketch.</summary>
      <remarks>
            Determines whether the order of the swimlanes should be read from the current sketch.
            The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TopLevelGroupToSwimlaneStage.Spacing">
      <summary>Determines the spacing between the lanes.</summary>
      <remarks>
            Determines the spacing between the lanes.
            The default is <c>0.0d</c>.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer">
      <summary>
            Inserts nodes incrementally into an existing layer structure, without destroying
            the latter.
            </summary>
      <remarks>
            Inserts nodes incrementally into an existing layer structure, without destroying
            the latter. Nodes are inserted such that the length of backwards pointing edges
            is minimized (not their number!). The method implemented will insert new layers
            into the current layering if necessary at locally optimal positions.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer.#ctor">
      <summary>Creates a new instance of IncrementalLayerer</summary>
      <remarks>Creates a new instance of IncrementalLayerer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer.AssignLayers(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Calculates an optimal layering for incremental nodes</summary>
      <param name="graph">
            the graph containing all nodes in layers and all nodes in incrementalNodes as
            well as the respective edges.
            </param>
      <param name="layers">the Layers structure containing all nodes but the incremental ones.</param>
      <remarks>Calculates an optimal layering for incremental nodes</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer.LayeredComponentsMerger">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger" />
            instance that will be used to
            merge the layers of separate components into the current layering.
            </summary>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayeredComponentsMerger" />
            instance that will be used to
            merge the layers of separate components into the current layering.
            Default is
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.DefaultLayeredComponentsMerger" />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TopologicalIncrementalLayerer.SeparateComponentsLayerer">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            instance used for the layering of separate
            components.
            </summary>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.ILayerer" />
            instance used for the layering of separate
            components.
            Default is an instance of
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.Incremental.OldLayererWrapper" />
            wrapping a
            <see cref="T:yWorks.yFiles.Layout.Hierarchic.WeightedLayerer" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator">
      <summary>
            This implementation returns the minimum distances for each kind of node pair
            based on their type as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" /></summary>
      <remarks>
            This implementation returns the minimum distances for each kind of node pair
            based on their type as returned by
            <see cref="P:yWorks.yFiles.Layout.Hierarchic.Incremental.INodeData.Type" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.#ctor">
      <summary>Creates a new instance of TypeBasedDrawingDistanceCalculator</summary>
      <remarks>Creates a new instance of TypeBasedDrawingDistanceCalculator</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.Dispose(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to dispose internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that was used</param>
      <param name="ldp">the LayoutDataProvider that was used to query information</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.Edge2EdgeDistance">
      <summary>The distance between edges.</summary>
      <remarks>Specifies the distance between edges.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.GetMinDistance(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayer,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node)">
      <summary>Main interface method.</summary>
      <param name="graph">the graph that contains the nodes</param>
      <param name="layer">the layer object that contains the nodes</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
      <param name="left">
            the left one of the two nodes whose
            minimum distance is to be determined or <see langword="null" /> if only the left border of the right node is
            of interest.
            </param>
      <param name="right">
            the right one of the two nodes whose
            minimum distance is to be determined or <see langword="null" /> if only the right border of the left node is
            of interest.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.Initialize(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayers,yWorks.yFiles.Layout.Hierarchic.Incremental.ILayoutDataProvider)">
      <summary>Called to initialize internal data structures.</summary>
      <param name="graph">
            the graph that contains all elements that are used during
            the node placement
            </param>
      <param name="layers">the Layers object that will be used during subsequent calls</param>
      <param name="ldp">the LayoutDataProvider that can be used to query information</param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.MinimumFirstSegmentLength">
      <summary>The minimum length of the first and last segment of an edge.</summary>
      <remarks>Specifies the minimum length of the first and last segment of an edge.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.Node2EdgeDistance">
      <summary>The distance between nodes and edges.</summary>
      <remarks>Specifies the distance between nodes and edges.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Hierarchic.Incremental.TypeBasedDrawingDistanceCalculator.Node2NodeDistance">
      <summary>The distance between nodes.</summary>
      <remarks>Specifies the distance between nodes.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm">
      <summary>This class is an abstract base class for labeling algorithms.</summary>
      <remarks>This class is an abstract base class for labeling algorithms. A labeling algorithm places a set of labels.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.#ctor">
      <summary>Creates a new instance of this class.</summary>
      <remarks>Creates a new instance of this class.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.ApplyPostprocessing">
      <summary>True if the postprocessing step is applied.</summary>
      <remarks>
            Getter:<br />
            Returns true if the postprocessing step is applied. The postprocessing step tries to further reduce the number of
            overlaps.
            <para />
            Setter:<br />
            Sets if the postprocessing step should be applied. The postprocessing step tries to further reduce the number of
            overlaps.
            <p />
            Note: the postprocessing step is only applied to edge labels whose edge label model is
            <c>FreeEdgeLabelModel</c> and node labels whose node label model is <c>FreeNodeLabelModel</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true" />.</summary>
      <remarks>Returns <see langword="true" />.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            It is called by the label-methods for each group node object in the input graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            It is called by the label-methods for each node object in the input graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Place the labels in the graph.</summary>
      <param name="graph">The graph to label.</param>
      <remarks>Place the labels in the graph. This method is equivalent to the <c>label()</c> method.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.EdgeGroupOverlapAllowed">
      <summary>Specifies whether edge labels may overlap with edges belonging to the same edge group.</summary>
      <remarks>
            Getter:<br />
            Returns whether edge labels may overlap with edges belonging to the same edge group.
            <para />
            Setter:<br />
            Sets the policy for edge groups. If edge labels overlap with other edges of the same group, this flag decides
            whether these positions are allowed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.GetProfit(yWorks.yFiles.Layout.LabelCandidate)">
      <summary>Returns the profit model that is used to rank the available positions for each label.</summary>
      <remarks>
            Returns the profit model that is used to rank the available positions for each label. The higher the rank of a
            position, the more likely it will be chosen by the algorithm. By default an instance of type
            <see cref="T:yWorks.yFiles.Layout.LabelRanking" />
            is set.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.Label(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Place the labels in the graph.</summary>
      <param name="gl">The graph to label.</param>
      <remarks>Place the labels in the graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.Label(yWorks.yFiles.Layout.LayoutGraph,System.Object)">
      <summary>Place a subset of the labels.</summary>
      <param name="key">
            The key for a <c>DataProvider</c> in <c>gl</c>. Labels which should be placed return
            <see langword="true" />.
            </param>
      <remarks>Place a subset of the labels.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.Label(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Algorithms.YList)">
      <summary>Place some labels in the graph.</summary>
      <remarks>Place some labels in the graph. The selection is ignored, if set.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.LabelModelDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key to specify for each
            <see cref="T:yWorks.yFiles.Layout.IEdgeLabelLayout" />
            s and each
            <see cref="T:yWorks.yFiles.Layout.INodeLabelLayout" />
            a replacement
            <see cref="T:yWorks.yFiles.Layout.IEdgeLabelModel" />
            or
            <see cref="T:yWorks.yFiles.Layout.INodeLabelModel" />
            ,
            respectively, that is used by the labeling algorithm instead of the original label model.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key to specify for each
            <see cref="T:yWorks.yFiles.Layout.IEdgeLabelLayout" />
            s and each
            <see cref="T:yWorks.yFiles.Layout.INodeLabelLayout" />
            a replacement
            <see cref="T:yWorks.yFiles.Layout.IEdgeLabelModel" />
            or
            <see cref="T:yWorks.yFiles.Layout.INodeLabelModel" />
            ,
            respectively, that is used by the labeling algorithm instead of the original label model. If this key is not
            defined or if a label has no mapping, the original model is used as normal. Otherwise, a model parameter that
            fits the calculated position of the replacement model best is set for the original model.
            <p />
            This feature is especially useful to restrict a free model. For example, to place a label upon its associated edge,
            a centered
            <see cref="T:yWorks.yFiles.Layout.RotatedSliderEdgeLabelLayoutModel" />
            can be used a replacement model.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.MoveInternalNodeLabels">
      <summary>True if the labeling algorithm is allowed to move internal node labels.</summary>
      <remarks>
            Specifies true if the labeling algorithm is allowed to move internal node labels.
            A node label is deemed internal if the label's bounds are completely within the node bounds.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.PlaceEdgeLabels">
      <summary>Specifies whether labels assigned to edges in a graph should be placed or ignored.</summary>
      <remarks>
            Specifies whether labels assigned to edges in a graph should be placed or ignored. This method has higher priority
            than a specified selection, that means that all selected edge labels are ignored by this algorithm if this property
            is set to <see langword="false" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.PlaceNodeLabels">
      <summary>Specifies whether labels assigned to nodes in a graph should be placed or ignored.</summary>
      <remarks>
            Specifies whether labels assigned to nodes in a graph should be placed or ignored. This method has higher priority
            than a specified selection, that means that all selected node labels are ignored by this algorithm if this property
            is set to <see langword="false" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.ProfitModel">
      <summary>The profit model that is used to rank the available positions for each label.</summary>
      <remarks>
            Sets the profit model that is used to rank the available positions for each label. The higher the rank of a
            position, the more likely it will be chosen by the algorithm. By default an instance of type
            <see cref="T:yWorks.yFiles.Layout.LabelRanking" />
            is set.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.Rects">
      <summary>The set of all generated candidate rectangles.</summary>
      <remarks>
            Returns the set of all generated candidate rectangles.
            <p>
            <b>Debug only.</b>
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.RemoveEdgeOverlaps">
      <summary>How label candidates which overlap with edges are handled.</summary>
      <remarks>
            Specifies how label candidates which overlap with edges are handled. If <see langword="true" /> these candidates are not
            considered, if <see langword="false" /> these candidates are considered, but a penalty is assigned to them.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.RemoveNodeOverlaps">
      <summary>How label candidates which overlap with nodes are handled.</summary>
      <remarks>
            Specifies how label candidates which overlap with nodes are handled. If <see langword="true" /> these candidates are not
            considered, if <see langword="false" /> these candidates are considered, but a penalty is assigned to them.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.SelectedLabelsDpKey">
      <summary>The labeling selection <c>DataProvider</c> key.</summary>
      <remarks>
            Setter:<br />
            Sets the <c>DataProvider</c> key, under which the labeling selection
            can be retrieved.
            The data provider registered with this key has to return <see langword="true" />
            for labels that should be placed and <see langword="false" /> for all other
            labels.
            <para />
            Getter:<br />
            Returns the labeling selection <c>DataProvider</c> key.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.StoreRects">
      <summary>Specifies whether the candidate rectangles should be stored to be retrieved.</summary>
      <remarks>
            Specifies whether the candidate rectangles should be stored to be retrieved.
            <p>
            <b>Debug only.</b>
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.AbstractLabelingAlgorithm.UseAlternativeSideHandling">
      <summary>
        <see langword="true" /> if the preference on which side of an edge a
            corresponding label should be placed is interpreted by human perception
            instead of always following the edge from source to target.
            </summary>
      <remarks>
            Getter:<br />
            Returns <see langword="true" /> if the preference on which side of an edge a
            corresponding label should be placed is interpreted by human perception
            instead of always following the edge from source to target.
            <para />
            Setter:<br />
            Specifies whether the preference on which side of an edge a corresponding
            label should be placed is interpreted by human perception instead of
            always following the edge from source to target.
            <p>
            Note: the alternative side handling is only applied to edge labels
            whose edge label model is <c>FreeEdgeLabelModel</c>.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Labeling.GreedyMISLabeling">
      <summary>This class places the labels of a graph using a greedy strategy.</summary>
      <remarks>
            This class places the labels of a graph using a greedy strategy.
            This is the fastest label placing algorithm provided.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.GreedyMISLabeling.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Labeling.GreedyMISLabeling" /> class</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm">
      <summary>Solving labeling problem by reducing it to the maximum independent set problem.</summary>
      <remarks>Solving labeling problem by reducing it to the maximum independent set problem.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.#ctor">
      <summary>Initializes a new instance of the MISLabelingAlgorithm class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.AssignProfit">
      <summary>Creates a node map which assigns to each node the profit.</summary>
      <remarks>Creates a node map which assigns to each node the profit.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.boxesToNodes" />
    <member name="F:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.conflictGraph">
      <summary>the conflict graph</summary>
      <remarks>the conflict graph</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.CreateEdges">
      <summary>Creates one edge between two nodes if the corresponding label candidates are intersecting.</summary>
      <remarks>Creates one edge between two nodes if the corresponding label candidates are intersecting.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.CustomProfitModelRatio" />
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.FoundEdgeOverlap(yWorks.yFiles.Layout.LabelCandidate,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.Geometry.LineSegment)">
      <summary>Calculates the overlapping factor between a label candidate and an edge segment.</summary>
      <remarks>Calculates the overlapping factor between a label candidate and an edge segment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.FoundLabelOverlap(yWorks.yFiles.Layout.LabelCandidate,yWorks.yFiles.Layout.LabelCandidate,yWorks.yFiles.Algorithms.Edge)">
      <summary>Calculates the overlapping factor between two label candidates.</summary>
      <remarks>Calculates the overlapping factor between two label candidates. Default value is 1.0.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.FoundNodeOverlap(yWorks.yFiles.Layout.LabelCandidate,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Geometry.YRectangle)">
      <summary>Calculates the overlapping factor between a label candidate and a node.</summary>
      <remarks>Calculates the overlapping factor between a label candidate and a node.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.graph" />
    <member name="F:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.nodesToBoxes">
      <summary>holds for each node in the conflictGraph the corresponding LabelCandidate</summary>
      <remarks>holds for each node in the conflictGraph the corresponding LabelCandidate</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.nodesToID">
      <summary>holds for each node in the conflictGraph the corresponding integer index of the Label[]</summary>
      <remarks>holds for each node in the conflictGraph the corresponding integer index of the Label[]</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.MISLabelingAlgorithm.OptimizationStrategy">
      <summary>The optimization strategy of the labeling algorithm.</summary>
      <remarks>
            Specifies the optimization strategy of the labeling algorithm.
            Possible values are:
            <see cref="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.None" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.Balanced" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.NodeOverlap" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.EdgeOverlap" />
            and
            <see cref="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.LabelOverlap" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Labeling.OptimizationStrategy" />
    <member name="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.Balanced">
      <summary>Use a balanced optimization strategy.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.NodeOverlap">
      <summary>Use an optimization strategy that especially reduces overlaps between labels and nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.LabelOverlap">
      <summary>Use an optimization strategy that especially reduces overlaps between labels.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.EdgeOverlap">
      <summary>Use an optimization strategy that especially reduces overlaps between labels and edges.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Labeling.OptimizationStrategy.None">
      <summary>Use no optimization strategy.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Labeling.SALabeling">
      <summary>
            This class is based on the enhanced profit model and places the labels of a graph using a simulated annealing
            strategy taking into account the amount of overlaps of labels.
            </summary>
      <remarks>
            This class is based on the enhanced profit model and places the labels of a graph using a simulated annealing
            strategy taking into account the amount of overlaps of labels. The algorithm is inspired by the article of
            Christensen, Marks and Shieber.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Labeling.SALabeling.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Labeling.SALabeling" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.SALabeling.DeterministicMode">
      <summary>Specifies whether or not this labeling algorithm should work deterministically.</summary>
      <remarks>
            Specifies whether or not this labeling algorithm should work
            deterministically. In deterministic mode this labeling algorithm produces
            the same layout results for the same input graph and layout/labeling
            parameters.
            <p>
            By default deterministic mode is disabled.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Labeling.SALabeling.MaximalDuration">
      <summary>The time limit for the algorithm (in milliseconds).</summary>
      <remarks>
            Setter:<br />
            Sets a time limit for the labeling algorithm. Note, that this limit is not strictly observed.
            <para />
            Getter:<br />
            Returns the time limit for the algorithm (in milliseconds).
            Note, that this limit is not strictly observed.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.DefaultElementFactory">
      <summary>Default implementation of an ElementFactory.</summary>
      <remarks>Default implementation of an ElementFactory.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Multipage.DefaultElementFactory" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.CreateConnectorEdge(yWorks.yFiles.Layout.Multipage.LayoutContext,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object,System.Boolean)">
      <summary>
            Callback method for creating an edge of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeType.Connector" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="connector">the endpoint of the edge that represents the connector node.</param>
      <param name="opposite">the other endpoint of the edge.</param>
      <param name="origEdgeId">the id of the edge that is split by the connector edge.</param>
      <param name="atTarget">whether or not the connector node is the target of the edge.</param>
      <returns>the created connector edge.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.CreateConnectorNode(yWorks.yFiles.Layout.Multipage.LayoutContext,yWorks.yFiles.Algorithms.YList,System.Object)">
      <summary>
            Callback method for creating a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="edgesIds">
            a list that contains the ids of edges that are split by this connector. Note: multi-edges
            (edges connecting the same nodes) may be split by the same connector pair.
            </param>
      <param name="representedNodeId">the id of the node that is represented by this connector.</param>
      <returns>the created connector node</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.CreateProxyEdge(yWorks.yFiles.Layout.Multipage.LayoutContext,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object,System.Object)">
      <summary>
            Callback method for creating an edge of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeType.Proxy" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="proxyNode">the endpoint of the edge that represents the proxy node.</param>
      <param name="opposite">the other endpoint of the new edge.</param>
      <param name="replacingEdgeId">the id of the related edge that is connected to the original node.</param>
      <param name="origNodeId">the id of the original node to which the proxy node refers to.</param>
      <returns>the created proxy edge.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.CreateProxyNode(yWorks.yFiles.Layout.Multipage.LayoutContext,System.Object)">
      <summary>
            Callback method for creating a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Proxy" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="origNodeId">the id of the node for which a proxy has to be created.</param>
      <returns>the proxy.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.CreateProxyReferenceEdge(yWorks.yFiles.Layout.Multipage.LayoutContext,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>
            Callback method for creating an edge of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeType.ProxyReference" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="proxyReference">
            the endpoint of the edge that represents the proxy
            reference node.
            </param>
      <param name="opposite">the other endpoint of the new edge.</param>
      <param name="referencingCopyId">
            the id of the proxy node that is referenced by the
            proxy reference node.
            </param>
      <returns>the created proxy reference edge.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.CreateProxyReferenceNode(yWorks.yFiles.Layout.Multipage.LayoutContext,System.Object)">
      <summary>
            Callback method for creating a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.ProxyReference" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="referringProxyId">the id of the proxy to which the created node refers to.</param>
      <returns>the new proxy reference node.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.GetDefaultNodeSize(yWorks.yFiles.Layout.Multipage.LayoutContext,System.Object,System.SByte)">
      <summary>Returns the default size for nodes created by this factory.</summary>
      <param name="context">
            an object providing relevant layout information,
            e.g., the current graph as well as various information about the graph
            elements.
            </param>
      <param name="id">
            the element ID that was passed to the calling <c>create</c>
            method.
            </param>
      <param name="type">the type of node to be created.</param>
      <returns>the default size of the new node.</returns>
      <remarks>
            Returns the default size for nodes created by this factory.
            Called from
            <see cref="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.CreateConnectorNode(yWorks.yFiles.Layout.Multipage.LayoutContext,yWorks.yFiles.Algorithms.YList,System.Object)" />
            ,
            <see cref="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.CreateProxyReferenceNode(yWorks.yFiles.Layout.Multipage.LayoutContext,System.Object)" />
            , and/or
            <see cref="M:yWorks.yFiles.Layout.Multipage.DefaultElementFactory.CreateProxyNode(yWorks.yFiles.Layout.Multipage.LayoutContext,System.Object)" />
            .
            Must return a non-<see langword="null" /> size with positive width and height.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.EdgeBundleMode">
      <summary>Edge bundle mode specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.EdgeBundleMode.DistinguishMultiEdges">
      <summary>
            Edge bundle mode specifier.
            Used to define edge bundles. All multi-edges (edges with same endpoints) belonging to the same edge bundle are
            split by the same connector pair (see
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector" />
            ).
            This value specifies that all multi-edges should be distinguished, i.e., a separate connector pair is used for each
            multi-edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.EdgeBundleMode.DistinguishDirections">
      <summary>
            Edge bundle mode specifier.
            Used to define edge bundles. All multi-edges (edges with same endpoints) belonging to the same edge bundle are
            split by the same connector pair (see
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector" />
            ).
            This value specifies that multi-edges should be distinguished if the have different directions.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.EdgeBundleMode.DistinguishTypes">
      <summary>
            Edge bundle mode specifier.
            Used to define edge bundles. All multi-edges (edges with same endpoints) belonging to the same edge bundle are
            split by the same connector pair (see
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector" />
            ).
            This value specifies that multi-edges should be distinguished if they are of different (user specified) type, see
            <see cref="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.EdgeTypeDpKey" />
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.EdgeType">
      <summary>Edge type specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.EdgeType.Normal">
      <summary>
            Edge type specifier.
            This value specifies that the edge is a normal edge, i.e., it does not belong to another type.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.EdgeType.Connector">
      <summary>
            Edge type specifier.
            This value specifies that the edge is connected to a connector node (a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector" />
            }), i.e., it represents an edge of the input graph
            whose endpoints lie on different pages.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.EdgeType.ProxyReference">
      <summary>
            Edge type specifier.
            This value specifies that the edge is connected to a proxy reference node
            (a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.ProxyReference" />
            }), i.e., a node that
            refers to a proxy of an original node lying on another page.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.EdgeType.Proxy">
      <summary>
            Edge type specifier.
            This value specifies that the edge is connected to a proxy node (a node of
            type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Proxy" />
            }), i.e., a node that is a proxy of an
            original node lying on another page.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.GroupingMode">
      <summary>Node grouping specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.GroupingMode.Ignore">
      <summary>
            Node grouping specifier.
            This value specifies that group nodes are completely ignored.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.GroupingMode.OriginalNodesOnly">
      <summary>
            Node grouping specifier.
            This value specifies that only original nodes are assigned in group nodes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.GroupingMode.AllNodes">
      <summary>
            Node grouping specifier.
            This value specifies that special nodes like, e.g., connector and proxy
            nodes are assigned to group nodes, too.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.IEdgeInfo">
      <summary>A class that holds all information related to an edge.</summary>
      <remarks>A class that holds all information related to an edge.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.IEdgeInfo.Id">
      <summary>The unique id of the related edge.</summary>
      <remarks>Returns the unique id of the related edge.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.IEdgeInfo.RepresentedEdge">
      <summary>The original edge.</summary>
      <remarks>
            Returns the original edge.
            That is, for edges of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeType.Connector" />
            ,
            the edge of the input graph that was split by the connector edge is
            returned.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.IEdgeInfo.Type">
      <summary>The type of the related edge.</summary>
      <remarks>Returns the type of the related edge.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.IEdgeLabelInfo">
      <summary>A class that holds all information related to an edge label.</summary>
      <remarks>A class that holds all information related to an edge label.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.IEdgeLabelInfo.Id">
      <summary>The unique id of the related edge label.</summary>
      <remarks>Returns the unique id of the related edge label.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.IElementFactory">
      <summary>
            Factory used by class
            <see cref="T:yWorks.yFiles.Layout.Multipage.MultiPageLayouter" />
            to create special nodes and edges.
            </summary>
      <remarks>
            Factory used by class
            <see cref="T:yWorks.yFiles.Layout.Multipage.MultiPageLayouter" />
            to create special nodes and edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.IElementFactory.CreateConnectorEdge(yWorks.yFiles.Layout.Multipage.LayoutContext,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object,System.Boolean)">
      <summary>
            Callback method for creating an edge of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeType.Connector" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="connector">the endpoint of the edge that represents the connector node.</param>
      <param name="opposite">the other endpoint of the edge.</param>
      <param name="origEdgeId">the id of the edge that is split by the connector edge.</param>
      <param name="atTarget">whether or not the connector node is the target of the edge.</param>
      <returns>the created connector edge.</returns>
      <remarks>
            Callback method for creating an edge of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeType.Connector" />
            .
            The edge should connect the given connector and opposite node.
            Note: all implementations have to use method
            <see cref="M:yWorks.yFiles.Layout.Multipage.LayoutContext.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)" />
            to create the edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.IElementFactory.CreateConnectorNode(yWorks.yFiles.Layout.Multipage.LayoutContext,yWorks.yFiles.Algorithms.YList,System.Object)">
      <summary>
            Callback method for creating a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="edgesIds">
            a list that contains the ids of edges that are split by this connector. Note: multi-edges
            (edges connecting the same nodes) may be split by the same connector pair.
            </param>
      <param name="representedNodeId">the id of the node that is represented by this connector.</param>
      <returns>the created connector node</returns>
      <remarks>
            Callback method for creating a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector" />
            .
            Note: all implementations have to use method
            <see cref="M:yWorks.yFiles.Layout.Multipage.LayoutContext.CreateNode(System.Object)" />
            to create the node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.IElementFactory.CreateProxyEdge(yWorks.yFiles.Layout.Multipage.LayoutContext,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object,System.Object)">
      <summary>
            Callback method for creating an edge of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeType.Proxy" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="proxyNode">the endpoint of the edge that represents the proxy node.</param>
      <param name="opposite">the other endpoint of the new edge.</param>
      <param name="replacingEdgeId">the id of the related edge that is connected to the original node.</param>
      <param name="origNodeId">the id of the original node to which the proxy node refers to.</param>
      <returns>the created proxy edge.</returns>
      <remarks>
            Callback method for creating an edge of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeType.Proxy" />
            .
            The edge should connect the given proxy node and opposite node.
            Note: all implementations have to use method
            <see cref="M:yWorks.yFiles.Layout.Multipage.LayoutContext.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)" />
            to create the edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.IElementFactory.CreateProxyNode(yWorks.yFiles.Layout.Multipage.LayoutContext,System.Object)">
      <summary>
            Callback method for creating a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Proxy" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="origNodeId">the id of the node for which a proxy has to be created.</param>
      <returns>the proxy.</returns>
      <remarks>
            Callback method for creating a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Proxy" />
            .
            Note: all implementations have to use method
            <see cref="M:yWorks.yFiles.Layout.Multipage.LayoutContext.CreateNode(System.Object)" />
            to create the node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.IElementFactory.CreateProxyReferenceEdge(yWorks.yFiles.Layout.Multipage.LayoutContext,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>
            Callback method for creating an edge of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeType.ProxyReference" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="proxyReference">
            the endpoint of the edge that represents the proxy
            reference node.
            </param>
      <param name="opposite">the other endpoint of the new edge.</param>
      <param name="referencingCopyId">
            the id of the proxy node that is referenced by the
            proxy reference node.
            </param>
      <returns>the created proxy reference edge.</returns>
      <remarks>
            Callback method for creating an edge of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeType.ProxyReference" />
            .
            This (undirected) edge should connect the given proxy reference and opposite node.
            Note: all implementations have to use method
            <see cref="M:yWorks.yFiles.Layout.Multipage.LayoutContext.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)" />
            to create the edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.IElementFactory.CreateProxyReferenceNode(yWorks.yFiles.Layout.Multipage.LayoutContext,System.Object)">
      <summary>
            Callback method for creating a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.ProxyReference" />
            .
            </summary>
      <param name="context">
            an object providing relevant layout information, e.g., the current graph as well as
            various information about the graph elements.
            </param>
      <param name="referringProxyId">the id of the proxy to which the created node refers to.</param>
      <returns>the new proxy reference node.</returns>
      <remarks>
            Callback method for creating a node of type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.ProxyReference" />
            .
            Note: all implementations have to use method
            <see cref="M:yWorks.yFiles.Layout.Multipage.LayoutContext.CreateNode(System.Object)" />
            to create the node.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.IElementInfoManager">
      <summary>Interface that offers access to the information objects of graph elements.</summary>
      <remarks>Interface that offers access to the information objects of graph elements.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.IElementInfoManager.GetEdgeInfo(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the edge information object of the given edge.</summary>
      <param name="e">the edge for which the information object should be returned.</param>
      <returns>the edge information object of the given edge.</returns>
      <remarks>Returns the edge information object of the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.IElementInfoManager.GetEdgeLabelInfo(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns the edge label information object of the given edge label layout.</summary>
      <param name="ell">the edge label layout for which the information object should be returned.</param>
      <returns>the edge label information object of the given edge label layout.</returns>
      <remarks>Returns the edge label information object of the given edge label layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.IElementInfoManager.GetNodeInfo(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the node information object of the given node.</summary>
      <param name="n">the node for which the information object should be returned.</param>
      <returns>the node information object of the given node.</returns>
      <remarks>Returns the node information object of the given node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.IElementInfoManager.GetNodeLabelInfo(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns the node label layout information object of the given node label layout.</summary>
      <param name="nll">the node label layout for which the information object should be returned.</param>
      <returns>the node label information object of the given node label layout.</returns>
      <remarks>Returns the node label layout information object of the given node label layout.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.ILayoutCallback">
      <summary>
            Callback that is invoked when a
            <see cref="T:yWorks.yFiles.Layout.Multipage.MultiPageLayouter" />
            has calculated
            a new multi-page layout.
            </summary>
      <remarks>
            Callback that is invoked when a
            <see cref="T:yWorks.yFiles.Layout.Multipage.MultiPageLayouter" />
            has calculated
            a new multi-page layout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.ILayoutCallback.LayoutDone(yWorks.yFiles.Layout.Multipage.MultiPageLayout)">
      <summary>
            Invoked from
            <see cref="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            when a new multi-page layout has been calculated.
            </summary>
      <param name="result">the result of the layout calculation.</param>
      <remarks>
            Invoked from
            <see cref="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            when a new multi-page layout has been calculated.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.INodeInfo">
      <summary>A class that holds all information related to a node.</summary>
      <remarks>A class that holds all information related to a node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.INodeInfo.Id">
      <summary>The unique id of the related node.</summary>
      <remarks>Returns the unique id of the related node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.INodeInfo.PageNo">
      <summary>The page of the related node.</summary>
      <remarks>Returns the page of the related node. This information is available after the layout.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.INodeInfo.ReferencingNode">
      <summary>The referencing node.</summary>
      <remarks>
            Returns the referencing node.
            That is, if the related node has type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector">connector</see>
            this method returns the opposite connector node, if the related node has
            type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.ProxyReference">proxy reference</see>
            it returns the
            corresponding proxy node, if the related node has type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Proxy">proxy</see>
            it returns the corresponding proxy reference
            node; otherwise it returns <see langword="null" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.INodeInfo.RepresentedNode">
      <summary>The represented node (always a node of the input graph).</summary>
      <remarks>
            Returns the represented node (always a node of the input graph).
            That is,
            if the related node has type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector">connector</see>
            this method returns the neighbor of the matching connector node,
            if the related node has type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Proxy">proxy</see>
            it returns the corresponding original node,
            if the related node has type
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.ProxyReference">proxy reference</see>
            it returns <see langword="null" />,
            and, otherwise, it returns the corresponding node in the input graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.INodeInfo.Type">
      <summary>The type of the related node.</summary>
      <remarks>Returns the type of the related node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.INodeLabelInfo">
      <summary>A class that holds all information related to a node label.</summary>
      <remarks>A class that holds all information related to a node label.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.INodeLabelInfo.Id">
      <summary>The unique id of the related node label.</summary>
      <remarks>Returns the unique id of the related node label.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.LayoutContext">
      <summary>Class that represents the layout context.</summary>
      <remarks>Class that represents the layout context.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.AddEdgeLabel(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Algorithms.Edge)">
      <summary>Adds a label to an edge.</summary>
      <param name="label">the label that should be added to the edge.</param>
      <param name="labeledElement">the edge the label should be added to.</param>
      <remarks>Adds a label to an edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.AddNodeLabel(yWorks.yFiles.Layout.INodeLabelLayout,yWorks.yFiles.Algorithms.Node)">
      <summary>Adds a label to a node.</summary>
      <param name="label">the label that should be added to the node.</param>
      <param name="labeledElement">the node the label should be added to.</param>
      <remarks>Adds a label to a node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.CreateEdge(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object)">
      <summary>
            All methods of the
            <see cref="T:yWorks.yFiles.Layout.Multipage.IElementFactory" />
            have to use this method to create an edge.
            </summary>
      <param name="source">the source of the edge.</param>
      <param name="target">the target of the edge.</param>
      <param name="sameDataElementId">
            the id of the edge whose data should be copied to the created edge
            (or null if no data should be copied).
            </param>
      <returns>the created edge.</returns>
      <remarks>
            All methods of the
            <see cref="T:yWorks.yFiles.Layout.Multipage.IElementFactory" />
            have to use this method to create an edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.CreateNode(System.Object)">
      <summary>
            All methods of the
            <see cref="T:yWorks.yFiles.Layout.Multipage.IElementFactory" />
            have to use this method to create a node.
            </summary>
      <param name="sameDataElementId">
            the id of the node whose data should be copied to the created node
            (or null if no data should be copied).
            </param>
      <returns>the created node.</returns>
      <remarks>
            All methods of the
            <see cref="T:yWorks.yFiles.Layout.Multipage.IElementFactory" />
            have to use this method to create a node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.GetEdgeInfo(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the edge information object of the given edge.</summary>
      <param name="e">the edge for which the information object should be returned.</param>
      <returns>the edge information object of the given edge.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.GetEdgeLabelInfo(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns the edge label information object of the given edge label layout.</summary>
      <param name="ell">the edge label layout for which the information object should be returned.</param>
      <returns>the edge label information object of the given edge label layout.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.GetNodeInfo(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the node information object of the given node.</summary>
      <param name="n">the node for which the information object should be returned.</param>
      <returns>the node information object of the given node.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.GetNodeLabelInfo(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns the node label layout information object of the given node label layout.</summary>
      <param name="nll">the node label layout for which the information object should be returned.</param>
      <returns>the node label information object of the given node label layout.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.GetOriginalEdge(System.Object)">
      <summary>Returns the edge of the input graph with the given id or null if there is no such edge.</summary>
      <param name="id">the id of the edge that should be returned.</param>
      <returns>the edge of the input graph with the given id or null if there is no such edge.</returns>
      <remarks>Returns the edge of the input graph with the given id or null if there is no such edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.GetOriginalNode(System.Object)">
      <summary>Returns the node of the input graph with the given id or null if there is no such node.</summary>
      <param name="id">the id of the node that should be returned.</param>
      <returns>the node of the input graph with the given id or null if there is no such node.</returns>
      <remarks>Returns the node of the input graph with the given id or null if there is no such node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.GetPageEdge(System.Object)">
      <summary>
            Returns the edge of a page graph (a graph that represents the result of the multi page layout)
            with the given id or null if there is no such edge.
            </summary>
      <param name="id">the id of the edge that should be returned.</param>
      <returns>the edge of a page graph with the given id or null if there is no such edge.</returns>
      <remarks>
            Returns the edge of a page graph (a graph that represents the result of the multi page layout)
            with the given id or null if there is no such edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.GetPageNode(System.Object)">
      <summary>
            Returns the node of a page graph (a graph that represents the result of the multi page layout)
            with the given id or null if there is no such node.
            </summary>
      <param name="id">the id of the node that should be returned.</param>
      <returns>the node of a page graph with the given id or null if there is no such node.</returns>
      <remarks>
            Returns the node of a page graph (a graph that represents the result of the multi page layout)
            with the given id or null if there is no such node.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.LayoutContext.Graph">
      <summary>The relevant graph.</summary>
      <remarks>Returns the relevant graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.LayoutContext.Layouter">
      <summary>The layouter object that belongs to this layout context.</summary>
      <remarks>Returns the layouter object that belongs to this layout context.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.RemoveEdgeLabel(yWorks.yFiles.Layout.IEdgeLabelLayout,yWorks.yFiles.Algorithms.Edge)">
      <summary>Removes a label from an edge.</summary>
      <param name="label">the label that should be removed.</param>
      <param name="labeledElement">the edge owning the label.</param>
      <remarks>Removes a label from an edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.LayoutContext.RemoveNodeLabel(yWorks.yFiles.Layout.INodeLabelLayout,yWorks.yFiles.Algorithms.Node)">
      <summary>Removes a label from a node.</summary>
      <param name="label">the label that should be removed.</param>
      <param name="labeledElement">the node owning the label.</param>
      <remarks>Removes a label from a node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.MultiPageLayout">
      <summary>
            Represents the result of a layout run of the
            <see cref="T:yWorks.yFiles.Layout.Multipage.MultiPageLayouter" />
            .
            </summary>
      <remarks>
            Represents the result of a layout run of the
            <see cref="T:yWorks.yFiles.Layout.Multipage.MultiPageLayouter" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayout.GetEdgeInfo(yWorks.yFiles.Algorithms.Edge)">
      <summary>Returns the edge information object of the given edge.</summary>
      <param name="e">the edge for which the information object should be returned.</param>
      <returns>the edge information object of the given edge.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayout.GetEdgeLabelInfo(yWorks.yFiles.Layout.IEdgeLabelLayout)">
      <summary>Returns the edge label information object of the given edge label layout.</summary>
      <param name="ell">the edge label layout for which the information object should be returned.</param>
      <returns>the edge label information object of the given edge label layout.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayout.GetNodeInfo(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the node information object of the given node.</summary>
      <param name="n">the node for which the information object should be returned.</param>
      <returns>the node information object of the given node.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayout.GetNodeLabelInfo(yWorks.yFiles.Layout.INodeLabelLayout)">
      <summary>Returns the node label layout information object of the given node label layout.</summary>
      <param name="nll">the node label layout for which the information object should be returned.</param>
      <returns>the node label information object of the given node label layout.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayout.GetPage(System.Int32)" />
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayout.PageCount">
      <summary>Returns the number of pages available in this <c>MultiPageLayout</c>.</summary>
      <returns>the number of available pages.</returns>
      <remarks>Returns the number of pages available in this <c>MultiPageLayout</c>.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.MultiPageLayouter">
      <summary>
            Layout algorithm that subdivides the input graph into several
            <see cref="T:yWorks.yFiles.Layout.LayoutGraph" />
            s (called page graphs) such that the layout of each graph
            fits the
            <see cref="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.MaxPageSize">
            specified maximum page
            size
            </see>
            .
            </summary>
      <remarks>
            Layout algorithm that subdivides the input graph into several
            <see cref="T:yWorks.yFiles.Layout.LayoutGraph" />
            s (called page graphs) such that the layout of each graph
            fits the
            <see cref="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.MaxPageSize">
            specified maximum page
            size
            </see>
            .
            <p>
            To guarantee that no information is lost, the layout algorithm replaces edges
            between nodes on different pages by so-called connector nodes
            (see
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector" />
            ).
            Furthermore, it may replicate (proxy) nodes and insert elements called proxy
            reference nodes to refers to such proxies (see
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Proxy" />
            and
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.ProxyReference" />
            ).
            </p><p>
            Unlike other yFiles layout algorithms, <c>MultiPageLayouter</c> does
            not modify its input graph but returns its result as a
            <see cref="T:yWorks.yFiles.Layout.Multipage.MultiPageLayout" />
            . To be able to profit as much as
            possible from existing layout support, <c>MultiPageLayouter</c>
            implements the
            <see cref="T:yWorks.yFiles.Layout.ILayouter" />
            interface although method
            <see cref="M:yWorks.yFiles.Layout.ILayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">doLayout</see>
            does not specify a
            return value. Therefore client code has to
            <see cref="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.LayoutCallback">register</see>
            a
            <see cref="T:yWorks.yFiles.Layout.Multipage.ILayoutCallback" />
            that is notified of <c>MultiPageLayouter</c> results.
            </p><p>
            <b>Note:</b>
            Client code must register data providers for keys
            <see cref="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.NodeIdDpKey" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.EdgeIdDpKey" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.NodeLabelIdDpKey" />
            , and
            <see cref="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.EdgeLabelIdDpKey" />
            before calling
            <see cref="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            or
            <see cref="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.CalcLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            .
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates an instance of this layouter.</summary>
      <param name="core">the layouter used to layout a page.</param>
      <remarks>Creates an instance of this layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.CalcLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a new multi-page layout for the specified graph.</summary>
      <param name="graph">the input graph.</param>
      <returns>an object that represents the results of the layout run.</returns>
      <remarks>Calculates a new multi-page layout for the specified graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.CreateElementFactory">
      <summary>Creates an element factory for multi-page layouts.</summary>
      <returns>
            a
            <see cref="T:yWorks.yFiles.Layout.Multipage.DefaultElementFactory" />
            instance.
            </returns>
      <remarks>
            Creates an element factory for multi-page layouts.
            Called from
            <see cref="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.ElementFactory" />
            if no factory has been explicitly
            set using
            <see cref="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.ElementFactory" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.DoIncrementalLayout(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.Multipage.LayoutContext)">
      <summary>Called to improve layout results.</summary>
      <param name="graph">the graph to layout.</param>
      <param name="incrementalNodesDP">
            a DataProvider that marks nodes that should be placed (nodes for which getBool()
            returns true). The position of the other nodes is not allowed to change.
            </param>
      <param name="context">the current layout context.</param>
      <remarks>
            Called to improve layout results.
            The marked nodes have to be placed without changing the coordinates of the fixed (non-marked) elements,
            without exceeding the specified maximum page size and without violating basic layout properties.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a new multi-page layout for the specified graph.</summary>
      <param name="graph">the input graph.</param>
      <remarks>
            Calculates a new multi-page layout for the specified graph.
            This method calls
            <see cref="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.CalcLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            and notifies
            the registered
            <see cref="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.LayoutCallback">layout callback</see>
            of the
            calculated result.
            <p>
            <b>Warning:</b>
            Unlike other implementations of the
            <see cref="M:yWorks.yFiles.Layout.ILayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method, the result
            of the layout calculation will <b>not</b> be applied to the input graph.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.EdgeBundleModeMask">
      <summary>The bit mask that is used to define edge bundles.</summary>
      <remarks>
            Getter:<br />
            Returns the bit mask that is used to define edge bundles.
            <para />
            Setter:<br />
            Specifies a bit mask that is used to define edge bundles.
            All multi-edges (edges with same endpoints) belonging to the same edge bundle are
            split by the same connector pair (see
            <see cref="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector" />
            ).
            Possible values are
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeBundleMode.DistinguishTypes" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeBundleMode.DistinguishDirections" />
            and
            <see cref="F:yWorks.yFiles.Layout.Multipage.EdgeBundleMode.DistinguishMultiEdges" />
            .
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.EdgeIdDpKey">
      <summary>Used to map each edge of the input graph to a unique id.</summary>
      <remarks>
            Used to map each edge of the input graph to a unique id.
            Note: this DataProvider has to be specified by the user!
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.EdgeLabelIdDpKey">
      <summary>Used to map each edge label of the input graph to a unique id.</summary>
      <remarks>
            Used to map each edge label of the input graph to a unique id.
            Note: this DataProvider has to be specified by the user!
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.EdgeTypeDpKey" />
    <member name="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.ElementFactory">
      <summary>
            The element factory that is used to create special nodes and edges
            in a multi-page layout.
            </summary>
      <remarks>
            Specifies the element factory that is used to create special nodes and edges
            in a multi-page layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.GroupMode">
      <summary>How to handle node grouping.</summary>
      <remarks>
            Specifies how to handle node grouping.
            Possible values are
            <see cref="F:yWorks.yFiles.Layout.Multipage.GroupingMode.Ignore" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Multipage.GroupingMode.AllNodes" />
            and
            <see cref="F:yWorks.yFiles.Layout.Multipage.GroupingMode.OriginalNodesOnly" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.LabelLayouter">
      <summary>The algorithm that is used for placing labels.</summary>
      <remarks>
            Getter:<br />
            Returns the algorithm that is used for placing labels. By default an instance of class
            <see cref="T:yWorks.yFiles.Layout.Labeling.GreedyMISLabeling" />
            will be returned that considers edge labels only.
            <para />
            Setter:<br />
            Sets the algorithm that is used for placing labels. Note that assigning a new layout stage will not automatically
            activate it. To activate this stage use
            <see cref="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.LabelLayouterEnabled" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.LabelLayouterEnabled">
      <summary>Specifies whether or not the specified labeling stage is enabled.</summary>
      <remarks>
            Getter:<br />
            Returns whether or not the specified labeling stage is enabled.
            <para />
            Setter:<br />
            Specifies whether or not to enable the labeling stage.
            By default it is disabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.LayoutCallback">
      <summary>
            The callback that is notified upon completion of multi-page layout
            calculation runs.
            </summary>
      <remarks>
            Specifies the callback that is notified upon completion of multi-page layout
            calculation runs.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.MaxPageSize">
      <summary>The maximum size allowed for a single page.</summary>
      <remarks>
            Specifies the maximum size allowed for a single page. The default value is width = height = 1000.
            Note that a large page size may increase runtime significantly.
            To limit runtime use method
            <see cref="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.PreferredMaximalDuration" />
            .
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.NodeClusterIdDpKey">
      <summary>Allows to specify a cluster id (an object) for each node.</summary>
      <remarks>
            Allows to specify a cluster id (an object) for each node. Nodes with the same cluster id should preferably be
            placed on the same page.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.NodeIdDpKey">
      <summary>Used to map each node of the input graph to a unique id.</summary>
      <remarks>
            Used to map each node of the input graph to a unique id.
            Note: this DataProvider has to be specified by the user!
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.NodeLabelIdDpKey">
      <summary>Used to map each node label of the input graph to a unique id.</summary>
      <remarks>
            Used to map each node label of the input graph to a unique id.
            Note: this DataProvider has to be specified by the user!
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.PreferredMaximalDuration">
      <summary>The preferred time limit (in milliseconds) set for the layout algorithm.</summary>
      <remarks>
            Getter:<br />
            Returns the preferred time limit (in milliseconds) set for the layout algorithm.
            <para />
            Setter:<br />
            Sets a preferred time limit (in milliseconds) for the layout algorithm.
            Note that restricting the maximal duration may result in a worse layout quality.
            Furthermore, the actual runtime may exceed the maximal duration since the layout algorithm
            still has to find a valid solution.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Multipage.MultiPageLayouter.RemoveConnectorPair(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.Multipage.LayoutContext)">
      <summary>Called during a postprocessing step that reduces the number of connectors.</summary>
      <param name="connector1">the first connector of the connector pair.</param>
      <param name="connector2">the second connector of the connector pair.</param>
      <param name="originalEdgeIds">the ids of the original edges that have to be restored.</param>
      <param name="context">the current layout context.</param>
      <returns>
            whether or not the removal of the connector pair was successful.
            If the method returns false the graph was not changed, i.e., the connector pair was not removed.
            </returns>
      <remarks>
            Called during a postprocessing step that reduces the number of connectors. A pair of connectors can be removed
            if both connector nodes are placed on the same page.
            This method removes both connector nodes and restores the original edges.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Multipage.NodeType">
      <summary>Node type specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.NodeType.Normal">
      <summary>
            Node type specifier.
            This value specifies that the node is a normal node, i.e., it does not belong to another type.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.NodeType.Group">
      <summary>
            Node type specifier.
            This value specifies that the node is a group node, i.e., a node that contains other nodes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.NodeType.Proxy">
      <summary>
            Node type specifier.
            This value specifies that the node is a proxy node, i.e., it is a copy of a normal node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.NodeType.ProxyReference">
      <summary>
            Node type specifier.
            This value specifies that the node is a proxy reference node, i.e., it refers to a proxy node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Multipage.NodeType.Connector">
      <summary>
            Node type specifier.
            This value specifies that the node is a connector node, i.e., a node that represents a jump mark to another connector node.
            Such a connector pair is used to represent edges that connects two nodes on different pages.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.GRIP">
      <summary>
            This class implements a variant of the GRIP algorithm by
            P Gajer and SG Kobourov: "Graph Drawing with
            Intelligent Placement".
            </summary>
      <remarks>
            This class implements a variant of the GRIP algorithm by
            P Gajer and SG Kobourov: "Graph Drawing with
            Intelligent Placement". It implements ideas of the GUIDE algorithm,
            and fixes some bugs from the original algorithm and implementation.
            Additionally several important parts of the algorithm have been drastically
            improved.
            This layout is especially suited for huge diagrams, that would normally
            be laid out using an Organic layout. It leads to perfect results for
            mesh-like graph structures.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GRIP.#ctor">
      <summary>Creates a new instance of the GRIP layout algorithm</summary>
      <remarks>Creates a new instance of the GRIP layout algorithm</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GRIP.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.Deterministic">
      <summary>Specifies whether or not GRIP works in a deterministic manner.</summary>
      <remarks>Specifies whether or not GRIP works in a deterministic manner.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GRIP.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.FinalRounds">
      <summary>The number of the final rounds</summary>
      <remarks>
            Setter:<br />
            Sets the number of Fruchtermann Reingold rounds (final)
            <para />
            Getter:<br />
            returns the number of the final rounds
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.InitialTemperature">
      <summary>The initial temperature</summary>
      <remarks>
            Specifies the initial temperature for each round.
            This value should lie somewhere in [10..80].
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.Laxity">
      <summary>The current laxity value.</summary>
      <remarks>Specifies the current laxity value.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.NodeSizeAware">
      <summary>Specifies whether or not GRIP takes average node sizes into account.</summary>
      <remarks>Specifies whether or not GRIP takes average node sizes into account.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.PreferredEdgeLength">
      <summary>The desired edge length</summary>
      <remarks>Specifies the desired edge length</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.Rounds">
      <summary>The number of the initial rounds</summary>
      <remarks>
            Setter:<br />
            Sets the number of Kamada Kawai rounds (initial)
            <para />
            Getter:<br />
            returns the number of the initial rounds
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GRIP.SmartInitialPlacement">
      <summary>Specifies whether or not initial placements are determined in a smart way.</summary>
      <remarks>Specifies whether or not initial placements are determined in a smart way.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter">
      <summary>
            This class uses a customizable shuffle layout algorithm to recursively remove node
            overlaps from grouped graph structures.
            </summary>
      <remarks>
            This class uses a customizable shuffle layout algorithm to recursively remove node
            overlaps from grouped graph structures.
            This class can be used as a LayoutStage in which case it will perform its work
            after the core layouter instance has performed its work.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Creates a new instance of GroupedShuffleLayouter
            The given core layouter instance will get to perform its work before the
            actual shuffling takes place.
            </summary>
      <remarks>
            Creates a new instance of GroupedShuffleLayouter
            The given core layouter instance will get to perform its work before the
            actual shuffling takes place.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.GroupBoundsCalculator">
      <summary>The currently installed GroupBoundsCalculator instance</summary>
      <remarks>
            Getter:<br />
            Returns the currently installed GroupBoundsCalculator instance
            <para />
            Setter:<br />
            Sets the new GroupBoundsCalculator instance.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.GroupedShuffleLayouter.ShuffleLayouter">
      <summary>The layouter instance, that will be used for shuffling (removing node overlaps).</summary>
      <remarks>Specifies the layouter instance, that will be used for shuffling (removing node overlaps).</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.GroupsPolicy">
      <summary>Node group policy specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.GroupsPolicy.Layout">
      <summary>
            Node group policy specifier. This layouter will consider grouping
            information of an input graph. It will layout the contents of groups
            in a way that highlights their togetherness.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.GroupsPolicy.Fixed">
      <summary>
            Node group policy specifier. This layouter will keep the relative positions
            of nodes that belong to the same group. The layouter will take the
            fixed groups into account when placing the other nodes of the graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.GroupsPolicy.Ignore">
      <summary>
            Node group policy specifier. This layouter will ignore all grouping related
            information when laying out the graph.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion">
      <summary>Horizontal overlap criteria enumeration constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion.IntersectionBox">
      <summary>Horizontal overlap criteria enumeration constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion.NodeCenter">
      <summary>Horizontal overlap criteria enumeration constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion.LessMovement">
      <summary>Horizontal overlap criteria enumeration constant.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.InitialPlacement">
      <summary>Initial placement strategy.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.InitialPlacement.Random">
      <summary>Initial placement strategy. Start with randomly chosen positions.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.InitialPlacement.Zero">
      <summary>Initial placement strategy. Start with all positions set to (0,0,0).</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.InitialPlacement.AsIs">
      <summary>Initial placement strategy. Start with given positions.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter">
      <summary>
            The InteractiveOrganicLayouter is a special organic layouter that offers functionality to change the
            laid out graph while the layouter is running.
            </summary>
      <remarks>
            The InteractiveOrganicLayouter is a special organic layouter that offers functionality to change the
            laid out graph while the layouter is running.
            This layouter may be used in a threaded environment. The read-access
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.GetCenter(yWorks.yFiles.Algorithms.Node)" />
            does not have to be synchronized.
            The setters (e.g.
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetCenter(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)" />
            ) are scheduled and executed at
            a specific point within the life-cycle of the layouter.
            If a
            <see cref="T:yWorks.yFiles.Layout.CopiedLayoutGraph" />
            is being laid out, structural changes (node and edge additions/removals)
            in the original graph are automatically scheduled and executed on the copy.
            The method
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.AddStructureUpdate(System.EventHandler,System.EventArgs)" />
            may be used to schedule an event handler that is executed in a
            synchronized context and may safely update the structure of the graph.
            The layouter can also run in a single-threaded mode that is provided by a
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.StartLayoutSingleThreaded(yWorks.yFiles.Layout.LayoutGraph)" />
            single threaded context}. The
            <see cref="T:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.ISingleThreadContext" />
            provides methods to
            control layout calculation.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.#ctor">
      <summary>Create a new instance of the InteractiveOrganicLayouter.</summary>
      <remarks>Create a new instance of the InteractiveOrganicLayouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.AddStructureUpdate(System.EventHandler,System.EventArgs)">
      <summary>Adds a structural update to the queue.</summary>
      <param name="handler">The handler delegate that will be invoked using <see langword="null" /> as the sender and <paramref name="args" /> as the event arguments</param>
      <param name="args">The event argument that will be piped to the <paramref name="handler" /> invocation.</param>
      <remarks>
            Adds a structural update to the queue.
            The given delegate will be queued and executed at a specific time. Within this Runnable structural
            changes (like edge/node removals or adds) may be done. They are synchronized with the layouter.
            This method should only be used when changes to the structure of the graph are done. Every structural
            change involves a rebuild of the internal data structure.
            So "lightweight" changes like modifications of the positions of the nodes should be done using the corresponding
            methods
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetCenter(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.AutomaticStructureUpdateEnabled">
      <summary>Determines whether this algorithm performs automatic structure updates.</summary>
      <remarks>
            Determines whether this algorithm performs automatic structure updates.
            If set to <see langword="true" /> this algorithm will register a listener
            on the graph to be laid out to automatically update internal data structures
            as soon as the structure of the original graph changes.
            <p>
            The default is <see langword="false" />.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns whether this layouter can layout the given graph.</summary>
      <returns>
        <see langword="true" /> if the graph may be laid out, <see langword="false" /> otherwise.</returns>
      <remarks>Returns whether this layouter can layout the given graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.CommitPositions">
      <summary>
            This method writes the calculated positions (represented by the internal data structure of this layouter) to
            the LayoutGraph.<br />
            This method must only be called while the layouter is running
            <see cref="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Running" />
            .<p />
            There may occur synchronization issues, if
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            is not called
            using a CopiedLayoutGraph.
            </summary>
      <remarks>
            This method writes the calculated positions (represented by the internal data structure of this layouter) to
            the LayoutGraph.<br />
            This method must only be called while the layouter is running
            <see cref="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Running" />
            .<p />
            There may occur synchronization issues, if
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            is not called
            using a CopiedLayoutGraph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.CommitPositionsSmoothly(System.Double,System.Double)">
      <summary>
            This method transfers the calculated positions (represented by the internal data structure of this layouter) to
            the LayoutGraph.<br />
            This method must only be called while the layouter is running
            <see cref="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Running" />
            .<p />
            The positions are not transferred directly.
            </summary>
      <param name="maxMovement">the maximal distance a node is moved</param>
      <param name="factor">determines the node movement (movement = factor * distance between calculated and actual location)</param>
      <returns>
            the biggest movement. This value can be used to estimate the difference between calculated layout
            and actual positions. If the return value is "0" the calculated layout has been transferred completely.
            </returns>
      <remarks>
            This method transfers the calculated positions (represented by the internal data structure of this layouter) to
            the LayoutGraph.<br />
            This method must only be called while the layouter is running
            <see cref="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Running" />
            .<p />
            The positions are not transferred directly. Instead the nodes are moved towards the calculated position in each step.
            "Good" values for this method may be about 50 for the maxMovement and about 0.15 as factor (when the
            positions are updates about 25 times a second).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates the layout for the graph.</summary>
      <param name="graph">the graph that is laid out</param>
      <remarks>
            Calculates the layout for the graph. The calculated layout is *NOT AUTOMATICALLY APPLIED*.
            The graph has to be updated with the actual calculated positions automatically.<p />
            Attention: It is recommended to use a CopiedLayoutGraph to buffer the original graph.
            If
            <see cref="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.AutomaticStructureUpdateEnabled" />
            is set to true, structural changes
            to the original graph are automatically transferred to the copy.<p />
            <pre>
            InteractiveOrganicLayouter layouter = new InteractiveOrganicLayouter();
            Graph2D originalGraph = new Graph2D();
            CopiedLayoutGraph copy = new CopiedLayoutGraph( originalGraph );
            layouter.setAutomaticStructureUpdateEnabled( true );
            layouter.doLayout( copy );
            </pre>
            <p />
            If an instance of CopiedLayoutGraph is laid out, the setters and getters having a node or edge
            as parameter may be used with instances from the original graph *or* the copied graph.
            <br />
            This call will not return until
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Stop" />
            is called.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.EnableOnlyCore">
      <summary>
            Makes sure that the core of this layouter will not use the usual
            <see cref="T:yWorks.yFiles.Layout.ILayoutStage" />
            s,
            like
            <see cref="T:yWorks.yFiles.Layout.ComponentLayouter" />
            ,
            <see cref="T:yWorks.yFiles.Layout.ParallelEdgeLayouter" />
            , etc.
            </summary>
      <remarks>
            Makes sure that the core of this layouter will not use the usual
            <see cref="T:yWorks.yFiles.Layout.ILayoutStage" />
            s,
            like
            <see cref="T:yWorks.yFiles.Layout.ComponentLayouter" />
            ,
            <see cref="T:yWorks.yFiles.Layout.ParallelEdgeLayouter" />
            , etc.
            If you really need this feature, override this method and return silently.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.GetCenter(yWorks.yFiles.Algorithms.Node)">
      <summary>Return the actual center of the node</summary>
      <param name="node" />
      <returns>the center of the node or null if the layouter does not know anything about the node.</returns>
      <remarks>Return the actual center of the node</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.GetCenterX(yWorks.yFiles.Algorithms.Node)">
      <summary>Return the actual center of the node.</summary>
      <param name="node" />
      <returns>the center of the node.</returns>
      <remarks>Return the actual center of the node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.GetCenterY(yWorks.yFiles.Algorithms.Node)">
      <summary>Return the actual center of the node.</summary>
      <param name="node" />
      <returns>the center of the node.</returns>
      <remarks>Return the actual center of the node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.GetStress(yWorks.yFiles.Algorithms.Node)">
      <summary>Gets the stress for the given node.</summary>
      <param name="node" />
      <remarks>
            Gets the stress for the given node.
            The higher the stress of a node is, the farther this node will be moved.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.LastWakeupTime">
      <summary>The time when the last wake-up has occurred</summary>
      <remarks>Returns the time when the last wake-up has occurred</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.MaxTime">
      <summary>The maximal time the layouter will run (in milliseconds).</summary>
      <remarks>
            Setter:<br />
            Sets the maximal time the layouter will run.
            After this time it will sleep - independent of the actual result.
            <para />
            Getter:<br />
            Return the maximal time the layouter will run (in milliseconds).
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.OutputRestriction">
      <summary>The current OutputRestriction instance set for this instance.</summary>
      <remarks>
            Setter:<br />
            Sets a restriction on the output generated by this layouter
            <para />
            Getter:<br />
            Returns the current OutputRestriction instance set for this instance.
            The default is
            <see cref="F:yWorks.yFiles.Layout.Organic.OutputRestriction.None" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.PreferredEdgeLength">
      <summary>The preferred edge length.</summary>
      <remarks>Sets the preferred edge length. The edges should not become smaller than this amount.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.PreferredNodeDistance">
      <summary>The preferred node distance.</summary>
      <remarks>Sets the preferred node distance.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Quality">
      <summary>The quality time ratio set.</summary>
      <remarks>
            Setter:<br />
            Sets the quality ratio (value between 0.0 and 1.0)
            The higher this value is, the better will be the quality for the resulting layout but also the needed time.
            <para />
            Getter:<br />
            The quality time ratio set.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Running">
      <summary>Specifies whether the layouter is running at the moment.</summary>
      <remarks>Returns whether the layouter is running at the moment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetCenter(yWorks.yFiles.Algorithms.Node,System.Double,System.Double)">
      <summary>Sets the center for the node.</summary>
      <param name="node" />
      <param name="x" />
      <param name="y" />
      <remarks>
            Sets the center for the node. This method does not affect the graph itself. Instead the internal
            data structure of the layouter is changed.
            This method may be used to update node positions due to user interaction (e.g. dragging).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetCenterX(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Sets the center of the node.</summary>
      <param name="node" />
      <param name="x" />
      <remarks>Sets the center of the node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetCenterY(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Sets the center of the node.</summary>
      <param name="node" />
      <param name="y" />
      <remarks>Sets the center of the node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetInertia(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Set the inertia for the node.</summary>
      <param name="node" />
      <param name="inertia" />
      <remarks>
            Set the inertia for the node.
            The inertia represents how "easy" a node will move.
            Inertia "1.0": The node will not move
            Inertia "0.5": The node will only move half as wide as it would with an inertia of "0.0"
            Inertia "0.0": The node will move as fast as possible
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetPreferredEdgeLength(yWorks.yFiles.Algorithms.Edge,System.Double)">
      <summary>Sets the preferred edge length for the given edge.</summary>
      <param name="edge" />
      <param name="newEdgeLength" />
      <remarks>Sets the preferred edge length for the given edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetRadius(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Sets the radius for the given node</summary>
      <param name="node" />
      <param name="radius" />
      <remarks>Sets the radius for the given node</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SetStress(yWorks.yFiles.Algorithms.Node,System.Double)">
      <summary>Sets the stress for the given node.</summary>
      <param name="node" />
      <param name="stress">a value between 0 and 1</param>
      <remarks>
            Sets the stress for the given node.
            The higher the stress of a node is, the farther this node will be moved.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Sleeping">
      <summary>Specifies whether the layouter is sleeping.</summary>
      <remarks>
            Returns whether the layouter is sleeping.
            A sleeping layouter can be awakened using
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.WakeUp" />
            and will continue its work.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.StartLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Calls
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            in a separate, newly started Thread.
            </summary>
      <param name="graph">
            the graph to pass on to
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" /></param>
      <returns>the Thread that has been created and started.</returns>
      <remarks>
            Calls
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            in a separate, newly started Thread.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.StartLayoutSingleThreaded(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Prepares the graph for layout and creates a context object that provides methods for
            <see cref="!:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.ISingleThreadContext.ContinueLayout(long)">continuing</see>
            and
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.ISingleThreadContext.StopLayout">stopping</see>
            the layout calculation.
            </summary>
      <param name="graph">the graph that gets layouted.</param>
      <returns>the context object to control layout calculation.</returns>
      <remarks>
            Prepares the graph for layout and creates a context object that provides methods for
            <see cref="!:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.ISingleThreadContext.ContinueLayout(long)">continuing</see>
            and
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.ISingleThreadContext.StopLayout">stopping</see>
            the layout calculation.
            Note that simply calling this method will not perform any layout. Repeated calls to
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.ISingleThreadContext.DoLayout(System.Int64)" />
            need to be made in order for the layout calculation to be performed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Stop">
      <summary>Stops the layouter.</summary>
      <remarks>
            Stops the layouter.
            The layouter will stop after the actual round. This means that the layouter cannot be awakened again.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.StopAndWait">
      <summary>
            Stops a previously
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.StartLayout(yWorks.yFiles.Layout.LayoutGraph)">started</see>
            layout
            Thread and blocks until the layout is completed.
            </summary>
      <remarks>
            Stops a previously
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.StartLayout(yWorks.yFiles.Layout.LayoutGraph)">started</see>
            layout
            Thread and blocks until the layout is completed.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.Stopped">
      <summary>Specifies whether the layouter has been stopped.</summary>
      <remarks>Returns whether the layouter has been stopped.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SyncStructure">
      <summary>
            This method synchronizes the CopiedLayoutGraph given as parameter to
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            with
            the original graph.
            </summary>
      <remarks>
            This method synchronizes the CopiedLayoutGraph given as parameter to
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            with
            the original graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.SyncStructure(System.Boolean)">
      <summary>
            This method synchronizes the CopiedLayoutGraph given as parameter to
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            with
            the original graph using a blocking call.
            </summary>
      <remarks>
            This method synchronizes the CopiedLayoutGraph given as parameter to
            <see cref="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            with
            the original graph, blocking the calling thread until the synchronization has been performed.
            This also wakes up the layouter to limit the blocking.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.WakeUp">
      <summary>This method may be called if something has "changed" and the layouter shall restart/continue layout calculation.</summary>
      <remarks>
            This method may be called if something has "changed" and the layouter shall restart/continue layout calculation.
            This is e.g. useful if the layouter is sleeping and some user interaction has occurred.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.WorkingRatio">
      <summary>The actual working ratio.</summary>
      <remarks>
            Getter:<br />
            Returns the actual working ratio. The working ratio is the planned ratio of working time to waiting time.
            <para />
            Setter:<br />
            Sets the working ratio. The working ratio represents the amount of processor time the layouter tries to
            grab.
            If the working ratio is set to 1 the layouter will try to run as fast as possible. Lower values will lead
            to small breaks after each round.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.ISingleThreadContext">
      <summary>Context object that provides controls of layout calculation in case the layouter runs single-threaded.</summary>
      <remarks>Context object that provides controls of layout calculation in case the layouter runs single-threaded.</remarks>
      <remarks>Context object that provides controls of layout calculation in case the layouter runs single-threaded.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.ISingleThreadContext.DoLayout(System.Int64)">
      <summary>Do layout calculation for the given amount of time where it has stopped before.</summary>
      <param name="duration">the duration of continuing layout calculation in milliseconds.</param>
      <remarks>Do layout calculation for the given amount of time where it has stopped before.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.InteractiveOrganicLayouter.ISingleThreadContext.StopLayout">
      <summary>Stops layout calculation.</summary>
      <remarks>Stops layout calculation. After this call, this context cannot continue layout calculation again.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.OrganicLayouter">
      <summary>A graph layout algorithm that is based on a force directed model.</summary>
      <remarks>
            A graph layout algorithm that is based on a force directed model.
            <p />
            Here is a sample output of the layouter:
            <p />
            <center><img src="doc-files/y.layout.organic.OrganicLayouter.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OrganicLayouter.#ctor">
      <summary>Returns a new organic Layouter.</summary>
      <remarks>Returns a new organic Layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.ActivateDeterministicMode">
      <summary>Specifies whether or not this layouter is in deterministic mode.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not this layouter should work in a deterministic mode.
            <br />
            In a deterministic mode this layouter produces the
            same layouts for the same input graph and layout parameters.
            <p>
            By default deterministic mode is inactive.
            </p>
            <para />
            Getter:<br />
            Returns whether or not this layouter is in deterministic mode.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.ActivateTreeBeautifier">
      <summary>Specifies whether or not to activate the subtree beautifier.</summary>
      <remarks>
            Specifies whether or not to activate the subtree beautifier.
            <br />
            Activating this feature lays out subtrees within the
            given graph structure in an optimized way.
            <p>
            By default this feature is inactive.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.Attraction">
      <summary>The current attraction.</summary>
      <remarks>Specifies the current attraction.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OrganicLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns always <see langword="true" /> because this algorithms has no
            preconditions.
            </summary>
      <returns>
        <see langword="true" />.</returns>
      <remarks>
            Returns always <see langword="true" /> because this algorithms has no
            preconditions.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OrganicLayouter.Dispose">
      <summary>Frees resources</summary>
      <remarks>Frees resources</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OrganicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Invokes the core layout algorithm.</summary>
      <remarks>Invokes the core layout algorithm.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.FinalTemperature">
      <summary>The final temperature.</summary>
      <remarks>
            Specifies the final temperature.
            This is an absolute temperature. If the average temperature falls
            under this value, the layout process comes to a halt.
            The default is <c>1.0d</c>.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.OrganicLayouter.FixedGroupNodesDpKey">
      <summary>DataProvider key used in conjunction with hierarchically grouped graphs.</summary>
      <remarks>
            DataProvider key used in conjunction with hierarchically grouped graphs.
            If this data provider key is registered with the LayoutGraph, then its associated
            data provider must return for each group node node in the input graph
            a boolean value indicating whether its contents/children should be treated
            as fixed or not.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.GravityFactor">
      <summary>The gravity factor.</summary>
      <remarks>
            Specifies the gravity factor. The magnitude of the gravity factor
            determines the strength of the force towards the barycenter of the graph.
            A high factor layout tends to cluster nodes
            around the barycenter of the graph. A low factor stretches the outskirts
            of the graph far away from the center.
            <p>
            By default a value of <c>0.0</c> is assumed.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.GroupBoundsCalculator">
      <summary>
            The GroupBoundsCalculator instance that is used for the
            calculation of the group nodes' bounds if a hierarchically grouped graph is
            being laid out.
            </summary>
      <remarks>
            Getter:<br />
            Returns the GroupBoundsCalculator instance that is used for the
            calculation of the group nodes' bounds if a hierarchically grouped graph is
            being laid out. By default a
            <see cref="T:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator" />
            instance
            is registered with this instance.
            <para />
            Setter:<br />
            Sets the instance used for the calculation of the group nodes' bounds
            if a hierarchically grouped graph is being laid out.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.GroupNodeCompactness">
      <summary>The group node compactness factor.</summary>
      <exception cref="T:System.ArgumentException">if compactness value does not lie in [0..1]</exception>
      <remarks>
            Getter:<br />
            Returns the group node compactness factor.
            <para />
            Setter:<br />
            Sets the compactness of group nodes. Values should be in the range [0..1],
            where 0 results in group nodes not affecting the overall layout too much, whereas
            a value of 1 forces nodes in the same group to be clustered tightly.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.GroupNodePolicy">
      <summary>The policy for group nodes.</summary>
      <remarks>
            Getter:<br />
            Returns the policy for group nodes. This policy controls the behavior
            of this layouter when acting on hierarchically grouped graphs.
            The default is
            <see cref="F:yWorks.yFiles.Layout.Organic.GroupsPolicy.Layout" />
            .
            <para />
            Setter:<br />
            Sets the policy for group nodes. This policy controls the behavior
            of this layouter when acting on hierarchically grouped graphs.
            This should be one of
            <see cref="F:yWorks.yFiles.Layout.Organic.GroupsPolicy.Fixed" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Organic.GroupsPolicy.Layout" />
            , or
            <see cref="F:yWorks.yFiles.Layout.Organic.GroupsPolicy.Ignore" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.InitialPlacement">
      <summary>The initial placement strategy.</summary>
      <remarks>
            Specifies the initial placement strategy.
            <p>
            The default value is
            <see cref="F:yWorks.yFiles.Layout.Organic.InitialPlacement.AsIs" />
            .
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.InitialTemperature">
      <summary>The initial temperature.</summary>
      <remarks>
            Specifies the initial temperature.
            The temperature will be multiplied with the <c>preferredEdgeLength</c>
            and then assigned as the initial node heat.
            <p>
            The default is <c>0.1d</c>.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.IterationFactor">
      <summary>The iteration factor of this layouter.</summary>
      <remarks>
            Specifies the iteration factor of this layouter.
            A higher iteration factor usually means better layout results and longer
            running times.
            <p>
            By default an iteration factor of <c>3</c> is set.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.MaximumDuration">
      <summary>The maximum duration granted to this layouter.</summary>
      <remarks>Specifies the maximum duration granted to this layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.ObeyNodeSize">
      <summary>Specifies whether or not node sizes should be considered by this layouter.</summary>
      <remarks>
            Specifies whether or not node sizes should be considered by this
            layouter.
            If you want to layout a diagram with big nodes in it you can reduce
            node overlaps by setting this feature to <see langword="true" />.
            <p>
            Defaults to <see langword="true" />.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.PreferredEdgeLength">
      <summary>
            The general edge length that should be attained by this
            layouter.
            </summary>
      <remarks>
            Specifies the general edge length that should be attained by this layouter.
            <p>
            By default an edge length of <c>80</c> is set.
            </p>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.OrganicLayouter.PreferredEdgeLengthDpKey">
      <summary>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            with a
            LayoutGraph.
            </summary>
      <remarks>
            Key used to associate a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            with a
            LayoutGraph. The associated DataProvider must return
            an <c>int</c> values for each edge of the LayoutGraph.
            The value returned for a specific edge will be interpreted as
            its preferred edge length.
            <p />
            If a DataProvider is bound to this key, then the global
            preferredEdgeLength for all edges (see
            <see cref="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.PreferredEdgeLength" />
            )
            will be ignored.
            <p />
            <b>Example:</b> Assuming that a method <c>int getWeight(Edge)</c>
            is provided that returns for each edge a double value between 0.0 and 1.0,
            then these edge weights can be translated to edge length preferences
            between 0 and 200 that the OrganicLayouter tries to obey.
            <pre>
            import y.util.DataProviderAdapter;
            //define an adequate data provider
            DataProviderAdapter edgeLengthData = new DataProviderAdapter() {
            public int getInt(Object o) {
            return (int)(200*getWeight((Edge)o));
            }
            }
            LayoutGraph graph = ...;
            OrganicLayouter layouter = ...;
            //register the data provider
            graph.addDataProvider(PREFERRED_EDGE_LENGTH_DATA, edgeLengthData);
            //launch the layouter
            layouter.doLayout(graph);
            </pre>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.Repulsion">
      <summary>The current repulsion.</summary>
      <remarks>Specifies the current repulsion.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.OrganicLayouter.SphereOfAction">
      <summary>The sphere of action for this layouter.</summary>
      <remarks>
            Specifies the sphere of action for this layouter.
            <p>
            The default value is
            <see cref="F:yWorks.yFiles.Layout.Organic.SphereOfAction.All" />
            .
            </p>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.OrganicLayouter.SphereOfActionNodesDpKey">
      <summary>DataProvider key used in conjunction with the sphere-of-action feature.</summary>
      <remarks>
            DataProvider key used in conjunction with the sphere-of-action feature. If this
            data provider key is being used, then it
            must return for each node in the input graph a boolean value indicating whether
            or not it should be handled by this layouter.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.OutputRestriction">
      <summary>Implementations of this class can be set via a <c>setOutputRestriction(OutputRestriction)</c> method, e.g.</summary>
      <remarks>
            Implementations of this class can be set via a <c>setOutputRestriction(OutputRestriction)</c> method, e.g.
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction" />
            in <c>SmartOrganicLayouter</c> to restrict the output area and shape of the layout.
            Instances of this class can only be retrieved from the factory methods or from the static field.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OutputRestriction.CreateAspectRatioRestriction(System.Double)">
      <summary>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter" />
            so
            that the bounding box roughly has the given aspect ratio.
            </summary>
      <param name="ratio">the preferred aspect ratio (width/height) of the output</param>
      <returns>
            an instance for use in
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction" /></returns>
      <remarks>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter" />
            so
            that the bounding box roughly has the given aspect ratio.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OutputRestriction.CreateCircularCageRestriction(System.Double,System.Double,System.Double)">
      <summary>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter" />
            so
            that the nodes lie within a circle.
            </summary>
      <param name="x">x coordinate of the center of the restriction circle</param>
      <param name="y">y coordinate of the center of the restriction circle</param>
      <param name="radius">the radius of the restriction circle</param>
      <returns>
            an instance for use in
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction" /></returns>
      <remarks>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter" />
            so
            that the nodes lie within a circle.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OutputRestriction.CreateEllipticalCageRestriction(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter" />
            so
            that the nodes lie within an ellipse whose main axes are parallel to the coordinate axes.
            </summary>
      <param name="x">x coordinate of the upper left corner</param>
      <param name="y">y coordinate of the upper left corner</param>
      <param name="w">width of the bounding box of the ellipse</param>
      <param name="h">the height of the bounding box of the ellipse</param>
      <returns>
            an instance for use in
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction" /></returns>
      <remarks>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter" />
            so
            that the nodes lie within an ellipse whose main axes are parallel to the coordinate axes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.OutputRestriction.CreateRectangularCageRestriction(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter" />
            so
            that the nodes lie within the given rectangle.
            </summary>
      <param name="x">x coordinate of the upper-left corner of the restriction rectangle</param>
      <param name="y">y coordinate of the upper-left corner of the restriction rectangle</param>
      <param name="w">width of the restriction rectangle</param>
      <param name="h">height of the restriction rectangle</param>
      <returns>
            an instance for use in
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction" /></returns>
      <remarks>
            This factory method creates a restriction object that can be used
            to restrict the result of a layout run of
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter" />
            so
            that the nodes lie within the given rectangle.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.OutputRestriction.None">
      <summary>This restriction actually does not restrict the output.</summary>
      <remarks>
            This restriction actually does not restrict the output. It is a no-op.
            It can be used in for use in
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction" />
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage">
      <summary>
            This LayoutStage removes node overlaps and guarantees a certain minimal
            node distance.
            </summary>
      <remarks>
            This LayoutStage removes node overlaps and guarantees a certain minimal
            node distance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.#ctor(System.Double)">
      <summary>Creates a new instance of RemoveOverlapsLayoutStage</summary>
      <remarks>Creates a new instance of RemoveOverlapsLayoutStage</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.#ctor(yWorks.yFiles.Algorithms.Util.YRandom,System.Double)">
      <summary>Creates a new instance of RemoveOverlapsLayoutStage</summary>
      <remarks>Creates a new instance of RemoveOverlapsLayoutStage</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.CoreLayouter">
      <summary>The core layouter.</summary>
      <remarks>Specifies the core layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
      <remarks>Assigns a new graph layout to the given layout graph.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.graph">
      <summary>the graph</summary>
      <remarks>the graph</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.h">
      <summary>heights based on node-indices</summary>
      <remarks>heights based on node-indices</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.nodes">
      <summary>the node array</summary>
      <remarks>the node array</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.random">
      <summary>the source of randomness</summary>
      <remarks>the source of randomness</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.UpdatePos">
      <summary>updates arrays x and y according to the current centers of the nodes</summary>
      <remarks>updates arrays x and y according to the current centers of the nodes</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.w">
      <summary>widths based on node-indices</summary>
      <remarks>widths based on node-indices</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.x">
      <summary>x coordinates based on node-indices</summary>
      <remarks>x coordinates based on node-indices</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.RemoveOverlapsLayoutStage.y">
      <summary>y coordinates based on node-indices</summary>
      <remarks>y coordinates based on node-indices</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.Scope" />
    <member name="F:yWorks.yFiles.Layout.Organic.Scope.All">
      <summary>Scope constant - used for laying out all nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.Scope.Subset">
      <summary>
            Scope constant - used for laying out the subset of nodes only.
            The above mentioned subset has to be specified by registering an
            appropriate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            for key
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSubsetDpKey" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.Scope.MainlySubset">
      <summary>
            Scope constant - used for laying out mainly the subset of the nodes.
            The above mentioned subset has to be specified by registering an
            appropriate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            for key
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSubsetDpKey" />
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.ShuffleLayouter">
      <summary>
            This layout stage removes node overlaps in a layout graph by using a method
            which is based on a famous russian arcade game.
            </summary>
      <remarks>
            This layout stage removes node overlaps in a layout graph by using a method
            which is based on a famous russian arcade game.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.ShuffleLayouter.#ctor">
      <summary>Creates a new instance of ShuffleLayouter.</summary>
      <remarks>Creates a new instance of ShuffleLayouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.ShuffleLayouter.BarycenterModeActive">
      <summary>
        <see langword="true" /> if this layouter uses a barycenter based
            node shuffling strategy and <see langword="false" /> otherwise.
            </summary>
      <remarks>
            Getter:<br />
            Returns <see langword="true" /> if this layouter uses a barycenter based
            node shuffling strategy and <see langword="false" /> otherwise.
            <para />
            Setter:<br />
            Specifies whether or not this layouter should use a barycenter based
            node shuffling strategy.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.ShuffleLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Organic.ShuffleLayouter.CoreLayouter">
      <summary>The core layouter.</summary>
      <remarks>Specifies the core layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.ShuffleLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Performs the force transfer algorithm on the given graph
            after the core layouter has performed its job.
            </summary>
      <remarks>
            Performs the force transfer algorithm on the given graph
            after the core layouter has performed its job.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.ShuffleLayouter.FixedNodeDpKey">
      <summary>
            This key can be used to specify a minimal distance for each single node in the graph
            using a data provider.
            </summary>
      <remarks>
            This key can be used to specify a minimal distance for each single node in the graph
            using a data provider. Note that values must be strictly positive.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.ShuffleLayouter.HorizontalOverlapCriterium">
      <summary>The horizontal overlap criterion.</summary>
      <remarks>
            Specifies the horizontal overlap criterion.
            One of
            <see cref="F:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion.IntersectionBox" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion.LessMovement" />
            and
            <see cref="F:yWorks.yFiles.Layout.Organic.HorizontalOverlapCriterion.NodeCenter" />
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.ShuffleLayouter.MinimalDistanceDpKey">
      <summary>
            This key can be used to specify a minimal distance for each single node in the graph
            using a data provider.
            </summary>
      <remarks>
            This key can be used to specify a minimal distance for each single node in the graph
            using a data provider. Note that values must be strictly positive.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.ShuffleLayouter.MinimalNodeDistance">
      <summary>
            The minimal distance between nodes that has to be obeyed by this
            layouter.
            </summary>
      <remarks>
            Specifies the minimal distance between nodes that has to be obeyed by this
            layouter.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.ShuffleLayouter.SimpleModeActive">
      <summary>Specifies whether or not simple mode is active.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to activate a simple layout mode.
            When in simple mode the algorithm is very fast
            but the quality of the resulting layout may be poor.
            When not active the resulting layout is better and
            the running time is higher.
            <p />
            By default simple mode is not active.
            <para />
            Getter:<br />
            Returns whether or not simple mode is active.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter">
      <summary>
            This class can be used as a convenience class to gain access to a variety of
            organic layout algorithms.
            </summary>
      <remarks>
            This class can be used as a convenience class to gain access to a variety of
            organic layout algorithms. Its strength lies in being able to conveniently
            specify a ratio between quality and running time, as well as the ability to
            specify the degree of the compactness of the drawing and
            to guarantee non-overlapping nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.#ctor">
      <summary>Creates a new SmartOrganicLayouter instance</summary>
      <remarks>Creates a new SmartOrganicLayouter instance</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.AutomaticGroupNodeCompactionEnabled">
      <summary>Specifies whether or not the automatic group node compaction is used.</summary>
      <remarks>
            Specifies whether or not to use the automatic group node compaction. If this option is enabled the group node compactness
            is determined automatically, i.e., it only depends on the general compactness specified by option
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.Compactness" />
            ). The value specified by option
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeCompactness" />
            is
            ignored.
            <p>
            By default this option is enabled.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.ClusteringQuality" />
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.ClusterNodes">
      <summary>Specifies whether or not a clustering algorithm should be applied.</summary>
      <remarks>
            Getter:<br />
            Returns whether or not a clustering algorithm should be applied.
            <p>
            By default, automatic clustering is not enabled.
            </p>
            <para />
            Setter:<br />
            Specifies whether or not a clustering algorithm should be applied to the input graph.
            If this option is enabled, the following steps are performed during the layout:
            <ol>
            <li>a clustering algorithm is applied to the input graph.</li>
            <li>all nodes of the same cluster are put into a new group node.</li>
            <li>the common layout is applied to the modified graph.</li>
            <li>group nodes denoting clusters (inserted during step 2) are removed.</li>
            </ol>
            The user can also specify customized clusters by defining appropriate groups.
            <p>
            By default, automatic clustering is not enabled.
            </p><p>
            Note: the runtime of the clustering algorithm does not depend on the specified maximal duration (see method
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.MaximumDuration" />
            ).
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.Compactness">
      <summary>The property for the compactness of the resulting layout.</summary>
      <exception cref="T:System.ArgumentException">
            if the specified value is less than
            <c>0</c> or greater than <c>1</c>.
            </exception>
      <remarks>
            Getter:<br />
            Returns the property for the compactness of the resulting layout.
            Lower values result in less compact drawings.
            <p>
            The default value is <c>0.5</c>.
            </p>
            <para />
            Setter:<br />
            Sets the compactness property for the next layout run.
            Smaller values result in less compact drawings, greater values result in more compact drawings
            with <c>0.5d</c> being a "normal" compactness.
            <p>
            The default value is <c>0.5</c>.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.ConfigureComponentLayouter(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.ComponentLayouter)">
      <summary>
            Configures the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">ComponentLayouter</see>
            and graph instance to adhere to the
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSubsetDpKey" />
            in case
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.All" />
            is not set, and to use
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.MinimalNodeDistance" />
            also for distances between components.
            </summary>
      <param name="graph">the graph that will be arranged</param>
      <param name="layouter">the layouter to reconfigure</param>
      <remarks>
            Configures the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">ComponentLayouter</see>
            and graph instance to adhere to the
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSubsetDpKey" />
            in case
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.All" />
            is not set, and to use
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.MinimalNodeDistance" />
            also for distances between components.
            This will result in the component layouter not rearranging components if they contain
            pinned-down nodes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.ConsiderNodeLabels">
      <summary>Specifies whether or not node labels are considered for the next layout run.</summary>
      <remarks>
            Getter:<br />
            Returns whether or not node labels are considered for the next layout run.
            <p>
            Default value is <see langword="false" />.
            </p>
            <para />
            Setter:<br />
            Specifies whether or not to consider node labels for the next layout run.
            Enabling this setting overrides the value of
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSizeAware" />
            , i.e.
            node sizes are always considered.
            <p>
            Default value is <see langword="false" />.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.Deterministic">
      <summary>Specifies whether the algorithm will behave deterministically in the next layout run.</summary>
      <remarks>
            Getter:<br />
            Returns whether the algorithm will behave deterministically in the next layout run.
            <para />
            Setter:<br />
            Sets this algorithm to deterministic mode. If set to <see langword="true" />, the algorithm will yield
            the same results if given the exact same input and same settings.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupBoundsCalculator">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Layout.Grouping.IGroupBoundsCalculator" />
            instance used for calculating the size of group nodes.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the
            <see cref="T:yWorks.yFiles.Layout.Grouping.IGroupBoundsCalculator" />
            instance used for calculating the size of group nodes.
            The default is
            <see cref="T:yWorks.yFiles.Layout.Grouping.MinimumSizeGroupBoundsCalculator" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeCompactness">
      <summary>The group node compactness factor.</summary>
      <exception cref="T:System.ArgumentException">if compactness value does not lie in [0..1]</exception>
      <remarks>
            Getter:<br />
            Returns the group node compactness factor.
            <br />
            Note: the specified value is only considered if option
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.AutomaticGroupNodeCompactionEnabled" />
            is disabled.
            <p>By default this value is <c>0.4</c>.</p>
            <para />
            Setter:<br />
            Sets the compactness of group nodes. Values should be in the range [0..1], where 0 results in group nodes not
            affecting the overall layout too much, whereas a value of 1 forces nodes in the same group to be clustered
            tightly.
            <br />
            Note: the specified value is only considered if option
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.AutomaticGroupNodeCompactionEnabled" />
            is disabled.
            <p>By default this value is <c>0.4</c>.</p>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeDpKey">
      <summary>The data provider key for specifying how to handle group nodes.</summary>
      <remarks>
            The data provider key for specifying how to handle group nodes.
            The algorithm expects for each node to find one of the following constants or
            <see langword="null" />:
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeNormal" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeFixBounds" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeFixContents" />
            </li>
            </ul>
            <see langword="null" /> will be treated like
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeNormal" />
            .
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeFixBounds">
      <summary>Group node mode constant that can be used to tag a group node.</summary>
      <remarks>
            Group node mode constant that can be used to tag a group node.
            Use the
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeDpKey" />
            DataProvider key to associate this constant
            with a group node to indicate that its bounds should be treated as fixed an
            its contents should never exceed those bounds.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeFixContents">
      <summary>Group node mode constant that can be used to tag a group node.</summary>
      <remarks>
            Group node mode constant that can be used to tag a group node.
            Use the
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeDpKey" />
            DataProvider key to associate this constant
            with a group node to indicate that it can be moved like an ordinary group node however its
            contents should remain fixed relative to the position of the group node.
            Note that this implicitly fixes all descendants of the group node.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeNormal">
      <summary>Group node mode constant that can be used to tag a group node.</summary>
      <remarks>
            Group node mode constant that can be used to tag a group node.
            Use the
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.GroupNodeModeDpKey" />
            DataProvider key to associate this constant
            with a group node to indicate that it should be treated like an ordinary group node.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.MaximumDuration">
      <summary>The maximum duration this algorithm is allowed to run.</summary>
      <exception cref="T:System.ArgumentException">
            if the specified duration is less than
            <c>0</c>.
            </exception>
      <remarks>
            Getter:<br />
            Returns the maximum duration this algorithm is allowed to run. This is a soft limit
            <p>
            By default, the maximum duration is set to 30 seconds.
            </p>
            <para />
            Setter:<br />
            Sets the soft limit for the maximum duration this algorithm is allowed to execute.
            <p>
            By default, the maximum duration is set to 30 seconds.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.MinimalNodeDistance">
      <summary>
            The current minimal node distance this algorithm should enforce if the
            node overlaps allowance property is set to <see langword="true" />.
            </summary>
      <remarks>
            Getter:<br />
            Returns the current minimal node distance this algorithm should enforce if the
            node overlaps allowance property is set to <see langword="true" />.
            <p>
            The default value is <c>0</c>.
            </p>
            <para />
            Setter:<br />
            Sets the minimal node distance this algorithm should enforce between all pairs of nodes
            for the next run.
            <p>
            The default value is <c>0</c>.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeEdgeOverlapAvoided">
      <summary>Specifies whether this algorithm is configured to try to avoid node/edge overlaps.</summary>
      <remarks>
            Getter:<br />
            Returns whether this algorithm is configured to try to avoid node/edge overlaps.
            <p>
            By default, this option is not enabled.
            </p>
            <para />
            Setter:<br />
            Specifies whether or not to try to avoid node/edge overlaps.
            The default is <see langword="false" />.
            Note that the current implementation does not guarantee the non-existence
            of overlaps but tries to avoid them.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeOverlapsAllowed" />
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSizeAware">
      <summary>Determines whether the algorithm should consider the size of the nodes for the layout.</summary>
      <remarks>
            Getter:<br />
            Determines whether the algorithm should consider the size of the nodes for the layout.
            If set to <see langword="true" /> the algorithm will take the node size into account
            for given preferred edge lengths.
            <para />
            Setter:<br />
            Specifies whether or not to consider node sizes for the next layout run.
            These settings do not affect the hard minimal node distance property.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSubsetDpKey">
      <summary>The data provider key for specifying the node subset to be laid out.</summary>
      <remarks>
            The data provider key for specifying the node subset to be laid out.
            The algorithm expects for each node in the graph to find a
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">boolean</see>
            that indicates whether the node belongs
            to the "sphere of action".
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.OutputRestriction">
      <summary>The current OutputRestriction instance set for this instance.</summary>
      <remarks>
            Setter:<br />
            Sets a restriction on the output generated by this layouter
            <para />
            Getter:<br />
            Returns the current OutputRestriction instance set for this instance.
            The default is
            <see cref="F:yWorks.yFiles.Layout.Organic.OutputRestriction.None" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.PreferredEdgeLength">
      <summary>The currently set default preferred edge length.</summary>
      <remarks>
            Getter:<br />
            Returns the currently set default preferred edge length. The algorithm will
            try to find a drawing where most of the edges have this length. This default
            is applied to all edges where there is no specific edge length given using the
            <c>double</c> DataProvider instance bound to the graph using the
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.PreferredEdgeLengthDpKey" />
            key.
            <para />
            Setter:<br />
            Sets the default preferred edge length for the next algorithm run.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.PreferredEdgeLengthDpKey">
      <summary>
            The data provider key for specifying the preferred edge lengths for each edge
            The algorithm expects to find
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetInt(System.Object)" />
            integer values associated with
            each edge.
            </summary>
      <remarks>
            The data provider key for specifying the preferred edge lengths for each edge
            The algorithm expects to find
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetInt(System.Object)" />
            integer values associated with
            each edge.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.PreferredMinimalNodeDistance">
      <summary>
            The current preferred minimal node distance this algorithm should use for
            pairs of nodes that are not directly connected by adjacent edges.
            </summary>
      <remarks>
            Getter:<br />
            Returns the current preferred minimal node distance this algorithm should use for
            pairs of nodes that are not directly connected by adjacent edges.
            <para />
            Setter:<br />
            Sets the minimal node distance this algorithm should try to obey for the next run.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.QualityTimeRatio">
      <summary>The quality to time ratio.</summary>
      <exception cref="T:System.ArgumentException">
            if the specified ratio is less than
            <c>0</c> or greater than <c>1</c>.
            </exception>
      <remarks>
            Getter:<br />
            Returns the quality to time ratio.
            This setting determines the ratio of layout quality versus time consumption.
            The higher the ratio, the better the quality of the resulting layout but
            the longer it may take to perform the layout.
            <p>
            The default value is <c>0.6</c>.
            </p>
            <para />
            Setter:<br />
            Specifies the quality to time ratio.
            This setting determines the ratio of layout quality versus time consumption.
            <p>
            The default value is <c>0.6</c>.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.Scope">
      <summary>The scope of the layout.</summary>
      <remarks>
            Getter:<br />
            Returns the scope of the layout.
            <para />
            Setter:<br />
            Sets the scope for the next layout run. The scope determines which of the nodes
            should be affected and how they should be affected by the layout run.
            <p>
            Defaults to
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.All" />
            .
            </p><p>
            <b>Note:</b>
            For all scopes but
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.All" />
            , a data provider for key
            <see cref="F:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.NodeSubsetDpKey" />
            <em>has</em> to be registered.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.SmartComponentLayout">
      <summary>
            Determines whether this instance should configure the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">ComponentLayouter</see>
            in such a way that it respects the
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.Scope">scope's</see>
            settings
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.Subset" />
            and
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.MainlySubset" />
            by keeping other nodes pinned, even if they reside in different components.
            </summary>
      <remarks>
            Determines whether this instance should configure the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">ComponentLayouter</see>
            in such a way that it respects the
            <see cref="P:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.Scope">scope's</see>
            settings
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.Subset" />
            and
            <see cref="F:yWorks.yFiles.Layout.Organic.Scope.MainlySubset" />
            by keeping other nodes pinned, even if they reside in different components.
            <p>
            The default is <see langword="false" />.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.UnconfigureComponentLayouter(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.ComponentLayouter)">
      <summary>
            Resets the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">ComponentLayouter</see>
            from the previous
            <see cref="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.ConfigureComponentLayouter(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.ComponentLayouter)" />
            call.
            </summary>
      <param name="graph">the graph that has been arranged</param>
      <param name="layouter">the layouter to reset.</param>
      <remarks>
            Resets the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter">ComponentLayouter</see>
            from the previous
            <see cref="M:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter.ConfigureComponentLayouter(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.ComponentLayouter)" />
            call.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.SphereOfAction">
      <summary>Sphere of action specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SphereOfAction.All">
      <summary>Sphere of action specifier. Displace all nodes.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SphereOfAction.MainlySelection">
      <summary>
            Sphere of action specifier. Displace mainly selected nodes, but allow
            minor movement of unselected nodes as well.
            A node is considered to be selected if the LayoutGraph DataProvider
            registered with the key
            <see cref="F:yWorks.yFiles.Layout.Organic.OrganicLayouter.SphereOfActionNodesDpKey" />
            returns <see langword="true" /> for that node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Organic.SphereOfAction.OnlySelection">
      <summary>
            Sphere of action specifier. Displace only selected nodes
            A node is considered to be selected if the LayoutGraph DataProvider
            registered with the key
            <see cref="F:yWorks.yFiles.Layout.Organic.OrganicLayouter.SphereOfActionNodesDpKey" />
            returns <see langword="true" /> for that node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage">
      <summary>
            This layout stage replaces edges by a path of nodes before it calls
            a core layouter.
            </summary>
      <remarks>
            This layout stage replaces edges by a path of nodes before it calls
            a core layouter. After the core layouter is finished this stage transforms
            the substituted path of nodes back to the original edge.  For each node in the path
            there will be a bend in the original edge. The coordinate of the bend will be the
            center coordinate of the corresponding path node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.#ctor">
      <summary>Creates a new instance of SplitEdgeLayouter</summary>
      <remarks>Creates a new instance of SplitEdgeLayouter</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true" /></summary>
      <remarks>Returns <see langword="true" /></remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.CoreLayouter">
      <summary>The core layouter.</summary>
      <remarks>Specifies the core layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph</summary>
      <remarks>Assigns a new graph layout to the given layout graph</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.ProxyNodeSize">
      <summary>The size used as width/height for proxy nodes, i.e.</summary>
      <remarks>Specifies the size which is used as width/height for proxy nodes, i.e. nodes inserted by this layout stage.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.SplitEdgesDpKey">
      <summary>
            The <c>DataProvider</c> key that determines which edges
            are to be split.
            </summary>
      <exception cref="T:System.ArgumentException">if the specified key is <see langword="null" />.</exception>
      <remarks>
            Specifies the <c>DataProvider</c> key that determines which edges
            are to be split.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedEdgesDpKey" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.SplitNodesDpKey">
      <summary>
            The <c>DataProvider</c> key to mark the nodes, that were
            created by splitting edges, for the core layouter.
            </summary>
      <exception cref="T:System.ArgumentException">if the specified key is <see langword="null" />.</exception>
      <remarks>
            Specifies the <c>DataProvider</c> key to mark the nodes, that were
            created by splitting edges, for the core layouter.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedNodesDpKey" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Organic.SplitEdgeLayoutStage.SplitSegmentLength">
      <summary>The split segment length.</summary>
      <remarks>
            Specifies the split segment length. The split segment length determines
            the length of the path that will replace an original edge in the graph.
            The length of the original edge path divided by the given split segment length
            yields the number of nodes on the new node path.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.CompactOrthogonalLayouter">
      <summary>
            This class is a variant of
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter" />
            that tries to arrange nodes in a more
            compact way, even allowing to specify a desired aspect ratio for the bounds of the
            calculated layout.
            </summary>
      <remarks>
            This class is a variant of
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter" />
            that tries to arrange nodes in a more
            compact way, even allowing to specify a desired aspect ratio for the bounds of the
            calculated layout. This is especially important if you want to print the layout
            on a paper with predefined size. As a disadvantage, this algorithm will usually produce
            less elegant edge routes than
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter" />
            does.
            <p>
            The algorithm is realized as a
            <see cref="T:yWorks.yFiles.Layout.PartitionLayouter" />
            , that uses
            <see cref="T:yWorks.yFiles.Layout.PartitionLayouter.EdgeBetweennessPartitionFinder" />
            to partition the graph,
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter" />
            to layout the graph partitions,
            <see cref="T:yWorks.yFiles.Layout.PartitionLayouter.ComponentPartitionPlacer" />
            to place the partitions, and finally
            <see cref="T:yWorks.yFiles.Layout.PartitionLayouter.ChannelInterEdgeRouter" />
            to route the edges between partitions.
            Each of these strategies can be individually configured and/or replaced.
            </p>
            <p>
            Here is a sample output of the layouter with aspect ratio of the resulting layout bounds set to <c>1</c>.
            </p>
            <p>
            <center><img src="doc-files/y.layout.orthogonal.CompactOrthogonalLayouter.gif" border="1" /></center>
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.CompactOrthogonalLayouter.#ctor">
      <summary>
            Create a new instance of this class with a default aspect ratio of 1 and a
            default grid spacing of 20.
            </summary>
      <remarks>
            Create a new instance of this class with a default aspect ratio of 1 and a
            default grid spacing of 20.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.CompactOrthogonalLayouter.AspectRatio">
      <summary>The desired aspect ratio of the resulting layout bounds.</summary>
      <remarks>
            Getter:<br />
            Returns the desired aspect ratio of the resulting layout bounds.
            <para />
            Setter:<br />
            Sets the desired aspect ratio (i.e. the quotient width/height) of the
            resulting layout bounds. By default a value of <c>1</c> is set.
            This setting will only have an effect if the set
            <see cref="T:yWorks.yFiles.Layout.PartitionLayouter.IPartitionPlacer" />
            is of the pre-configured type
            <see cref="T:yWorks.yFiles.Layout.PartitionLayouter.ComponentPartitionPlacer" />
            .
            <br />
            <b>Note</b>: When setting configurable stages <em>after</em> specifying
            aspect ratio, it is assumed that the aforementioned stages are already
            properly configured and the previously set aspect ratio will not be passed
            to these stages.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.CompactOrthogonalLayouter.GridSpacing">
      <summary>The grid spacing used to place the nodes.</summary>
      <remarks>
            Getter:<br />
            Returns the grid spacing used to place the nodes.
            <para />
            Setter:<br />
            Sets the grid spacing to be used. By default, a value of <c>20</c> is set.
            Setting the grid spacing will only have an effect if the configurable stages
            have not been replaced by other implementations.
            <br />
            <b>Note</b>: When setting configurable stages <em>after</em> specifying
            grid spacing, it is assumed that the aforementioned stages are already
            properly configured and the previously set grid spacing will not be passed
            to these stages.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter">
      <summary>
            This class is a variant of
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter" />
            that can route edges in a way that
            they point to a main layout direction.
            </summary>
      <remarks>
            This class is a variant of
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter" />
            that can route edges in a way that
            they point to a main layout direction. Also, this class can route edges that connect to the same
            node in a shared bus-structure. A typical use case for this layout algorithm are UML class diagrams
            that contain some relationships like generalization or realization which are best expressed by
            upward-pointing edges.
            <p />
            Directed edges are marked by a boolean data provider that is registered with the key
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.DirectedEdgeDpKey" />
            to the input graph. Edge groups at a common node can be specified
            by registering data providers with the keys
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
            .
            <p />
            Like
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter" />
            this layout algorithm can consider edge label data when
            laying out a graph. That means that the layout of edge labels will be part of the resulting
            layout and the layout of nodes and edges is chosen in such a way that the
            edge labels do not conflict with the rest of the layout.
            See classes
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData" />
            ,
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutKeys" />
            , and
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            on how
            to setup the integrated edge label layout feature.
            <p />
            Here is an sample output of the layout algorithm. Note that all edges painted in blue
            are marked as directed edges. Also, the directed edges at each node have been put into the
            same edge group.
            <p />
            <center><img src="doc-files/y.layout.orthogonal.DirectedOrthogonalLayouter.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.#ctor">
      <summary>Creates a new instance of this class.</summary>
      <remarks>Creates a new instance of this class.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
      <returns>
        <see langword="true" /> for all graphs.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.ConsiderNodeLabels">
      <summary>
            Specifies whether or not node labels are taken into account when calculating node positions (thereby preventing
            possible node/node label or node label/node label overlaps).
            </summary>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            .
            </exception>
      <remarks>
            Setter:<br />
            Specifies whether or not to consider node labels when calculating node positions (thereby preventing possible
            node/node label or node label/node label overlaps). This method is a convenience method that assures that the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels" />
            is set to
            <see langword="true" />.
            Note that setting this option may overwrite the currently set label layouter. Hence, to combine this option with
            a generic edge labeling algorithm, the generic labeling has to be applied in an additional step after calculating the layout.
            <para />
            Getter:<br />
            Returns whether or not node labels are taken into account when calculating node positions (thereby preventing
            possible node/node label or node label/node label overlaps). This method is a convenience method checks whether the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels" />
            returns <see langword="true" />.
            <br /> The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.CreateEdgeLayoutDescriptor">
      <summary>Factory method that creates the default EdgeLayoutDescriptor.</summary>
      <returns>a new EdgeLayoutDescriptor (<c>new EdgeLayoutDescriptor()</c>)</returns>
      <remarks>
            Factory method that creates the default EdgeLayoutDescriptor.
            May not return <see langword="null" />!
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.DirectedEdgeDpKey">
      <summary>
            DataProvider key that is used to mark edges that should be routed in a way that
            point in the main layout direction.
            </summary>
      <remarks>
            DataProvider key that is used to mark edges that should be routed in a way that
            point in the main layout direction. The main layout direction can be set
            by using method
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LayoutOrientation" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.EdgeLayoutDescriptor">
      <summary>
            The <c>EdgeLayoutDescriptor</c> instance used for all those
            edges, that do not have a specific layout descriptor assigned.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the <c>EdgeLayoutDescriptor</c> instance used for all those
            edges, that do not have a specific layout descriptor assigned.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.EdgeLayoutDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor" />
            instances for each edge in the graph.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor" />
            instances for each edge in the graph. Different settings will affect the routing of the edges during the layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.Grid">
      <summary>The currently set grid spacing.</summary>
      <remarks>
            Getter:<br />
            Returns the currently set grid spacing.
            <para />
            Setter:<br />
            Sets the grid spacing to be used. By default a value of <c>20</c> is set.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.IntegratedEdgeLabeling">
      <summary>Specifies whether integrated edge labeling is enabled.</summary>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            .
            </exception>
      <remarks>
            Setter:<br />
            Specifies whether or not to use integrated edge labeling. This method is a convenience method that assures that the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels" />
            is set to
            <see langword="true" />
            <para />
            Getter:<br />
            Returns whether integrated edge labeling is enabled. This method is a convenience method that checks if the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels" />
            returns <see langword="true" />. <br /> The default is
            <see langword="false" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.UsePostprocessing">
      <summary>If an additional postprocessing step is used that improves compactness and reduces the number of edge bends.</summary>
      <remarks>
            Specifies if an additional postprocessing step is used that improves compactness and reduces the number of edge bends.
            The postprocessing is enabled by default.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter.UseSketchDrawing">
      <summary>If the existing drawing should be used as sketch.</summary>
      <remarks>Specifies if the existing drawing should be used as sketch.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor">
      <summary>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter" />
            ,
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter" />
            and
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter" />
            to determine the routing details of the graph's edges.
            </summary>
      <remarks>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter" />
            ,
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.DirectedOrthogonalLayouter" />
            and
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter" />
            to determine the routing details of the graph's edges.
            <br />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor.#ctor">
      <summary>
            Creates a new instance of an EdgeLayoutDescriptor using the
            default values.
            </summary>
      <remarks>
            Creates a new instance of an EdgeLayoutDescriptor using the
            default values.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor.CreateCopy">
      <summary>Creates a copy of this instance.</summary>
      <returns>the copy.</returns>
      <remarks>Creates a copy of this instance.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor.MinimumFirstSegmentLength">
      <summary>The minimum length of the first segment (at the source).</summary>
      <remarks>
            Setter:<br />
            Sets the minimum length of the first segment (at the source).
            Note: the resulting segment length also depends on the given grid size
            (see
            <see cref="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.Grid" />
            ),
            i.e., segment length &gt;= (int) Math.ceil(length / grid size).
            <para />
            Getter:<br />
            Returns the minimum length of the first segment (at the source).
            Default is <c>15.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor.MinimumLastSegmentLength">
      <summary>The minimum length of the last segment (at the target).</summary>
      <remarks>
            Setter:<br />
            Sets the minimum length of the last segment (at the target).
            Note: the resulting segment length also depends on the given grid size
            (see
            <see cref="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.Grid" />
            ),
            i.e., segment length &gt;= (int) Math.ceil(length / grid size).
            <para />
            Getter:<br />
            Returns the minimum length of the last segment (at the target).
            Default is <c>15.0d</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor.MinimumSegmentLength">
      <summary>The minimum segment length of the edge.</summary>
      <remarks>
            Setter:<br />
            Sets the minimum segment length of an edge.
            Note: the resulting segment length also depends on the given grid size
            (see
            <see cref="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.Grid" />
            ),
            i.e., segment length &gt;= (int) Math.ceil(length / grid size).
            <para />
            Getter:<br />
            Returns the minimum segment length of the edge.
            Default is <c>15.0d</c>.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.LayoutStyle">
      <summary>Layout style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Normal">
      <summary>
            Layout style specifier. In this layout style the size of the nodes will not
            be changed by the algorithm. All edges will be routed orthogonally.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Uniform">
      <summary>
            Layout style specifier. In this layout style a uniform size will be assigned to all
            nodes. All edges will be routed orthogonally.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Box">
      <summary>
            Layout style specifier. In this layout style the size of the original nodes will
            be enlarged in order to save some bends.
            All edges will be routed orthogonally.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Mixed">
      <summary>
            Layout style specifier. In this layout style not all edges will be routed orthogonally.
            Edge segments that directly connect to a node may be routed non-vertically and
            non-horizontally.
            A small uniform size will be assigned to all nodes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.NormalTree">
      <summary>
            Layout style specifier. Like
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Normal" />
            but all directed subtree structures
            of the graph will be laid out in an optimized way.  All edges will be routed orthogonally.
            The tree edges will be routed in a bus-like fashion.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.FixedMixed">
      <summary>
            Layout style specifier. In this layout style not all edges will be routed orthogonally.
            Edge segments that directly connect to a node may be routed non-vertically and
            non-horizontally.
            The size of nodes will not be altered.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.FixedBox">
      <summary>
            Layout style specifier. Nodes will be placed
            at the same location as with
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.FixedMixed" />
            but edges will be routed strictly orthogonally.
            The size of nodes will not be altered.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter">
      <summary>
            This class provides a layout algorithm which produces
            orthogonal drawings of hierarchically grouped graphs.
            </summary>
      <remarks>
            This class provides a layout algorithm which produces
            orthogonal drawings of hierarchically grouped graphs.
            <p />
            Here is a sample output of the layouter.
            <p />
            <center><img border="0" src="doc-files/y.layout.orthogonal.OrthogonalGroupLayouter.gif" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.#ctor">
      <summary>Creates a new instance of OrthogonalGroupLayouter</summary>
      <remarks>Creates a new instance of OrthogonalGroupLayouter</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.ComponentLayouter">
      <summary>
            Note that the component layouter set here should work in such a way that
            isolated components inside groups should be reported separately.
            </summary>
      <remarks>
            Note that the component layouter set here should work in such a way that
            isolated components inside groups should be reported separately.
            E.g. instances of
            <see cref="T:yWorks.yFiles.Layout.Grouping.IsolatedGroupComponentLayouter" />
            can be set here.
            If the component layouter should be customized, the suggested way of doing this is to
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.ComponentLayouter" />
            and cast it to
            <see cref="T:yWorks.yFiles.Layout.ComponentLayouter" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.ConsiderNodeLabels">
      <summary>
            Specifies whether or not node labels are taken into account when calculating node positions (thereby preventing
            possible node/node label or node label/node label overlaps).
            </summary>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            .
            </exception>
      <remarks>
            Setter:<br />
            Specifies whether or not to consider node labels when calculating node positions (thereby preventing possible
            node/node label or node label/node label overlaps). This method is a convenience method that assures that the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels" />
            is set to
            <see langword="true" />.
            Note that setting this option may overwrite the currently set label layouter. Hence, to combine this option with
            a generic edge labeling algorithm, the generic labeling has to be applied in an additional step after calculating the layout.
            <para />
            Getter:<br />
            Returns whether or not node labels are taken into account when calculating node positions (thereby preventing
            possible node/node label or node label/node label overlaps). This method is a convenience method checks whether the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels" />
            returns <see langword="true" />.
            <br /> The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.CreateEdgeLayoutDescriptor">
      <summary>Factory method that creates the default EdgeLayoutDescriptor.</summary>
      <returns>a new EdgeLayoutDescriptor (<c>new EdgeLayoutDescriptor()</c>)</returns>
      <remarks>
            Factory method that creates the default EdgeLayoutDescriptor.
            May not return <see langword="null" />!
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a layout for the given graph.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.EdgeLayoutDescriptor">
      <summary>
            The <c>EdgeLayoutDescriptor</c> instance used for all those
            edges, that do not have a specific layout descriptor assigned.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the <c>EdgeLayoutDescriptor</c> instance used for all those
            edges, that do not have a specific layout descriptor assigned.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.EdgeLayoutDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor" />
            instances for each edge in the graph.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor" />
            instances for each edge in the graph. Different settings will affect the routing of the edges during the layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.Grid">
      <summary>The grid distance.</summary>
      <remarks>Specifies the grid distance.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.IntegratedEdgeLabeling">
      <summary>Specifies whether integrated edge labeling is enabled.</summary>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            .
            </exception>
      <remarks>
            Setter:<br />
            Specifies whether or not to use integrated edge labeling. This method is a convenience method that assures that the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels" />
            is set to
            <see langword="true" />
            <para />
            Getter:<br />
            Returns whether integrated edge labeling is enabled. This method is a convenience method that checks if the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels" />
            returns <see langword="true" />. <br /> The default is
            <see langword="false" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.LayoutQuality">
      <summary>The currently set layout quality.</summary>
      <remarks>
            Setter:<br />
            Sets the desired layout quality. Higher quality means less connection
            crossings and smaller layout area, but also increased computation time.
            <p />By default best layout quality (value <c>1</c>) is set.
            <para />
            Getter:<br />
            Returns the currently set layout quality.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalGroupLayouter.PostprocessingEnabled">
      <summary>Determines if an additional postprocessing step is used that improves compactness and reduces the number of edge bends.</summary>
      <remarks>
            Specifies if an additional postprocessing step is used that improves compactness and reduces the number of edge bends.
            The postprocessing is enabled by default.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter">
      <summary>
            This class provides a layout algorithm which produces
            orthogonal drawings.
            </summary>
      <remarks>
            This class provides a layout algorithm which produces
            orthogonal drawings.
            <p />
            OrthogonalLayouter can consider edge label data when laying out a graph.
            That means that the the layout of edge labels will be part of the resulting
            layout and the layout of nodes and edges is chosen in such a way that the
            edge labels do not conflict with the rest of the layout.
            See classes
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutData" />
            ,
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutKeys" />
            , and
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            on how
            to setup the integrated edge label layout feature.
            <p />
            Here is an sample output of the layouter using the layout style
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Normal" />
            .
            <p />
            <center><img src="doc-files/y.layout.orthogonal.OrthogonalLayouter.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.#ctor">
      <summary>Returns a new instance.</summary>
      <remarks>Returns a new instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns always <see langword="true" />.</summary>
      <remarks>Returns always <see langword="true" />.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.ConsiderNodeLabels">
      <summary>
            Specifies whether or not node labels are taken into account when calculating node positions (thereby preventing
            possible node/node label or node label/node label overlaps).
            </summary>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            .
            </exception>
      <remarks>
            Setter:<br />
            Specifies whether or not to consider node labels when calculating node positions (thereby preventing possible
            node/node label or node label/node label overlaps). This method is a convenience method that assures that the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter" />
            label layouter is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels" />
            is set to
            <see langword="true" />.
            Note that setting this option may overwrite the currently set label layouter. Hence, to combine this option with
            a generic edge labeling algorithm, the generic labeling has to be applied in an additional step after calculating the layout.
            Furthermore, node labels can only be considered if the layout style is set to
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Normal" />
            .
            <para />
            Getter:<br />
            Returns whether or not node labels are taken into account when calculating node positions (thereby preventing
            possible node/node label or node label/node label overlaps). This method is a convenience method checks whether the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateNodeLabels" />
            returns <see langword="true" />.
            <br /> The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.CreateEdgeLayoutDescriptor">
      <summary>Factory method that creates the default EdgeLayoutDescriptor.</summary>
      <returns>a new EdgeLayoutDescriptor (<c>new EdgeLayoutDescriptor()</c>)</returns>
      <remarks>
            Factory method that creates the default EdgeLayoutDescriptor.
            May not return <see langword="null" />!
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns an orthogonal graph layout to the given layout graph.</summary>
      <remarks>Assigns an orthogonal graph layout to the given layout graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.EdgeLayoutDescriptor">
      <summary>
            The <c>EdgeLayoutDescriptor</c> instance used for all those
            edges, that do not have a specific layout descriptor assigned.
            </summary>
      <exception cref="T:System.ArgumentNullException">if the argument is <see langword="null" /></exception>
      <remarks>
            Specifies the <c>EdgeLayoutDescriptor</c> instance used for all those
            edges, that do not have a specific layout descriptor assigned.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.EdgeLayoutDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor" />
            instances for each edge in the graph.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to retrieve
            <see cref="T:yWorks.yFiles.Layout.Orthogonal.EdgeLayoutDescriptor" />
            instances for each edge in the graph. Different settings will affect the routing of the edges during the layout.
            Note: minimum edge length constraints are only considered for layout style
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Normal" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.NormalTree" />
            and
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Uniform" />
            (see
            <see cref="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.LayoutStyle" />
            ).
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.Grid">
      <summary>
            The size of the grid on which the nodes and edges are placed.<br />
            Default is 20.
            </summary>
      <remarks>
            Specifies the size of the grid on which the nodes and edges are placed.<br />
            Default is 20.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.IntegratedEdgeLabeling">
      <summary>Specifies whether integrated edge labeling is enabled.</summary>
      <exception cref="T:System.InvalidOperationException">
            if the current label layouter is not of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            .
            </exception>
      <remarks>
            Setter:<br />
            Specifies whether or not to use integrated edge labeling. This method is a convenience method that assures that the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels" />
            is set to
            <see langword="true" />
            <br />
            Note: edge labels can only be considered if the layout style is set to
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Normal" />
            .
            <para />
            Getter:<br />
            Returns whether integrated edge labeling is enabled. This method is a convenience method that checks if the
            <see cref="P:yWorks.yFiles.Layout.CanonicMultiStageLayouter.LabelLayouter">label layouter</see>
            is of type
            <see cref="T:yWorks.yFiles.Layout.LabelLayoutTranslator" />
            and
            <see cref="P:yWorks.yFiles.Layout.LabelLayoutTranslator.TranslateEdgeLabels" />
            returns <see langword="true" />. <br /> The default is
            <see langword="false" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.LayoutStyle">
      <summary>The layout style of this layouter.</summary>
      <remarks>
            Setter:<br />
            Sets the layout style for this layouter.
            By default the layout style
            <see cref="F:yWorks.yFiles.Layout.Orthogonal.LayoutStyle.Normal" />
            is set.
            <para />
            Getter:<br />
            Returns the layout style of this layouter.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.NodeModel" />
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.OptimizePerceivedBends">
      <summary>
            Specifies whether the algorithm should perform a post processing algorithm
            to reduce perceived bends in the drawing.
            </summary>
      <remarks>
            Specifies whether the algorithm should perform a post processing algorithm
            to reduce perceived bends in the drawing.
            The default is <see langword="true" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseCrossingPostprocessing">
      <summary>If post-processing is used to reduce the number of crossings.</summary>
      <remarks>
            Setter:<br />
            Sets if post-processing is used to reduce the number of crossings.
            This post-processing may decrease the number of crossings significantly
            but it may slows down the algorithm, too.<br />
            Default is <see langword="true" />.
            <para />
            Getter:<br />
            Returns if post-processing is used to reduce the number of crossings.
            Default is <see langword="true" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseFaceMaximization">
      <summary>If the layouter should try to maximize one face of the embedding.</summary>
      <remarks>
            Specifies if the layouter should try to maximize one face of the embedding.
            Default is <see langword="false" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseLengthReduction">
      <summary>If the algorithm optimizes over the length of the edges.</summary>
      <remarks>
            Specifies if the algorithm optimizes over the length of the edges.
            This may decrease the length of some edges significantly
            but it slows the algorithm down.<br />
            Default is <see langword="true" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseRandomization">
      <summary>If a randomization strategy is used.</summary>
      <remarks>
            Setter:<br />
            Sets if a randomization strategy is used.
            The randomization usually improves the result but it may be disabled to
            get a deterministic behavior of the algorithm.<br />
            Default is <see langword="true" />.
            <para />
            Getter:<br />
            Returns if a randomization strategy is used.
            Default is <see langword="true" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseSketchDrawing">
      <summary>If the existing drawing should be used as sketch.</summary>
      <remarks>Specifies if the existing drawing should be used as sketch.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Orthogonal.OrthogonalLayouter.UseSpacePostprocessing">
      <summary>If post-processing is used to reduce the space used by the drawing.</summary>
      <remarks>
            Setter:<br />
            Sets if post-processing is used to reduce the space used by the drawing.
            This post-processing may decrease space significantly
            but it slows the algorithm down.<br />
            Default is <see langword="true" />.
            <para />
            Getter:<br />
            Returns if post-processing is used to reduce the space used by the drawing.
            Default is <see langword="true" />.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Partial.ComponentAssignmentStrategy">
      <summary>Specifier for the strategy that is used to assign partial nodes to subgraph components.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.ComponentAssignmentStrategy.Single">
      <summary>
            Specifier for the strategy that is used to assign partial nodes to subgraph components. This value specifies that
            each partial node is assigned to a separate component.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.ComponentAssignmentStrategy.Connected">
      <summary>
            Specifier for the strategy that is used to assign partial nodes to subgraph components. This value specifies that
            all partial nodes of a connected component are assigned to the same subgraph component.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.ComponentAssignmentStrategy.Clustering">
      <summary>
            Specifier for the strategy that is used to assign partial nodes to subgraph components. This value specifies that
            the algorithm should use a natural clustering algorithm to determine the subgraph components (nodes of the same
            cluster are in the same subgraph component).
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.ComponentAssignmentStrategy.Customized">
      <summary>
            Specifier for the strategy that is used to assign partial nodes to subgraph components. This value allows to use a
            customized component assignment, see
            <see cref="F:yWorks.yFiles.Layout.Partial.PartialLayouter.ComponentAssignmentDpKey" />
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Partial.EdgeRoutingStrategy">
      <summary>
            Specifier for the routing strategy of inter-edges (edges between fixed and partial nodes as well as edges between
            different subgraph components).
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.EdgeRoutingStrategy.Orthogonal">
      <summary>
            Specifier for the routing strategy of inter-edges (edges between fixed and partial nodes as well as edges between
            different subgraph components). The algorithm will use orthogonal routes for inter-edges, i.e., each edge only
            consists of vertical and horizontal segments.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.EdgeRoutingStrategy.Straightline">
      <summary>
            Specifier for the routing strategy of inter-edges (edges between fixed and partial nodes as well as edges between
            different subgraph components). The algorithm will use straight-line routes for inter-edges.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.EdgeRoutingStrategy.Automatic">
      <summary>
            Specifier for the routing strategy of inter-edges (edges between fixed and partial nodes as well as edges between
            different subgraph components). The algorithm automatically chooses a suitable routing strategy.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.EdgeRoutingStrategy.Organic">
      <summary>
            Specifier for the routing strategy of inter-edges (edges between fixed and partial nodes as well as edges between
            different subgraph components). The algorithm will use organic routes for inter-edges.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Partial.LayoutOrientation">
      <summary>Specifies the orientation of the drawing.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.LayoutOrientation.TopToBottom">
      <summary>
            Specifies the orientation of the drawing. This value specifies that the algorithm should try to place partial nodes
            (subgraph components) such that each predecessor of a node v is placed above v and each successor below v.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.LayoutOrientation.BottomToTop">
      <summary>
            Specifies the orientation of the drawing. This value specifies that the algorithm should try to place partial nodes
            (subgraph components) such that each predecessor of a node v is placed below v and each successor above v.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.LayoutOrientation.LeftToRight">
      <summary>
            Specifies the orientation of the drawing. This value specifies that the algorithm should try to place partial nodes
            (subgraph components) such that each predecessor of a node v is placed to the left of v and each successor to the
            right of v.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.LayoutOrientation.RightToLeft">
      <summary>
            Specifies the orientation of the drawing. This value specifies that the algorithm should try to place partial nodes
            (subgraph components) such that each predecessor of a node v is placed to the right of v and each successor to the
            left of v.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.LayoutOrientation.AutoDetect">
      <summary>
            Specifies the orientation of the drawing. This value specifies that the layout algorithm should detect the
            orientation automatically. Therefore it analysis the current drawing.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.LayoutOrientation.None">
      <summary>Specifies the orientation of the drawing.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Partial.PartialLayouter">
      <summary>This class represents a partial layouter.</summary>
      <remarks>
            This class represents a partial layouter. A partial layouter is a layout algorithm that changes the coordinates for a
            given set of graph elements (called partial elements). The location or size of the remaining elements (called fixed
            elements) is not allowed to be changed. The layout algorithm tries to place the partial elements such that the
            resulting drawing (including the fixed elements) has a good quality with respect to common graph drawing aesthetics.
            <p>This layouter can be applied to plain graphs as well as to grouped graphs.
            Note: when a partial node should be placed inside a fixed group node,
            it is important that there is enough free space inside the group. Otherwise, there may be overlapping node elements.</p>
            <p>The layouter handles each selected graph element as partial element. Therefore it looks up the data provider keys
            <see cref="F:yWorks.yFiles.Layout.Partial.PartialLayouter.PartialNodesDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.Partial.PartialLayouter.PartialEdgesDpKey" />
            . Partial node elements can be
            assigned to so called subgraph components. During the layout process each subgraph induced by the nodes of a
            component is first laid out using the specified core layouter
            <see cref="P:yWorks.yFiles.Layout.Partial.PartialLayouter.CoreLayouter" />
            . Then, the
            different components are placed one-by-one onto the drawing area such that the number of overlaps among graph
            elements is small. The user can specify different objectives for finding 'good' positions for subgraph components
            (
            <see cref="P:yWorks.yFiles.Layout.Partial.PartialLayouter.PositioningStrategy" />
            ), e.g.,
            <see cref="F:yWorks.yFiles.Layout.Partial.SubgraphPositioningStrategy.Barycenter" />
            specifies that the
            component should be placed close to the barycenter of its graph neighbors and
            <see cref="F:yWorks.yFiles.Layout.Partial.SubgraphPositioningStrategy.FromSketch" />
            specifies that the component should be placed close to its original
            position. </p>
            <p> Method
            <see cref="P:yWorks.yFiles.Layout.Partial.PartialLayouter.ComponentAssignmentStrategy" />
            allows to specify the strategy that is used
            to assign partial nodes to subgraph components. Possible values are
            <see cref="F:yWorks.yFiles.Layout.Partial.ComponentAssignmentStrategy.Clustering" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Partial.ComponentAssignmentStrategy.Connected" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Partial.ComponentAssignmentStrategy.Single" />
            and
            <see cref="F:yWorks.yFiles.Layout.Partial.ComponentAssignmentStrategy.Customized" />
            . The last value allows to use a customized component assignment. Note:
            nodes of a component cannot be assigned to different group nodes. </p>
            <p> Furthermore, the user can specify the edge
            routing strategy (method
            <see cref="P:yWorks.yFiles.Layout.Partial.PartialLayouter.EdgeRoutingStrategy" />
            ) that is used for routing partial edges and edges
            between different subgraph components (so-called inter-edges). Possible values are
            <see cref="F:yWorks.yFiles.Layout.Partial.EdgeRoutingStrategy.Organic" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Partial.EdgeRoutingStrategy.Orthogonal" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Partial.EdgeRoutingStrategy.Straightline" />
            and
            <see cref="F:yWorks.yFiles.Layout.Partial.EdgeRoutingStrategy.Automatic" />
            . </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.#ctor">
      <summary>Creates a new instance of the PartialLayouter.</summary>
      <remarks>Creates a new instance of the PartialLayouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of the PartialLayouter.</summary>
      <param name="subgraphLayouter">the layout algorithm that is applied to the subgraph components.</param>
      <remarks>
            Creates a new instance of the PartialLayouter. The parameter specifies the layout algorithm that is used for the
            subgraph components.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.AllowMirroring">
      <summary>
            Specifies whether or not subgraph components may be mirrored to improve the layout quality, i.e., for each component
            the algorithm checks which of the four possible mirrorings minimizes the edge length.
            </summary>
      <remarks>
            Specifies whether or not subgraph components may be mirrored to improve the layout quality, i.e., for each component
            the algorithm checks which of the four possible mirrorings minimizes the edge length.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="F:yWorks.yFiles.Layout.Partial.PartialLayouter.ComponentAssignmentDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store an object for each partial node of the graph.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store an object for each partial node of the graph. All partial nodes
            associated with the same object are assigned to the same subgraph component. Note: nodes of a component cannot be
            assigned to different group nodes as well as different partition cells.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.ComponentAssignmentStrategy">
      <summary>The strategy that is used to assign partial nodes to subgraph components.</summary>
      <remarks>Specifies the strategy that is used to assign partial nodes to subgraph components.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.ConfigureOrthogonalEdgeRouter(yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter)">
      <summary>This method is called each time edges are routed with an OrthogonalEdgeRouter instance.</summary>
      <param name="edgeRouter">the instance used for routing the edges.</param>
      <remarks>
            This method is called each time edges are routed with an OrthogonalEdgeRouter instance.
            Hence, it offers a way to modify the used settings.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.ConsiderNodeAlignment">
      <summary>
            True, if node alignment is enabled, that is the algorithm tries to
            align partial nodes with other nodes.
            </summary>
      <remarks>
            Getter:<br />
            Returns true, if node alignment is enabled, that is the algorithm tries to
            align partial nodes with other nodes.
            <para />
            Setter:<br />
            Specifies whether or not nodes should be aligned. If set to true, the algorithm tries to align the center of
            partial nodes with other nodes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.CoreLayouter">
      <summary>The core layouter, i.e., the layout algorithm that is applied to the subgraph components.</summary>
      <remarks>Specifies the core layouter, i.e., the layout algorithm that is applied to the subgraph components.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.DoPartialLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>This method calculates the partial layout.</summary>
      <param name="graph">the input graph.</param>
      <remarks>
            This method calculates the partial layout. Therefore, it calls the following methods: 1.
            <see cref="M:yWorks.yFiles.Layout.Partial.PartialLayouter.RouteEdgesBetweenFixedElements(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.EdgeList)" />
            2.
            <see cref="M:yWorks.yFiles.Layout.Partial.PartialLayouter.LayoutSubgraph(yWorks.yFiles.Layout.LayoutGraph)" />
            for each subgraph component 3.
            <see cref="M:yWorks.yFiles.Layout.Partial.PartialLayouter.PlaceSubgraphs(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[])" />
            4.
            <see cref="M:yWorks.yFiles.Layout.Partial.PartialLayouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.EdgeList)" />
            <p />
            Note: the method is called after applying the
            <see cref="T:yWorks.yFiles.Layout.OrientationLayouter" />
            . Hence, the called methods
            always assume that the graph is drawn from top to bottom.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.EdgeRouter">
      <summary>
            The edge router used for routing partial edges as well as edges
            between different subgraph components (so-called inter-edges).
            </summary>
      <remarks>
            Getter:<br />
            Returns the edge router used for routing partial edges as well as edges
            between different subgraph components (so-called inter-edges).
            <para />
            Setter:<br />
            Sets a customized edge router.
            The specified edge router is used for routing partial edges as well as
            edges between different subgraph components (so-called inter-edges).
            Edges that have to be routed with the specified router will be marked
            using this algorithm's
            <see cref="F:yWorks.yFiles.Layout.Partial.PartialLayouter.RouteEdgeDpKey" />
            data provider key.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.EdgeRoutingStrategy">
      <summary>The specified edge routing strategy.</summary>
      <remarks>
            Getter:<br />
            Return the specified edge routing strategy.
            <para />
            Setter:<br />
            This method allows to specify the edge routing strategy that is used for
            routing partial edges and edges between different subgraph components
            (so-called inter-edges).
            <p>
            Note: if a customized edge router is set with method
            <see cref="P:yWorks.yFiles.Layout.Partial.PartialLayouter.EdgeRouter" />
            , the layout algorithm always
            uses the corresponding routing strategy.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.FixedGroupResizingEnabled">
      <summary>Specifies whether or not fixed group nodes may be resized.</summary>
      <remarks>
            Getter:<br />
            Returns whether or not fixed group nodes may be resized.
            <para />
            Setter:<br />
            Specifies whether or not fixed (non-partial) group nodes may be resized.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.LayoutOrientation">
      <summary>The layout orientation.</summary>
      <remarks>Specifies the layout orientation.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.LayoutSubgraph(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates the layout for the subgraph component.</summary>
      <param name="subGraph">the subgraph component</param>
      <remarks>Calculates the layout for the subgraph component.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.MaximalDuration">
      <summary>The time limit (in milliseconds) set for the layout algorithm.</summary>
      <remarks>
            Getter:<br />
            Returns the time limit (in milliseconds) set for the layout algorithm.
            By default the time limit is Integer.MAX_VALUE.
            <para />
            Setter:<br />
            Sets a preferred time limit (in milliseconds) for the layout algorithm. Note that restricting the maximal duration
            may result in a worse layout quality. Furthermore, the real runtime may exceed the maximal duration since the
            layout algorithm still have to find a valid solution.
            By default the time limit is Integer.MAX_VALUE.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.MinimalNodeDistance">
      <summary>The minimum distance between two adjacent nodes.</summary>
      <remarks>Specifies the minimum distance between two adjacent nodes.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.OptimizeLayoutOrientation">
      <summary>
            Specifies whether or not a postprocessing step should be applied to reduce
            the number of edges that do not comply with the desired orientation.
            </summary>
      <remarks>
            Specifies whether or not a postprocessing step should be applied to reduce
            the number of edges that do not comply with the desired orientation.
            <p>
            By default, this feature is disabled.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.PackComponents">
      <summary>
            If enabled, the bounding boxes of subgraph components may overlap (elements of different components will still not
            overlap).
            </summary>
      <remarks>
            Getter:<br />
            If enabled, the bounding boxes of subgraph components may overlap (elements of different components will still not
            overlap).
            <para />
            Setter:<br />
            Packing subgraph components leads to more compact layout results. If set to true, the bounding boxes of subgraph
            components may overlap (elements of different components will still not overlap).
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.PartialLayouter.PartialEdgesDpKey">
      <summary>The data provider key used to look up the partial edges of the graph.</summary>
      <remarks>
            The data provider key used to look up the partial edges of the graph.
            The looked up data provider should provide boolean values
            for the edges of that graph. The boolean value should signal
            whether an edge is to be considered as partial or not.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.PartialLayouter.PartialNodesDpKey">
      <summary>The data provider key used to look up the partial nodes of the graph.</summary>
      <remarks>
            The data provider key used to look up the partial nodes of the graph.
            The looked up data provider should provide boolean values
            for the nodes of that graph. The boolean value should signal
            whether a node is to be considered as partial or not.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.PlaceSubgraphs(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.NodeList[])">
      <summary>This method places the subgraph components one-by-one onto the drawing area.</summary>
      <param name="graph">the input graph</param>
      <param name="subgraphComponents">each entry contains a NodeList that defines a subgraph component</param>
      <remarks>
            This method places the subgraph components one-by-one onto the drawing area. Therefore, it considers the specified
            objective for finding a 'good' position, see (
            <see cref="P:yWorks.yFiles.Layout.Partial.PartialLayouter.PositioningStrategy" />
            ).
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.PositioningStrategy">
      <summary>The objective used for finding 'good' positions for subgraph components.</summary>
      <remarks>Specifies the objective used for finding 'good' positions for subgraph components.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.PartialLayouter.RouteEdgeDpKey">
      <summary>The data provider key used to mark edges for routing.</summary>
      <remarks>
            The data provider key used to mark edges for routing.
            The registered data provider's
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see>
            method will return <see langword="true" /> for edges that have to be
            routed and <see langword="false" /> for all other edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.RouteEdgesBetweenFixedElements(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method routes all partial edges that connect two fixed elements.</summary>
      <param name="graph">the original graph.</param>
      <param name="partialEdges">the edges to route.</param>
      <remarks>
            This method routes all partial edges that connect two fixed elements. Therefore, it uses the edge router set with
            method
            <see cref="P:yWorks.yFiles.Layout.Partial.PartialLayouter.EdgeRouter" />
            . If no edge router was specified by the user, it uses an internal
            edge router with routing strategy
            <see cref="P:yWorks.yFiles.Layout.Partial.PartialLayouter.EdgeRoutingStrategy" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.RouteInterEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.EdgeList)">
      <summary>
            This method routes all inter-edges, that is edges between different
            subgraph components (including edges between fixed and partial elements).
            </summary>
      <param name="graph">the original graph.</param>
      <param name="interEdges">the edges to route.</param>
      <remarks>
            This method routes all inter-edges, that is edges between different
            subgraph components (including edges between fixed and partial elements).
            Therefore, it uses the edge router set with method
            <see cref="P:yWorks.yFiles.Layout.Partial.PartialLayouter.EdgeRouter" />
            . If no edge router was specified
            by the user, it uses an internal edge router with routing strategy
            <see cref="P:yWorks.yFiles.Layout.Partial.PartialLayouter.EdgeRoutingStrategy" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.RouteInterEdgesImmediately">
      <summary>Specifies whether or not edges between different subgraph components should be routed immediately.</summary>
      <remarks>
            Getter:<br />
            Returns whether or not edges between different subgraph components should be routed immediately.
            <para />
            Setter:<br />
            Whether or not edges between different subgraph components should be routed immediately.
            If this option is enabled, edges are routed during the placement of the subgraph components, i.e., immediately
            after a component is placed, its edges to other, already placed components are routed.
            Otherwise these edges are routed in a separate step after placing all subgraph components.
            By default this option is disabled.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Partial.PartialLayouter.StraightLineEdgeRouter">
      <summary>Simple Edge Router that draws edges straight-line.</summary>
      <remarks>Simple Edge Router that draws edges straight-line.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.StraightLineEdgeRouter.#ctor">
      <summary>Initializes a new instance of the StraightLineEdgeRouter class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.StraightLineEdgeRouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true" /> iff the given graph can be laid
            out by this algorithm.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Partial.PartialLayouter.StraightLineEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine that assigns new layout information to the given graph.</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Partial.PartialLayouter.StraightLineEdgeRouter.SelectedEdgesDpKey">
      <summary>
            The <c>DataProvider</c> key to mark edges as
            <em>selected</em>.
            </summary>
      <exception cref="T:System.ArgumentException">if the specified key is <see langword="null" />.</exception>
      <remarks>
            Specifies the <c>DataProvider</c> key to mark edges as
            <em>selected</em>.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedEdgesDpKey" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Partial.SubgraphPositioningStrategy">
      <summary>Specifies the objective used for finding 'good' positions for subgraph components.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.SubgraphPositioningStrategy.Barycenter">
      <summary>
            Specifies the objective used for finding 'good' positions for subgraph components. This values specifies that each
            component should be placed close to the barycenter of its graph neighbors.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Partial.SubgraphPositioningStrategy.FromSketch">
      <summary>
            Specifies the objective used for finding 'good' positions for subgraph components. This values specifies that each
            component should be placed close to its original position.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Random.RandomLayouter">
      <summary>
            This class generates a layout, where the nodes are placed
            randomly.
            </summary>
      <remarks>
            This class generates a layout, where the nodes are placed
            randomly. Edges have no bends and ports.
            The layout is placed inside a box.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Random.RandomLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Random.RandomLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Random.RandomLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns always <see langword="true" />, because every graph can be drawn.</summary>
      <remarks>Returns always <see langword="true" />, because every graph can be drawn.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Random.RandomLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Perform the layout.</summary>
      <remarks>Perform the layout.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Random.RandomLayouter.LayoutBounds">
      <summary>The rectangle, inside which the layout should be placed.</summary>
      <remarks>Specifies the rectangle, inside which the layout should be placed.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Random.RandomLayouter.Seed">
      <summary>The randomization seed, with which the layout will be generated.</summary>
      <remarks>Specifies the randomization seed, with which the layout will be generated.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.BusDescriptor">
      <summary>A descriptor for bus-related information to be associated with an edge.</summary>
      <remarks>
            A descriptor for bus-related information to be associated with an edge. It consists of a bus ID defining the bus
            of the associated edge, two optional edge group IDs for specifying the edge grouping at the source and target side,
            respectively, and an optional boolean flag to mark the edge as fixed.
            <p />
            Every object except <see langword="null" /> can be used as valid bus ID. Every edge of ID <see langword="null" /> forms a group
            of its own. Also, every object except <see langword="null" /> can be used as valid edge group ID. If there is no group ID
            defined for an edge or if <see langword="null" /> is set, a default group ID is used. Therefore, all such edges ending at
            the same node belong to the same group.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusDescriptor.#ctor(System.Object)">
      <summary>
            Creates a new instance of <c>BusDescriptor</c> for the specified bus ID which is marked as not fixed and uses
            the default edge group IDs.
            </summary>
      <param name="busID">the ID of the bus the associated edge belongs to</param>
      <remarks>
            Creates a new instance of <c>BusDescriptor</c> for the specified bus ID which is marked as not fixed and uses
            the default edge group IDs.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusDescriptor.#ctor(System.Object,System.Boolean)">
      <summary>Creates a new instance of <c>BusDescriptor</c> for the specified parameters and default group IDs.</summary>
      <param name="busID">the ID of the bus the associated edge belongs to</param>
      <param name="fixed">whether the associated edge is fixed or not</param>
      <remarks>Creates a new instance of <c>BusDescriptor</c> for the specified parameters and default group IDs.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusDescriptor.#ctor(System.Object,System.Boolean,System.Object,System.Object)">
      <summary>Creates a new instance of <c>BusDescriptor</c> for the specified parameters.</summary>
      <param name="busID">the ID of the bus the associated edge belongs to</param>
      <param name="fixed">whether the associated edge is fixed or not</param>
      <param name="sourceGroupID">the group ID of the source side</param>
      <param name="targetGroupID">the group ID of the target side</param>
      <remarks>Creates a new instance of <c>BusDescriptor</c> for the specified parameters.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusDescriptor.#ctor(System.Object,System.Object,System.Object)">
      <summary>Creates a new instance of <c>BusDescriptor</c> for the specified parameters and marks it as not fixed.</summary>
      <param name="busID">the ID of the bus the associated edge belongs to</param>
      <param name="sourceGroupID">the group ID of the source side</param>
      <param name="targetGroupID">the group ID of the target side</param>
      <remarks>Creates a new instance of <c>BusDescriptor</c> for the specified parameters and marks it as not fixed.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusDescriptor.BusId">
      <summary>The bus ID.</summary>
      <remarks>Specifies the bus ID.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusDescriptor.Equals(System.Object)">
      <summary>Indicates whether some other object is "equal to" this one.</summary>
      <param name="obj">the reference object with which to compare.</param>
      <returns>
        <see langword="true" /> if all corresponding parameters are equal; <see langword="false" /> otherwise.</returns>
      <remarks>Indicates whether some other object is "equal to" this one.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusDescriptor.Fixed">
      <summary>Specifies whether the associated edge is fixed or not.</summary>
      <remarks>Specifies whether the associated edge is fixed or not.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusDescriptor.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusDescriptor.SourceGroupId">
      <summary>The group ID for the source side of the edge.</summary>
      <remarks>Specifies the new group ID for the source side of the edge.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusDescriptor.TargetGroupId">
      <summary>The group ID for the target side of the edge.</summary>
      <remarks>Specifies the new group ID for the target side of the edge.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusDescriptor.ToString">
      <summary>Returns a string consisting of the bus ID, the fixed flag, and both group IDs.</summary>
      <returns>a string consisting of the bus ID, the fixed flag, and both group IDs</returns>
      <remarks>Returns a string consisting of the bus ID, the fixed flag, and both group IDs.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.BusRepresentations">
      <summary>
            This class provides helpers to convert between buses given by complete subgraphs and buses represented by specific
            <em>hub</em> nodes.
            </summary>
      <remarks>
            This class provides helpers to convert between buses given by complete subgraphs and buses represented by specific
            <em>hub</em> nodes. <p> In a representation by means of hubs, each connected subgraph induced by hubs establishes a
            bus. All regular nodes (non-hubs) which are connected to hubs of the same component are end-nodes of the same bus. In
            other words, nodes which are reachable on paths consisting of only hubs belong to the same bus. Of course, a node can
            be an end-node of more than one bus. </p> <p> Since a bus models a group of nodes in which every node is connected to
            every other node, it can be represented as a complete subgraph of these nodes. To distinguish buses in this
            representation, each edge must be associated with a unique ID which identifies the bus it is associated to. This is
            the representation expected by
            <see cref="T:yWorks.yFiles.Layout.Router.BusRouter" />
            . </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusRepresentations.ReplaceHubsBySubgraph(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.EdgeList[],yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>
            Changes the representation of buses from hubs to complete subgraphs by creating new edges between regular nodes and
            removing the hubs.
            </summary>
      <param name="graph">the graph of the bus</param>
      <param name="hubEdgesLists">an <c>EdgeList</c> for each bus</param>
      <param name="hubMarker">
            a <c>DataProvider</c> that returns <see langword="true" /> if and only if a node is a
            hub
            </param>
      <param name="fixedMarker">
            a <c>DataProvider</c> that returns <see langword="true" /> if and only if an edge is
            fixed
            </param>
      <param name="descriptorAcceptor">a <c>DataAcceptor</c> to which the created bus descriptors are set</param>
      <returns>a list of the created edges</returns>
      <remarks>
            Changes the representation of buses from hubs to complete subgraphs by creating new edges between regular nodes and
            removing the hubs. This method respects multiple connections of nodes and creates appropriate
            <see cref="T:yWorks.yFiles.Layout.Router.BusDescriptor" />
            s consisting of the bus ID and source and target group IDs.
            <p />
            The path of each new edge follows the route defined by the component of the hubs. If the subgraph of hubs is not a
            tree, these paths are ambiguous. In this case, an arbitrary tree is computed from the hub's subgraph which defines
            all the paths.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusRepresentations.ReplaceHubsBySubgraph(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>Changes the representation of buses from hubs to complete subgraphs.</summary>
      <remarks>
            Changes the representation of buses from hubs to complete subgraphs. This method calls
            <code>replaceHubsBySubgraph(graph, calculateBusEdgeLists(graph, hubMarker), hubMarker, false,
            busDescriptors)</code>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusRepresentations.ReplaceSubgraphByHubs(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeCursor,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataAcceptor)">
      <summary>Changes the representation of buses from complete subgraphs to hubs by replacing intersection points by hubs.</summary>
      <param name="graph">the graph of the bus</param>
      <param name="edgeCursor">an <c>EdgeCursor</c> of the regular edges</param>
      <param name="descriptorProvider">
            a <c>DataProvider</c> that provides a
            <see cref="T:yWorks.yFiles.Layout.Router.BusDescriptor" />
            for each edge
            </param>
      <param name="busIDAcceptor">
            an optional <c>DataAcceptor</c>. If specified, the bus ID for each new edge is set
            to this data acceptor
            </param>
      <exception cref="T:System.InvalidOperationException">if the path of an edge is not orthogonal or if some paths form a cycle</exception>
      <remarks>
            Changes the representation of buses from complete subgraphs to hubs by replacing intersection points by hubs. The
            edges must form an orthogonal, cycle-free bus, otherwise an
            <see cref="T:System.InvalidOperationException" />
            is thrown.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.BusRepresentations.SourcePointIdDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to transfer a user-defined object from each original edge to the respective
            newly created edge.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to transfer a user-defined object from each original edge to the respective
            newly created edge. Algorithms which respect this key expect the associated data provider to be also an instance of
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            to enable the storage of the data object for the new edge. Since there is no one-to-one
            mapping between original and new edges, the data provider of this key is responsible for the edges whose source end
            is a regular node.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.BusRepresentations.TargetPointIdDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to transfer a user-defined object from each original edge to the respective
            newly created edge.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to transfer a user-defined object from each original edge to the respective
            newly created edge. Algorithms which respect this key expect the associated data provider to be also an instance of
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            to enable the storage of the data object for the new edge. Since there is no one-to-one
            mapping between original and new edges, the data provider of this key is responsible for the edges whose target end
            is a regular node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusRepresentations.ToEdgeLists(yWorks.yFiles.Algorithms.Graph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>Calculates for every bus represented by hubs a list of all of its edges.</summary>
      <param name="graph">the graph</param>
      <param name="hubMarker">a <c>DataProvider</c> which returns <see langword="true" /> if and only if a node is a hub</param>
      <returns>an array of <c>EdgeList</c>s. Each list contains all edges of a bus.</returns>
      <remarks>
            Calculates for every bus represented by hubs a list of all of its edges. Note that this method cannot return
            isolated hubs and that each edge between two regular nodes establishes a separate bus.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.BusRouter">
      <summary>
            An orthogonal bus-style edge routing algorithm which combines the large number of edges of complete subgraphs in a
            concise, tree-like structure that consists of vertical and horizontal line segments.
            </summary>
      <remarks>
            An orthogonal bus-style edge routing algorithm which combines the large number of edges of complete subgraphs in a
            concise, tree-like structure that consists of vertical and horizontal line segments. A complete (sub)graph is a set
            of nodes, in which each node is connected to every other node.  The positions of the nodes in a graph are not
            altered by this algorithm.
            <p><br /><center><img src="doc-files/y.layout.router.BusRouter.gif" border="1" /></center><br /></p>
            <p>
            In a drawing of this algorithm, each edge path is orthogonal and there are no cycles induced by any two edge paths of
            the same bus, that is, the combination of all edge routes looks like an orthogonal tree. Besides these strict
            requirements, the algorithm aims to find routes where shared paths of edges with different end-nodes are drawn on top
            of each other and form long straight lines, so-called <b>backbone segments</b>. From these
            backbone segments, short connections of grouped edges branch off to each node (<b>bus
            connections</b>).
            </p><p>
            This routing algorithm uses a two-phase process. First, in <b>backbone selection</b>, a set
            of good initial backbone segments is determined. In <b>routing and recombination</b>, each
            initial backbone segment is connected to all others and also to each node by using orthogonal edge paths. Then, the
            set of resulting structures is reduced to the most optimal structure where backbone segments are long and connections
            to the nodes are short. Note that the calculated paths can join before reaching an initial backbone segment and,
            thus, establish additional backbone segments. Contrariwise, initial backbone segments of low overall profit are
            discarded and connections to them are rerouted to other backbone segments.
            </p><p>
            To determine which edges belong to a common bus, a mapping that assigns a bus ID to each edge must be specified using
            <see cref="T:yWorks.yFiles.Layout.Router.BusDescriptor" />
            s. A data provider holding bus descriptor objects is expected to be registered
            with the graph using the
            <see cref="F:yWorks.yFiles.Layout.Router.BusRouter.EdgeDescriptorDpKey" />
            look-up key. In the absence of an individual bus ID for an
            edge, a bus consisting only of the single edge is created. Additionally, a bus descriptors allows to mark its
            associated edge as fixed or movable, which is required for incremental routing, and to specify an optional group ID
            for an edge's source end and target end, respectively.
            </p><p>
            Incremental routing means extending or updating an already existing bus-style representation. This can be used to
            rearrange existing edges or to include additional edges in an existing bus. The paths of edges not marked as fixed by
            their associated
            <see cref="P:yWorks.yFiles.Layout.Router.BusDescriptor.Fixed">BusDescriptor</see>
            are calculated anew. The structure induced by the
            fixed edges must be orthogonal and cycle-free.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusRouter.#ctor">
      <summary>Creates a new instance of <c>BusRouter</c>.</summary>
      <remarks>Creates a new instance of <c>BusRouter</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusRouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true" /> if the specified graph can be routed by this algorithm.</summary>
      <remarks>
            Returns <see langword="true" /> if the specified graph can be routed by this algorithm. Calling
            <see cref="M:yWorks.yFiles.Layout.Router.BusRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            with
            the specified graph as its argument will only succeed if this method returns <see langword="true" />.
            <p />
            If there is no fixed edge in the graph, routing is always possible. Otherwise, the route of each fixed edge must be
            orthogonal.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusRouter.CreateOrthogonalEdgeRouter">
      <summary>Factory method that creates an appropriate OrthogonalEdgeRouter implementation.</summary>
      <returns>an appropriate OrthogonalEdgeRouter</returns>
      <remarks>Factory method that creates an appropriate OrthogonalEdgeRouter implementation.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.CrossingCost">
      <summary>The cost for each edge crossing of a routed path.</summary>
      <remarks>
            Specifies the cost for each edge crossing of a routed path. A cost of <c>n</c> means that a path rather changes
            direction <c>n</c> times than crossing the path of an edge. If the cost is set to <c>0.0</c>, no global
            crossing optimization is performed. Setting a higher value will activate global crossing minimization. A good
            trade-off between the number of direction changes and few crossings of a path is achieved by values between
            <c>1.0</c> and <c>3.0</c>. By default, a cost of <c>1.0</c> is set.
            <p />
            This setting is taken into account only in the routing and recombination phase and does not affect the selection of
            the initial backbone segments.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Calculates a new bus layout for the specified graph.</summary>
      <param name="graph">the graph to lay out</param>
      <remarks>Calculates a new bus layout for the specified graph.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.BusRouter.EdgeDescriptorDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store the
            <see cref="T:yWorks.yFiles.Layout.Router.BusDescriptor" />
            of every edge.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used to store the
            <see cref="T:yWorks.yFiles.Layout.Router.BusDescriptor" />
            of every edge. A bus descriptor provides the
            edge's bus ID, its optional group IDs and whether or not the edge is fixed.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.BusRouter.EdgeSubsetDpKey">
      <summary>
        <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used for specifying the edge subset to be laid out.
            </summary>
      <remarks>
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            key used for specifying the edge subset to be laid out. This key is used if no custom key is
            set. The algorithm expects for each edge in the graph to find a
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.GetBool(System.Object)">boolean</see>
            that
            indicates whether the node belongs to the scope.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.GridRouting">
      <summary>Specifies whether or not to route edge segments on grid lines.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to route edge segments on grid lines only. By default, this feature is disabled.
            <para />
            Getter:<br />
            Returns whether or not to route edge segments on grid lines.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.GridSpacing">
      <summary>The grid spacing that is used when grid routing is enabled.</summary>
      <remarks>Specifies the grid spacing that is used when grid routing is enabled. By default, a spacing of <c>10</c> is set.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.MinimumBackboneSegmentLength">
      <summary>The preferred minimum length of a backbone segment.</summary>
      <remarks>
            Specifies the preferred minimum length of a backbone segment. This should be at least as large as the typical distance
            between nodes to avoid small backbone segments. It is reasonable to set this according to the dimension of the
            graph's bounding box. By default, a minimum length of <c>100.0</c> is set.
            <p />
            This number defines the minimum length of backbone segments which are computed by the backbone selection phase.
            Some of the final backbone segments may be shorter due to changes in the routing and recombination phase.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.MinimumBusConnectionsCount">
      <summary>The minimum number of bus connections each backbone segment must have.</summary>
      <remarks>
            Getter:<br />
            Returns the minimum number of bus connections each backbone segment must have.
            <para />
            Setter:<br />
            Sets the minimum number of bus connections a backbone segment must have. If a backbone segment has less
            connections, it is removed and the affected nodes connect to another backbone segment. Three or four is a good
            choice for small graphs, for larger graphs a much larger count can be reasonable. By default, a minimum count of
            <c>3</c> is set.
            <p />
            This setting is taken into account only in the routing and recombination phase and does not affect the selection of
            the initial backbone segments.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.MinimumDistanceToEdge">
      <summary>The minimum distance between edge segments.</summary>
      <remarks>Specifies the minimum distance between edge segments. By default, a distance of <c>5</c> is set.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.MinimumDistanceToNode">
      <summary>The minimum distance between edge segments and nodes.</summary>
      <remarks>Specifies the minimum distance between edge segments and nodes. By default, a distance of <c>10</c> is set.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.PreferredBackboneSegmentCount">
      <summary>The preferred number of backbone segments with the same orientation.</summary>
      <remarks>
            Getter:<br />
            Returns the preferred number of backbone segments with the same orientation.
            <para />
            Setter:<br />
            Sets the maximal number of selected backbone segments with the same orientation. The more initial backbone
            segments, the longer the running time. By default, a count of <c>2</c> is set.
            <p />
            This count defines the number of backbone segments of the same orientation which are computed by the backbone
            selection phase. The final number of backbone segments may be different due to changes in the routing and
            recombination phase.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.RemoveCollinearBends">
      <summary>Specifies whether or not collinear bends are removed from the layout.</summary>
      <remarks>
            Specifies whether or not collinear bends are removed from the layout. If an edge has a collinear bend, there is
            another edge which has a real bend at this point, i.e. the bend location is an intersection of the bus. Therefore,
            it is advantageous for some applications to keep such bends. By default, this feature is enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.Rerouting">
      <summary>Specifies whether rerouting of edges with many crossings is enabled.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to enable a further crossing minimization optimization based on rerouting edges that cross
            many edges. By default, this feature is disabled. Activating this feature only makes sense if the global crossing
            cost is set to a value greater than <c>0.0</c>.
            <p />
            This setting is taken into account only in the routing and recombination phase and does not affect the selection of
            the initial backbone segments.
            <para />
            Getter:<br />
            Returns whether rerouting of edges with many crossings is enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.Scope">
      <summary>The scope set for this router.</summary>
      <remarks>
            Getter:<br />
            Returns the scope set for this router.
            <para />
            Setter:<br />
            Sets the scope for this router. The scope determines which edges are routed. Defaults to
            <see cref="F:yWorks.yFiles.Layout.Router.Scope.All" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.BusRouter.SelectedEdgesDpKey">
      <summary>The <c>DataProvider</c> key to mark edges as <em>selected</em>.</summary>
      <exception cref="T:System.ArgumentException">if the specified key is <see langword="null" />.</exception>
      <remarks>
            Specifies the <c>DataProvider</c> key to mark edges as <em>selected</em>. <p> By default,
            <see cref="F:yWorks.yFiles.Layout.Router.BusRouter.EdgeSubsetDpKey" />
            is used. </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.BusRouter.SetProperty(System.String,System.Object)">
      <summary>Provides access to implementation specific properties of the algorithms used internally.</summary>
      <param name="key">the key to a property</param>
      <param name="value">the value to associate with the key</param>
      <remarks>
            Provides access to implementation specific properties of the algorithms used internally. <br /> Used for internal
            purposes.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter">
      <summary>This class represents an edge router.</summary>
      <remarks>
            This class represents an edge router. It combines two strategic steps of edge routing and executes them after each
            other. The first strategy is called path finder strategy and will route the edges, potentially with edge overlaps.
            The second strategy will then split overlapping edge segments inside their channels and distribute them according to
            the specific distribution strategy.
            For path finding strategies you can for example use
            <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder" />
            or
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter" />
            . By default the latter will be used.
            One possible implementation of an edge distribution strategy is
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage" />
            , which is also used by default.
            Note: when exchanging only one of the strategies, make sure, that their algorithms will use the same (sub)set
            of graph objects. The strategies bound to this router by default will use key
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.AffectedEdgesDpKey" />
            to determine
            the affected edges.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter" /> class</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.AffectedEdgesDpKey">
      <summary>
            This field is used as the key to add a DataProvider to the graph, which specifies the edges, that are affected by
            the edge routing.
            </summary>
      <remarks>
            This field is used as the key to add a DataProvider to the graph, which specifies the edges, that are affected by
            the edge routing.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            It is called by the
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method for each group node object in the input graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            It is called by the
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method for each node object in the input graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.EdgeDistributionStrategy">
      <summary>The currently used edge distribution strategy of this router.</summary>
      <remarks>
            Setter:<br />
            Sets the strategy with which overlapping edge segments will be distributed in their provided channel.
            Note: when exchanging only one of the strategies, make sure, that their algorithms will use the same (sub)set
            of graph objects. The strategies bound to this router by default will us key
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.AffectedEdgesDpKey" />
            to determine the
            affected edges.
            <para />
            Getter:<br />
            Returns the currently used edge distribution strategy of this router.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.PathFinderStrategy">
      <summary>The currently used path finder strategy of this router.</summary>
      <remarks>
            Setter:<br />
            Sets the strategy for path finding. Path finding means routing the edges in a first approach.
            Note: when exchanging only one of the strategies, make sure, that their algorithms will use the same (sub)set
            of graph objects. The strategies bound to this router by default will us key
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.AffectedEdgesDpKey" />
            to determine the
            affected edges.
            <para />
            Getter:<br />
            Returns the currently used path finder strategy of this router.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder">
      <summary>
            This layouter is a s special version of
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            that can be used as a path
            finding strategy in
            <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter" />
            .
            </summary>
      <remarks>
            This layouter is a s special version of
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            that can be used as a path
            finding strategy in
            <see cref="T:yWorks.yFiles.Layout.Router.ChannelEdgeRouter" />
            .
            It takes a bit longer than using the default path finding strategy
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter" />
            but therefore will create no node crossings. It can be
            configured like OrthogonalEdgeRouter.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder.#ctor">
      <summary>Initializes a new instance of the OrthogonalShortestPathPathFinder class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder.AffectedEdgesDpKey">
      <summary>The key of a DataProvider that defines the edges, that shall be affected</summary>
      <remarks>
            Setter:<br />
            Determines a key, that is registered on the graph and determines the edges which shall be affected by this
            router.
            <para />
            Getter:<br />
            Returns the key of a DataProvider that defines the edges, that shall be affected
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true" /> if the specified core layouter does, and also when there is no core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main entrance to orthogonal edge routing.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.ChannelOrientation">
      <summary>Channel orientation specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Vertical">
      <summary>Channel orientation specifier. Used to route edges in a vertical channel.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Horizontal">
      <summary>Channel orientation specifier. Used to route edges in a horizontal channel.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.ChannelRouter">
      <summary>
            Class that routes edges within a vertical or horizontal channel
            All edges will then be routed in an orthogonal fashion.
            </summary>
      <remarks>
            Class that routes edges within a vertical or horizontal channel
            All edges will then be routed in an orthogonal fashion.
            This class basically assigns subchannels to each each key (normally edges)
            so that the
            overall number of subchannels is small.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.#ctor(System.Double,System.Double)">
      <summary>Creates a new instance of ChannelRouter for a horizontal channel.</summary>
      <param name="min">the smallest assignable coordinate within the channel</param>
      <param name="max">the largest assignable  coordinate within the channel</param>
      <remarks>Creates a new instance of ChannelRouter for a horizontal channel.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.#ctor(System.Double,System.Double,yWorks.yFiles.Layout.Router.ChannelOrientation)">
      <summary>Creates a new instance of ChannelRouter.</summary>
      <param name="min">the smallest assignable coordinate within the channel</param>
      <param name="max">the largest assignable  coordinate within the channel</param>
      <param name="orientation">
            the direction of the channel. One of
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Vertical" />
            and
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Horizontal" /></param>
      <remarks>Creates a new instance of ChannelRouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddGroupSegment(System.Object,System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Adds an edge object that belongs to a group of edges
            with source and target coordinates
            to the set of edges that have to be routed within the channel
            Edges sharing the same groupId will be placed on the same channel.
            </summary>
      <remarks>
            Adds an edge object that belongs to a group of edges
            with source and target coordinates
            to the set of edges that have to be routed within the channel
            Edges sharing the same groupId will be placed on the same channel.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddSegment(System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>
            Adds an edge object with source and target coordinates
            to the set of edges that have to be routed within the channel
            </summary>
      <remarks>
            Adds an edge object with source and target coordinates
            to the set of edges that have to be routed within the channel
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.ContainsGroupKey(System.Object)">
      <summary>Determines if the given key has been registered as a grouping key with this instance.</summary>
      <param name="groupKey">
            the key which is used in
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddGroupSegment(System.Object,System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)" /></param>
      <remarks>Determines if the given key has been registered as a grouping key with this instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.ContainsKey(System.Object)">
      <summary>Determines if the given key has been registered already with this instance.</summary>
      <param name="key">
            the key which is used in
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddSegment(System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)" /></param>
      <remarks>Determines if the given key has been registered already with this instance.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelRouter.Epsilon">
      <summary>The current epsilon value.</summary>
      <remarks>
            Specifies the current epsilon value. Subchannel lengths smaller than this
            value will be ignored by this instance if the the <c>epsilonChannelIgnored</c>
            property is set to <see langword="true" />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelRouter.EpsilonChannelIgnored">
      <summary>
            Specifies whether subchannels shorter than <c>epsilon</c> are ignored
            by this instance.
            </summary>
      <remarks>
            Getter:<br />
            Returns whether subchannels shorter than <c>epsilon</c> are ignored
            by this instance.
            <para />
            Setter:<br />
            Determines if subchannel lengths smaller than epsilon should be ignored by the
            channel router. Default is <see langword="true" /> with an epsilon value of 0.5d.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.GetCoord(System.Object)">
      <summary>Returns the calculated channel coordinate for an added edge object.</summary>
      <param name="key">
            an edge object added with
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddSegment(System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)" /></param>
      <remarks>
            Returns the calculated channel coordinate for an added edge object.
            If for example the router was instantiated with the arguments
            <c>ChannelRouter(100,200,ChannelRouter.ROUTE_HORIZONTAL)</c>
            then the returned coordinate is an x-coordinate between 100 and
            200. This coordinate represents the x-coordinate of two additional
            bends that are needed to route the edge orthogonally from
            p1 to p2 (as specified in addSegment).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.GetGroupSubChannelRank(System.Object)">
      <summary>Returns the subchannel rank for the group indicated by the groupKey.</summary>
      <remarks>Returns the subchannel rank for the group indicated by the groupKey.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.GetSubChannelRank(System.Object)">
      <summary>Returns the subchannel rank of this segment within the channel.</summary>
      <param name="key">
            an edge object added with
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelRouter.AddSegment(System.Object,yWorks.yFiles.Algorithms.Geometry.YPoint,yWorks.yFiles.Algorithms.Geometry.YPoint)" /></param>
      <remarks>Returns the subchannel rank of this segment within the channel.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.Route">
      <summary>Routes all added edges within the specified channel.</summary>
      <remarks>
            Routes all added edges within the specified channel.
            The resulting subchannels can then be queried using the
            <see cref="M:yWorks.yFiles.Layout.Router.ChannelRouter.GetSubChannelRank(System.Object)" />
            method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.SegmentKeys">
      <summary>Returns an iterator over all added segment keys.</summary>
      <remarks>
            Returns an iterator over all added segment keys.
            For grouped edges, there will be a YList returned.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ChannelRouter.SetChannel(System.Double,System.Double,yWorks.yFiles.Layout.Router.ChannelOrientation)">
      <summary>Sets the channel bounds and direction.</summary>
      <param name="min">the smallest assignable coordinate within the channel</param>
      <param name="max">the largest assignable  coordinate within the channel</param>
      <param name="orientation">
            the orientation of the channel. One of
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Vertical" />
            and
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelOrientation.Horizontal" /></param>
      <remarks>
            Sets the channel bounds and direction. A call to this method
            implies that all previously added segments will be removed.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ChannelRouter.SubChannelCount">
      <summary>The number of subchannels within this channel.</summary>
      <remarks>
            Returns the number of subchannels within this channel.
            The return value <c>0</c> indicates that there are no subchannels
            present.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.CollinearBendHider">
      <summary>Temporarily hides collinear bends on edge paths.</summary>
      <remarks>Temporarily hides collinear bends on edge paths.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.CollinearBendHider.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.CollinearBendHider" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.CollinearBendHider.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Router.CollinearBendHider.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="F:yWorks.yFiles.Layout.Router.CollinearBendHider.SelectedEdgesDpKey">
      <summary>DataProvider key for boolean edge data.</summary>
      <remarks>
            DataProvider key for boolean edge data. Only selected edges
            will be considered by this stage. If this key is not bound
            to the graph, then all edges will be considered.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage">
      <summary>
            Layout stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            that adds support for a bus-like routing style.
            </summary>
      <remarks>
            Layout stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            that adds support for a bus-like routing style. Edges that connect to a
            common node can be marked as grouped by using the data provider keys
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
            or
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
            . This stage tries to route grouped edges on a vertical or horizontal
            bus. The edges will connect to their common node at the same port coordinate. There are some limitations to this
            stage: <ul> <li>If at least one edge of a specific edge group is part of the sphere of action of
            OrthogonalEdgeRouter, then all of the edges belonging to that group will be part of the sphere of action of the
            router. </li> <li> Edges can either be source or target grouped but not both at the same time. </li> <li> Not all
            edges belonging to a group will be placed on a common bus. Only edges that connect to nodes which lie in the same
            direction relative to their common node will be routed on a bus. </li> </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage.MinimalBusDistance">
      <summary>The minimal distance between a bus formed by an edge group and the nodes the grouped edges connect to.</summary>
      <remarks>
            Specifies the minimal distance between a bus formed by an edge group and the nodes the grouped edges connect to. By
            default this value is set to <c>15.0</c>.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.GroupNodeRouterStage">
      <summary>
            Layout stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            that should be
            applied when routing edges in hierarchically grouped graphs.
            </summary>
      <remarks>
            Layout stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            that should be
            applied when routing edges in hierarchically grouped graphs.
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            itself is not well suited
            to route edges that connect to grouped nodes, since it considers
            all nodes (also group nodes!) as obstacles that should be avoided
            when determining the route of an edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.GroupNodeRouterStage.#ctor">
      <summary>Creates a new instance of this class.</summary>
      <remarks>Creates a new instance of this class.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.GroupNodeRouterStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of this class.</summary>
      <param name="coreLayouter">
            the core layouter invoked by this stage.
            The coreLayouter must contain an instance of
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            in its layout pipeline.
            </param>
      <remarks>Creates a new instance of this class.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.GroupNodeRouterStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Router.GroupNodeRouterStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine.</summary>
      <remarks>Main layout routine.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.MonotonicPathRestriction">
      <summary>Constant that specifies monotonic path restrictions for edges.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.None">
      <summary>
            Constant that specifies monotonic path restrictions for edges.
            This constant specifies that there are no restrictions.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.Vertical">
      <summary>
            Constant that specifies monotonic path restrictions for edges.
            This constant specifies restrictions for the vertical direction, i.e.,
            each vertical edge segment is directed from the source to the target.
            Furthermore, each edge path starts and ends with a vertical segment.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.Horizontal">
      <summary>
            Constant that specifies monotonic path restrictions for edges.
            This constant specifies restrictions for the horizontal direction, i.e.,
            each horizontal edge segment is directed from the source to the target.
            Furthermore, each edge path starts and ends with a horizontal segment.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.Both">
      <summary>
            Constant that specifies monotonic path restrictions for edges.
            This constant specifies restrictions for the horizontal and vertical direction, i.e.,
            each horizontal as well as each vertical edge segment is directed from the source to the target.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.OrganicEdgeRouter">
      <summary>This algorithm routes edges using an organic-like layout approach and style.</summary>
      <remarks>
            This algorithm routes edges using an organic-like layout approach and style.
            It is implemented as a LayoutStage so that it can easily be appended to
            another stage, by setting the other stage as the core of this one.
            Note that this algorithm only works correctly if it is guaranteed that nodes are at
            least approximately twice as far away from each other as the minimal edge
            distance, which has been set for this algorithm. This can be achieved by using
            the
            <see cref="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CreateNodeEnlargementStage" />
            layout stage in combination with a stage
            that removes node overlaps as the core of this layouter.
            <p />
            Here is a sample output of the router using as input a straight-line drawing
            created by
            <see cref="T:yWorks.yFiles.Layout.Organic.SmartOrganicLayouter" />
            :
            <p />
            <p><br /><center><img src="doc-files/y.layout.router.OrganicEdgeRouter.star.gif" border="1" /></center></p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.#ctor">
      <summary>
            Creates a new instance of OrganicEdgeRouter with an
            initial minimal distance of <c>10</c>.
            </summary>
      <remarks>
            Creates a new instance of OrganicEdgeRouter with an
            initial minimal distance of <c>10</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.#ctor(System.Double)">
      <summary>
            Creates a new instance of OrganicEdgeRouter using the given
            initial minimal distance
            </summary>
      <remarks>
            Creates a new instance of OrganicEdgeRouter using the given
            initial minimal distance
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            It is called by the
            <see cref="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method for each group node object in the input graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            It is called by the
            <see cref="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method for each node object in the input graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CoreLayouter">
      <summary>The core layouter.</summary>
      <remarks>Specifies the core layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CreateNodeEnlargementStage">
      <summary>
            This will return a layout stage which can be given a core layouter, which
            itself should assure that the nodes do not overlap.
            </summary>
      <remarks>
            This will return a layout stage which can be given a core layouter, which
            itself should assure that the nodes do not overlap. This ensures that
            OrganicEdgeRouter has enough empty space for routing edges. This could for example look
            like the following snippet:
            <pre>
            RemoveOverlapsLayoutStage rmos = new RemoveOverlapsLayoutStage(0);
            LayoutStage nodeEnlarger = router.createNodeEnlargementStage();
            final CompositeLayoutStage cls = new CompositeLayoutStage();
            cls.appendStage(nodeEnlarger);
            cls.appendStage(new BendConverter());
            cls.appendStage(rmos);
            OrganicEdgeRouter oer = new OrganicEdgeRouter();
            oer.setCoreLayouter(cls);
            oer.doLayout(myGraph);
            </pre>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.EdgeNodeOverlapAllowed">
      <summary>Specifies whether or not edge-node overlaps are allowed.</summary>
      <remarks>
            Specifies whether or not edge-node overlaps are allowed.
            Enabling this option often leads to better results if the
            <see cref="M:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.CreateNodeEnlargementStage" />
            LayoutStage is not used
            (e.g. because the nodes are not allowed to move) and the distances between some nodes are small.
            However enabling this option may produce edge-node overlaps. Furthermore, the minimal distance (set with
            <see cref="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.MinimalDistance" />
            cannot always be maintained in that case.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.MinimalDistance">
      <summary>The minimal distance between nodes and non-incident edges.</summary>
      <remarks>
            Getter:<br />
            Returns the minimal distance between nodes and non-incident edges.
            <para />
            Setter:<br />
            Specifies the minimal distance the algorithm should guarantee between
            nodes and non-incident edges.
            Values should be larger than 10.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.RouteEdgeDpKey">
      <summary>
            Use this key to provide the algorithm with boolean values for each edge,
            specifying the ones which should be rerouted.
            </summary>
      <remarks>
            Use this key to provide the algorithm with boolean values for each edge,
            specifying the ones which should be rerouted.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.RoutingAll">
      <summary>
            Specifies whether edges should be rerouted even if they do not obey all
            constraints initially.
            </summary>
      <remarks>
            Specifies whether edges should be rerouted even if they do not obey all
            constraints initially. This flag is initially set to <see langword="false" />
            so that if edges that do not intersect with other nodes will not be rerouted
            by this algorithm.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrganicEdgeRouter.UsingBends">
      <summary>
            Specifies whether given bend coordinates are taken into account when
            determining initial bend positions.
            </summary>
      <remarks>
            Specifies whether given bend coordinates are taken into account when
            determining initial bend positions.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter">
      <summary>This class represents an orthogonal edge router.</summary>
      <remarks>
            This class represents an orthogonal edge router. An orthogonal edge router is a layout algorithm that changes the
            coordinates of the edge paths in a way that the resulting layout of the edges is made up of vertical and horizontal
            segments only. The router does not change the location or the size of the nodes in a diagram in any way.
            <p>
            Several LayoutStages can be used to enhance performance and/or functionality of this class, e.g.
            <see cref="T:yWorks.yFiles.Layout.Router.EdgeGroupRouterStage" />
            ,
            <see cref="T:yWorks.yFiles.Layout.Router.GroupNodeRouterStage" />
            ,
            <see cref="T:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage" />
            or
            <see cref="T:yWorks.yFiles.Layout.Router.PatchRouterStage" />
            .
            </p>
            <p>
            This edge router will obey strong and weak port constraints. It expects the port constraints to be bound to the input
            graph by the data provider keys
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
            . Furthermore, this class supports the more advanced port constraint
            concept of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s. It expects collections of port candidates to be bound to the input graph by the
            data provider keys
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.SourcePcListDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.TargetPcListDpKey" />
            .
            </p>
            <p>
            The router often finds ideal routes in difficult situations like the one depicted below. </p>
            <p><br /><center><img src="doc-files/y.layout.router.OrthogonalEdgeRouter.maze.gif" border="1" /></center></p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.#ctor">
      <summary>Creates a new instance of the Orthogonal Edge Router.</summary>
      <remarks>
            Creates a new instance of the Orthogonal Edge Router. The initial settings (the default values) make up an instance
            that: <ul> <li>processes all edges,</li> <li>applies "free" routing with a minimum distance between edge segments
            of 4 [pixel],</li> <li>uses an automatically derived minimum distance between edge segments and nodes of 2
            [pixel],</li> <li>obeys port constraints (if previously set),</li> <li>uses an edge routing style, where edge
            segments are drawn with the most distance to already known obstacles (i.e., nodes and other edge segments),</li>
            <li>draws edges, which cannot be routed, in an orthogonal fashion, and</li> <li>places edge ports along the node's
            bounding box.</li> </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Convenience constructor to simultaneously set a core layout algorithm which will run before the orthogonal edge
            router.
            </summary>
      <remarks>
            Convenience constructor to simultaneously set a core layout algorithm which will run before the orthogonal edge
            router.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.BadOrthogonal">
      <summary>Specifies whether bad edges should be drawn in an orthogonal fashion.</summary>
      <remarks>
            Setter:<br />
            Determines the way that edges which cannot be routed should be drawn. If set, edge paths are drawn in an orthogonal
            fashion. Otherwise the edge path is drawn as a straight line.
            <p>
            Default setting is <see langword="true" />. </p>
            <para />
            Getter:<br />
            Returns whether bad edges should be drawn in an orthogonal fashion.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true" /> if the specified core layouter does, and also when there is no core layouter.</summary>
      <remarks>Returns <see langword="true" /> if the specified core layouter does, and also when there is no core layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CenterToSpaceRatio">
      <summary>The currently set ratio between the two complementary weighting strategies center driven and space driven.</summary>
      <remarks>
            Setter:<br />
            Determines the ratio between two complementary weighting strategies, namely center driven and space driven
            weighting, when looking for an edge path. <ul> <li>Center driven means that those edge paths should be preferred
            that are closer to the edge's center. (Where the edge's center is an equidistant point between source node and
            target node.)</li> <li>Space driven means that those edge paths should be preferred that are evenly distributed
            over the available space.</li> </ul>
            <para />
            Getter:<br />
            Returns the currently set ratio between the two complementary weighting strategies center driven and space driven.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            It is called by the
            <see cref="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method for each group node object in the input graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            It is called by the
            <see cref="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method for each node object in the input graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.ConsiderNodeLabels">
      <summary>
            Specifies whether or not node labels are taken into account when calculating edge paths (thereby preventing
            possible edge/node label overlaps).
            </summary>
      <remarks>
            Specifies whether or not node labels are taken into account when calculating edge paths (thereby preventing
            possible edge/node label overlaps).
            <br /> The default is <see langword="false" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CoupledDistances">
      <summary>Specifies whether the minimum distances are coupled.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not the minimum distances should be coupled.
            I.e., whether half the value set for the minimum distance between edge
            segments should automatically be used as the minimum distance between edge
            segments and nodes, or a custom value should be used instead.
            <p>
            By default the minimum distances are coupled.
            </p>
            <para />
            Getter:<br />
            Returns whether the minimum distances are coupled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CrossingCost">
      <summary>The cost for each edge crossing of a routed path.</summary>
      <remarks>
            Specifies the cost for each edge crossing of a routed path. A cost of <c>n</c> means that a path rather changes
            direction <c>n</c> times than crossing the path of an edge. By default the cost is set to <c>0</c> and
            therefore no global crossing optimization is performed. Setting a higher value will activate global crossing
            minimization. A good trade-off between the number of direction changes and few crossings of a path is achieved by
            values between <c>1</c> and <c>3</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.CustomBorderCapacity">
      <summary>The currently set custom value for the capacity of the routing border around the graph's bounding box.</summary>
      <remarks>
            Setter:<br />
            Determines the custom value for the capacity of the routing border around the graph's bounding box. The routing
            border means the space left of the leftmost node, right of the rightmost node, above the topmost node, and below
            the bottommost node. By default this value is set to 5, i.e., the routing border accommodates up to 5 parallel edge
            paths left of the leftmost node, right of the rightmost node, etc.
            <para />
            Getter:<br />
            Returns the currently set custom value for the capacity of the routing border around the graph's bounding box.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main entrance to orthogonal edge routing.</summary>
      <remarks>Main entrance to orthogonal edge routing. Routes the edges of the given graph.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.EnforceMonotonicPathRestrictions">
      <summary>
            Specifies whether monotonic path restrictions (set with
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.MonotonicPathRestriction" />
            ) should be enforced.
            </summary>
      <remarks>
            Getter:<br />
            Returns whether monotonic path restrictions (set with
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.MonotonicPathRestriction" />
            ) should be enforced.
            <para />
            Setter:<br />
            Whether or not monotonic path restrictions (set with
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.MonotonicPathRestriction" />
            ) should be enforced.
            Enabling this option guarantees monotonic edge paths even if this results in additional overlaps between edges and nodes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.GridOrigin">
      <summary>A grid point coordinate used when grid routing is enabled.</summary>
      <remarks>Returns a grid point coordinate used when grid routing is enabled.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.GridRouting">
      <summary>Specifies whether or not to route edge segments on grid lines.</summary>
      <remarks>
            Specifies whether or not to route edge segments on grid lines.
            By default this feature is disabled, i.e., "free" routing is enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.GridSpacing">
      <summary>The grid spacing that is used when grid routing is enabled.</summary>
      <remarks>
            Specifies the grid spacing that is used when grid routing is enabled. By default a spacing of <c>2</c> is set,
            which is also the minimum allowed spacing.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.InnerPorts">
      <summary>
            Specifies whether edge ports (that do not have a strong port constraint set) should lie inside the node's bounding
            box or on the node's border.
            </summary>
      <remarks>
            Specifies whether edge ports (that do not have a strong port constraint
            set) should lie inside the node's bounding box or on the node's border.
            More specifically, "inside" means on the node's meridian for edges
            connecting to the left and right, and on the node's equator for edges
            connecting to the upper and lower side.
            <p>
            Default setting is <see langword="false" />.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.LocalCrossingMinimization">
      <summary>Specifies whether the local crossing minimization strategy is enabled.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not a local crossing minimization strategy should be
            applied.
            By default this feature is enabled.
            <para />
            Getter:<br />
            Returns whether the local crossing minimization strategy is enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.MinimumDistance">
      <summary>The minimum distance between edge segments.</summary>
      <remarks>
            Specifies the minimum distance between edge segments. By default a distance of <c>4</c> is set, which is also the
            minimum allowed distance.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.MinimumDistanceToNode">
      <summary>The minimum distance between edge segments and nodes.</summary>
      <remarks>Specifies the minimum distance between edge segments and nodes.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.MonotonicPathRestriction">
      <summary>The specified kind of monotonic path restrictions.</summary>
      <remarks>
            Getter:<br />
            Returns the specified kind of monotonic path restrictions.
            <para />
            Setter:<br />
            Specifies which kind of monotonic path restrictions should be applied.
            Possible values are
            <see cref="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.None" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.Vertical" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.Horizontal" />
            and
            <see cref="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.Both" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.Rerouting">
      <summary>Specifies whether rerouting bad edges is enabled.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to enable a further crossing minimization
            optimization based on rerouting edges that cross many edges.
            By default this feature is not enabled.
            Activating this feature only makes sense if the global crossing cost
            is set to a value greater an <c>0</c>.
            <para />
            Getter:<br />
            Returns whether rerouting bad edges is enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.RoutingStyle">
      <summary>The currently set routing style.</summary>
      <remarks>
            Setter:<br />
            Sets the preferred routing style for the edges to be routed. The default setting is
            <see cref="F:yWorks.yFiles.Layout.Router.RoutingStyle.Balanced" />
            .
            <para />
            Getter:<br />
            Returns the currently set routing style.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.SelectedEdgesDpKey">
      <summary>
            The <c>DataProvider</c> key to mark edges as
            <em>selected</em>.
            </summary>
      <exception cref="T:System.ArgumentException">if the specified key is <see langword="null" />.</exception>
      <remarks>
            Specifies the <c>DataProvider</c> key to mark edges as
            <em>selected</em>.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedEdgesDpKey" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.SelectedNodesDpKey">
      <summary>
            The <c>DataProvider</c> key to mark nodes as
            <em>selected</em>.
            </summary>
      <exception cref="T:System.ArgumentException">if the specified key is <see langword="null" />.</exception>
      <remarks>
            Specifies the <c>DataProvider</c> key to mark nodes as
            <em>selected</em>.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.LayouterKeys.SelectedNodesDpKey" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.SetGridOrigin(System.Int32,System.Int32)">
      <summary>Sets a grid point coordinate used when grid routing is enabled.</summary>
      <remarks>Sets a grid point coordinate used when grid routing is enabled. By default <c>(0, 0)</c> is set.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.SetProperty(System.String,System.Object)">
      <summary>For internal use only.</summary>
      <remarks>For internal use only.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.SphereOfAction">
      <summary>The currently set sphere of action specifier.</summary>
      <remarks>
            Setter:<br />
            Sets the edge (sub-)set to be routed.
            Default setting is
            <see cref="F:yWorks.yFiles.Layout.Router.SphereOfAction.RouteAllEdges" />
            .
            <para />
            Getter:<br />
            Returns the currently set sphere of action specifier.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.UseCustomBorderCapacity">
      <summary>Specifies whether a custom value for the capacity of the routing border is used.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not a custom value for the capacity of the routing
            border around the graph's bounding box should be applied.
            <p>
            Default setting is <see langword="false" />. </p>
            <para />
            Getter:<br />
            Returns whether a custom value for the capacity of the routing border is used.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter">
      <summary>This class represents an orthogonal edge router.</summary>
      <remarks>
            This class represents an orthogonal edge router. An orthogonal edge router is a layout algorithm that changes the
            coordinates of the edge paths in a way that the resulting layout of the edges is made up of vertical and horizontal
            segments only. The router does not change the location or the size of the nodes in a diagram in any way.
            <p>
            The edge router will not try to find a perfect route from source to edge like OrthogonalEdgeRouter does, but chooses
            the best path out of several fixed paths it can choose from. The best path out of these possible paths is determined
            by its cost. One can take influence on the costs by setting several cost factors. The distance, an edge will have
            from its source and target node is determined by setMinimumDistance(double).
            </p>
            <p>
            The edges whose paths are to be routed can be defined using method setSphereOfAction(byte)
            or binding a data provider to the input graph with key
            <see cref="F:yWorks.yFiles.Layout.Router.ChannelEdgeRouter.AffectedEdgesDpKey" />
            .
            Note: If the DataProvider is registered on the graph, it will determine all affected edges, regardless of the set
            sphere of action. So setting a sphere of action has lower priority than adding the specific DataProvider directly.
            </p>
            <p>
            By default all edges are routed according to their best paths and afterwards overlapping edges will be redistributed.
            This can be prevented by calling method setDistributeEdgesEnabled(boolean).
            </p>
            <p>
            ChannelEdgeRouter does also support grid routing setGridRoutingEnabled(boolean).Therefore
            the user can define the grid origin setGridOrigin(y.geom.YPoint) and the
            grid width setGridWidth(double).
            </p>
            <p>
            This edge router will obey strong and weak port constraints. It expects the port constraints to be bound to the input
            graph by the data provider keys
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
            . Furthermore, this class supports the more advanced port constraint
            concept of
            <see cref="T:yWorks.yFiles.Layout.PortCandidate" />
            s. It expects collections of port candidates to be bound to the input graph by the
            data provider keys
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.SourcePcListDpKey" />
            and
            <see cref="F:yWorks.yFiles.Layout.PortCandidate.TargetPcListDpKey" />
            .
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.AffectedEdgesDpKey">
      <summary>The <c>DataProvider</c> key, which determines the edges, that shall be routed by the algorithm.</summary>
      <remarks>
            Specifies the <c>DataProvider</c> key, which determines the edges, that shall be routed by the algorithm.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.DefaultAffectedEdgesDpKey" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.BendCost">
      <summary>The edge cost a bend inside an edge's path will cause.</summary>
      <remarks>
            Specifies the edge cost a bend inside an edge's path will cause. Used to find the best path out of the predefined paths
            the router can choose from. Default value is 1.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculateBendCost(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>
            Calculates the costs for all bends of the given path by simple multiplying
            all bends with the
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.BendCost">bend costs</see>
            .
            </summary>
      <param name="edge">the edge the penalty is calculated for.</param>
      <param name="path">the path this penalty is calculated for.</param>
      <param name="spc">the used source PortCandidate for this path.</param>
      <param name="tpc">the used target PortCandidate for this path.</param>
      <returns>the costs for all bends of this path</returns>
      <remarks>
            Calculates the costs for all bends of the given path by simple multiplying
            all bends with the
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.BendCost">bend costs</see>
            .
            <p>
            <b>Note:</b> Only bends are taken into account, not the source and target
            ports, that are also part of the given path.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCost(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>Calculates the edge cost of a possible edge path, to determine which path is the best (cheapest).</summary>
      <param name="edge">the edge whose cost to calculate.</param>
      <param name="path">the edge's path.</param>
      <param name="spc">the source port candidate chosen for this path.</param>
      <param name="tpc">the target port candidate chosen for this path.</param>
      <returns>the sum of all costs for this edge's path</returns>
      <remarks>Calculates the edge cost of a possible edge path, to determine which path is the best (cheapest).</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCrossingCosts(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>Calculates the overall crossing costs of the given path including edge crossings, edge overlaps and node crossings.</summary>
      <param name="edge">the edge the penalty is calculated for.</param>
      <param name="path">the path this penalty is calculated for.</param>
      <param name="spc">the used source PortCandidate for this path.</param>
      <param name="tpc">the used target PortCandidate for this path.</param>
      <returns>the overall crossing costs of the given path including edge crossings, edge overlaps and node crossings.</returns>
      <remarks>Calculates the overall crossing costs of the given path including edge crossings, edge overlaps and node crossings.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculateEdgeLength(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>Calculates the costs for the length of the given path.</summary>
      <param name="edge">the edge the penalty is calculated for.</param>
      <param name="path">the path this penalty is calculated for.</param>
      <param name="spc">the used source PortCandidate for this path.</param>
      <param name="tpc">the used target PortCandidate for this path.</param>
      <returns>the length costs of the given path between 0 and 1</returns>
      <remarks>
            Calculates the costs for the length of the given path.
            By default this cost is between 0 (short path) and 1 (long path) so this has very little impact on the
            overall costs.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculatePortCandidateCost(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>Calculates the costs for the chosen ports.</summary>
      <param name="edge">the edge the penalty is calculated for.</param>
      <param name="path">the path this penalty is calculated for.</param>
      <param name="spc">the used source PortCandidate for this path.</param>
      <param name="tpc">the used target PortCandidate for this path.</param>
      <returns>the costs for all bends of this path</returns>
      <remarks>
            Calculates the costs for the chosen ports. By default these costs are determined from set port
            candidates. If no PortCandidates have been set on the given edge, the cost is 0. If PortConstraints have been set
            for this edge, the cost is also 0.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CalculateSelfLoopSelfSidePenaltyCost(yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Algorithms.YList,yWorks.yFiles.Layout.PortCandidate,yWorks.yFiles.Layout.PortCandidate)">
      <summary>
            Calculates the extra penalty that is added to the paths cost if the edge is a selfloop and source and target
            ports have the same direction.
            </summary>
      <param name="edge">the edge the penalty is calculated for.</param>
      <param name="path">the path this penalty is calculated for.</param>
      <param name="spc">the used source PortCandidate for this path.</param>
      <param name="tpc">the used target PortCandidate for this path.</param>
      <returns>an extra penalty for paths</returns>
      <remarks>
            Calculates the extra penalty that is added to the paths cost if the edge is a selfloop and source and target
            ports have the same direction.
            By default this penalty is a bit more than adding another bend to the path so that patterns with different
            source and target directions are cheaper and thus preferred.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CheckGroupNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the group node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the group node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given group node object is zero.
            It is called by the
            <see cref="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method for each group node object in the input graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.CheckNodeSize(yWorks.yFiles.Layout.IGraphLayout,System.Object)">
      <summary>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            </summary>
      <param name="layout">a graph layout object.</param>
      <param name="node">the node object to test.</param>
      <exception cref="T:System.ArgumentException">thrown if the width/height of the node object is zero.</exception>
      <remarks>
            This method throws an
            <see cref="T:System.ArgumentException" />
            if the width/height of the given node object is zero.
            It is called by the
            <see cref="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            method for each node object in the input graph.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.DefaultAffectedEdgesDpKey">
      <summary>DataProvider key that can be used to determine which edges the edge router will route.</summary>
      <remarks>DataProvider key that can be used to determine which edges the edge router will route.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.EdgeCrossingCost">
      <summary>The edge cost an edge crossing will cause.</summary>
      <remarks>
            Specifies the edge cost an edge crossing will cause. Used to find the best path out of the predefined paths the
            router can choose from. Default value is 5.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.EdgeOverlapCost">
      <summary>The cost an edge overlap will cause.</summary>
      <remarks>
            Specifies the cost an edge overlap will cause. By default this edge router is used in conjunction with a segment
            distribution stage like
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage" />
            , so edge overlaps are wanted and
            thus should not cause any costs. Default value is therefore 0.
            If this edge router is used stand-alone, one can determine a higher cost to prevent edge overlaps.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridOrigin">
      <summary>The origin of the grid, which is used for grid routing if enabled.</summary>
      <remarks>
            Setter:<br />
            Sets the origin of the grid. Takes effect if grid routing is enabled
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridRoutingEnabled" />
            .
            Note that grid routing has lower priority than the minimum Distance setting
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.MinimumDistance" />
            .
            Thus it is possible that edges are not routed on the grid if there is not enough space between two borders. Default
            origin is at x = 0, y = 0
            <para />
            Getter:<br />
            Returns the origin of the grid, which is used for grid routing if enabled.
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridRoutingEnabled" />
            . Default origin is at x = 0, y = 0
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridRoutingEnabled">
      <summary>Specifies whether or not grid routing is enabled.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to use grid routing.
            Grid routing means edges are routed on a grid's lines only. The grid can be defined
            using method
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridOrigin" />
            and
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridWidth" />
            . Note that grid routing has
            lower priority than the minimum Distance setting
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.MinimumDistance" />
            . Thus it is possible that
            edges are not routed on the grid if there is not enough space between two borders.
            <p>
            Also, the edges source and target ports are not reassigned if they have fixed coordinates. Therefore, the first and
            last segments of an edge might not be routed on the grid. Use weak ports or assign coordinates that already lie on
            the grid for these ports, if grid routing is wanted.
            </p>
            By default grid routing is <b>not</b> enabled.
            <para />
            Getter:<br />
            Returns whether or not grid routing is enabled.
            By default grid routing is <b>not</b> enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridWidth">
      <summary>The grid width, that defines the space between two grid lines.</summary>
      <exception cref="T:System.ArgumentException">
            if the specified grid width is less than
            <c>2</c>.
            </exception>
      <remarks>
            Setter:<br />
            Sets the grid width of the grid on which edges shall be routed.
            Only takes effect if
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.GridRoutingEnabled">grid routing is enabled</see>
            .
            <p>Default value is <c>10.0</c>.</p>
            <para />
            Getter:<br />
            Returns the grid width, that defines the space between two grid lines.
            <p>Default value is <c>10.0</c></p>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.MinimumDistance">
      <summary>The minimum distance an edge will have to its source and target node.</summary>
      <remarks>Specifies the minimum distance an edge will have to its source and target node. Default value is 10.0.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.MonotonicPathRestriction">
      <summary>The specified kind of monotonic path restrictions.</summary>
      <remarks>
            Getter:<br />
            Returns the specified kind of monotonic path restrictions.
            <para />
            Setter:<br />
            Specifies which kind of monotonic path restrictions should be applied.
            Possible values are
            <see cref="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.None" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.Vertical" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.Horizontal" />
            and
            <see cref="F:yWorks.yFiles.Layout.Router.MonotonicPathRestriction.Both" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalPatternEdgeRouter.NodeCrossingCost">
      <summary>The node cost an edge node overlap will cause.</summary>
      <remarks>
            Specifies the node cost an edge node overlap will cause. Used to find the best path out of the predefined paths the
            router can choose from. Default value is 50.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage">
      <summary>This class can be used to distribute overlapping edge segments of orthogonally routed edges.</summary>
      <remarks>
            This class can be used to distribute overlapping edge segments of orthogonally routed edges. The edge segments will
            then be distributed in their so called channel according to the given settings. The channel in which the segments can
            be distributed is defined by the surrounding graph elements, which will form borderlines for the channel.
            <p />
            The distance between the distributed edge segments can be determined by method
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.PreferredDistance" />
            .
            <p />
            The edge segments can also be forced to be distributed on a given grid (
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridEnabled" />
            ) whose
            origin (
            <see cref="M:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.SetGridOffset(System.Double,System.Double)" />
            ) and grid width (
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridWidth" />
            ) can be set.
            <p />
            Note: this LayoutStage is not capable of moving nodes. If the set conditions like preferred distance or the grid width
            can not be satisfied, for example, because there is not enough space inside the channel, the set values will by
            default be adjusted (reduced). Concerning the grid, it will be divided by 2 until all segments will fit. The
            preferred distance will be adjusted so that the maximum possible distance near the given value will be taken. Also,
            segments that are directly at a node (source or target) will be distributed, so that they are placed equidistant
            all along the node's side.
            <p />
            Settings
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridWidthAdjustable" />
            and
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.PreferredDistanceAdjustable" />
            can be used to
            force the algorithm to distribute the edges with the exact given distances. If the segments will not fit into the
            given channel, they then will not be distributed at all. So there is a guarantee that they will match the settings if
            they are routed.
            <p />
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.LockFirstAndLastSegment" />
            can be used to guarantee that the first and last segment of an edge
            (connected to source or target), won't be distributed. So ports can easily be kept without setting explicit strong
            port constraints or fixed PortCandidates.
            <p />
            The algorithm will not distribute the segments, whose end connect to a node at a strong port constraint or fixed
            port candidate.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.AffectedEdgesDpKey">
      <summary>The DataProvider key, which determines the edges, that shall be distributed by the algorithm.</summary>
      <remarks>
            Specifies the DataProvider key, which determines the edges, that shall be distributed by the algorithm.
            <p>
            By default,
            <see cref="F:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.DefaultAffectedEdgesDpKey" />
            is used.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="F:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.DefaultAffectedEdgesDpKey">
      <summary>DataProvider key that can be used to determine which edges the distribution stage will route.</summary>
      <remarks>DataProvider key that can be used to determine which edges the distribution stage will route.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridEnabled">
      <summary>Specifies whether grid distribution is enabled or not.</summary>
      <remarks>
            Specifies whether grid distribution is enabled or not. If so, all segments will be distributed onto the grid. By
            default grid distribution is not enabled.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridOffsetX">
      <summary>The grid offset in x direction.</summary>
      <remarks>Returns the grid offset in x direction. by default this will be 0.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridOffsetY">
      <summary>The grid offset in y direction.</summary>
      <remarks>Returns the grid offset in y direction. by default this will be 0.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridWidth">
      <summary>The grid width that shall be used if grid distribution is enabled.</summary>
      <remarks>Specifies the grid width that shall be used if grid distribution is enabled. By default the grid width is 10.0.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.GridWidthAdjustable">
      <summary>
            Specifies whether or not the algorithm is allowed to reduce the grid width,
            if segments cannot be distributed using the previously given grid width.
            </summary>
      <remarks>
            Specifies whether or not the algorithm is allowed to reduce the grid width,
            if segments cannot be distributed using the previously given grid width.
            The algorithm will divide the given grid width by 2 as long as the segments
            will not fit and thus will lead to nicer results than taking some other value.
            Note: The grid width will only be adjusted for segments that cannot keep
            the originally set grid width.
            <p>
            By default, the algorithm is allowed to reduce the grid width.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.LockFirstAndLastSegment">
      <summary>Specifies whether the first and last segment of an edge (connected to source or target), will be distributed.</summary>
      <remarks>
            Getter:<br />
            Returns whether the first and last segment of an edge (connected to source or target), will be distributed.
            Defaults to <see langword="false" />, i.e. first and last segments are not locked.
            <para />
            Setter:<br />
            Determines whether the first and last segment of an edge (connected to source or target), will be distributed. So
            ports can easily be kept without setting explicit strong port constraints or fixed PortCandidates.
            Defaults to <see langword="false" />, i.e. first and last segments are not locked.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.PreferredDistance">
      <summary>The preferred distance, segments shall have to each other and to the channel's border.</summary>
      <remarks>
            Specifies the preferred distance, segments shall have to each other and to the channel's border.
            <p>
            Default value is <c>10.0</c>.
            </p><p>
            Note: if
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.PreferredDistanceAdjustable" />
            is set to <see langword="true" /> (which is the default), the
            preferred distance might be adjusted so that the maximum possible distance near the given value will be taken. This
            happens if the channel is not big enough to fit in all segments with the desired preferred distance.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.PreferredDistanceAdjustable">
      <summary>
            What happens if the preferred distance can not be kept, because there is not enough space for the segments
            to be distributed in that distance.
            </summary>
      <remarks>
            Determines what happens if the preferred distance can not be kept, because there is not enough space for the
            segments to be distributed in that distance. If set to <see langword="true" /> the algorithm is allowed to reduce the
            distance to the next best value, that is possible. If set to <see langword="false" /> the algorithm will not at all
            distribute those segments. By default the setting is <see langword="true" /> and therefore segments will be distributed.
            Note: Preferred distances will not be kept for segments connecting to nodes (first and last segment of an edge).
            The segments are distributed equidistant all along the node side, thus may lead to bigger distances between
            segments.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.OrthogonalSegmentDistributionStage.SetGridOffset(System.Double,System.Double)">
      <summary>Can be used to set the grid origin.</summary>
      <param name="offsetX">the offset in x direction.</param>
      <param name="offsetY">the offset in y direction</param>
      <remarks>Can be used to set the grid origin. By default the offset is (0, 0), so there is no offset.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.PartitionGridRouterStage">
      <summary>
            Layout stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            that should be
            applied when routing edges in a partition grid.
            </summary>
      <remarks>
            Layout stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            that should be
            applied when routing edges in a partition grid.
            Note: This stage can only be applied if all nodes are contained within a single partition grid, i.e., edges can
            never cross the border of the partition grid.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.PartitionGridRouterStage.#ctor">
      <summary>Creates a new instance of this class.</summary>
      <remarks>Creates a new instance of this class.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.PartitionGridRouterStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of this class.</summary>
      <param name="coreLayouter">
            the core layouter invoked by this stage.
            The coreLayouter must contain an instance of
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            in its layout pipeline.
            </param>
      <remarks>Creates a new instance of this class.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.PartitionGridRouterStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Router.PartitionGridRouterStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Main layout routine.</summary>
      <remarks>Main layout routine.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.PatchRouterStage">
      <summary>
            Performance optimization stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            .
            </summary>
      <remarks>
            Performance optimization stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            . This layout stage decomposes
            the input graph for the orthogonal edge router into several smaller graphs
            on each of which the edge router will perform its action separately, hence
            speeding up execution time and reducing peak memory consumption.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.PatchRouterStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of PatchRouterStage.</summary>
      <param name="coreLayouter">
            the core layouter invoked by this stage. The coreLayouter must
            contain an instance of
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            its layout pipeline.
            </param>
      <remarks>Creates a new instance of PatchRouterStage.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.PatchRouterStage.ActivationThreshold">
      <summary>The activation threshold for this class.</summary>
      <remarks>
            Specifies the activation threshold for this class. The patch router will perform its optimization
            step only if the sum of the edges and nodes of the input graph is bigger than the activation threshold.
            By default the threshold value is set to 1000.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.PatchRouterStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Router.PatchRouterStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns orthogonal edge paths to the edges of a big graph, efficiently.</summary>
      <remarks>
            Assigns orthogonal edge paths to the edges of a big graph, efficiently. Note that this
            stage will only have an optimizing effect if the graph is bigger than the
            activation threshold and the sphere of action of the core router includes all edges.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage">
      <summary>
            Performance optimization stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            .
            </summary>
      <remarks>
            Performance optimization stage for
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            .
            This layout stage is applicable when only a subset of the edges
            in the input graph should be
            routed orthogonally.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>Creates a new instance of ReducedSphereOfActionStage.</summary>
      <param name="coreLayouter">
            the core layouter invoked by this stage. The coreLayouter must
            contain an instance of
            <see cref="T:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter" />
            its layout pipeline.
            </param>
      <remarks>Creates a new instance of ReducedSphereOfActionStage.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage.ActivationThreshold">
      <summary>The activation threshold for this class.</summary>
      <remarks>
            Specifies the activation threshold for this class. This stage will perform its optimization
            step only if the sum of the edges and nodes of the input graph is bigger than the activation threshold.
            By default the threshold value is set to 200.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Router.ReducedSphereOfActionStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns orthogonal edge paths to the selected edges of a graph, efficiently.</summary>
      <remarks>
            Assigns orthogonal edge paths to the selected edges of a graph, efficiently. Note that this
            stage will only have an optimizing effect if not all edges of the graph
            should be routed.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.RoutingStyle">
      <summary>Routing style specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.RoutingStyle.Adhoc">
      <summary>Routing style specifier. Edge segments are drawn ad hoc, i.e., rather crude.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.RoutingStyle.Shortpath">
      <summary>Routing style specifier. Edge segments are drawn the short way, i.e., with the global way of the edge in mind.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.RoutingStyle.Prefermiddle">
      <summary>
            Routing style specifier. Edge segments are drawn with the most distance to already known obstacles such as nodes or
            other edge segments.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.RoutingStyle.Balanced">
      <summary>
            Routing style specifier. Similar to
            <see cref="F:yWorks.yFiles.Layout.Router.RoutingStyle.Prefermiddle" />
            for the two end segments and segments between bends
            of different directions. Segments between bends of the same direction (u-shaped turns) are drawn the short way.
            This style achieves a well-balanced routing and is used by default.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.Scope" />
    <member name="F:yWorks.yFiles.Layout.Router.Scope.All">
      <summary>Scope constant - used for routing all edges in the graph.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.Scope.Subset">
      <summary>
            Scope constant - used for routing only a subset of edges. This subset has to be specified by registering an
            appropriate
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Router.SnapOuterPortsToNodeBorderStage">
      <summary>This LayoutStage will move edge ports, that are outside the corresponding nodes border, to the border.</summary>
      <remarks>
            This LayoutStage will move edge ports, that are outside the corresponding nodes border, to the border.
            Thus guarantees ports are not outside of nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.SnapOuterPortsToNodeBorderStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Router.SnapOuterPortsToNodeBorderStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Router.SnapOuterPortsToNodeBorderStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="M:yWorks.yFiles.Layout.Router.SnapOuterPortsToNodeBorderStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="T:yWorks.yFiles.Layout.Router.SphereOfAction">
      <summary>Sphere of action specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.SphereOfAction.RouteAllEdges">
      <summary>Sphere of action specifier. Route all edges of the input graph.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.SphereOfAction.RouteSelectedEdges">
      <summary>
            Sphere of action specifier. Route only selected edges of the input graph.
            The selection state of an edge is determined by a boolean value returned
            by the data provider associated with the data provider key
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.SelectedEdgesDpKey" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Router.SphereOfAction.RouteEdgesAtSelectedNodes">
      <summary>
            Sphere of action specifier. Route only edges connected to selected nodes.
            The selection state of a node is determined by a boolean value returned
            by the data provider associated with the data provider key
            <see cref="P:yWorks.yFiles.Layout.Router.OrthogonalEdgeRouter.SelectedNodesDpKey" />
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Transformer.GraphTransformer">
      <summary>Provides geometric transforms for (sub-)graphs.</summary>
      <remarks>
            Provides geometric transforms for (sub-)graphs.
            This module provides the following kinds of geometric transforms
            on graphs or subgraphs.
            <ul>
            <li>Mirroring along X-axis</li>
            <li>Mirroring along Y-axis</li>
            <li>Rotation by angle</li>
            <li>Scaling by factor. (Node size scaling optional)</li>
            <li>Translating</li>
            </ul>
            <p>
            Here is an sample output of the layouter that rotated the inner
            nine nodes of the grid by 45 degrees.
            </p>
            <center><img src="doc-files/y.layout.transformer.GraphTransformer.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.#ctor">
      <summary>Creates a new instance of graph transformer.</summary>
      <remarks>Creates a new instance of graph transformer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.ApplyBestFitRotationAngle(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double)">
      <summary>
            Performs a rotation of the given graph such that its
            resulting bounding box (approximately) fits best to
            the given area bounds.
            </summary>
      <remarks>
            Performs a rotation of the given graph such that its
            resulting bounding box (approximately) fits best to
            the given area bounds.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.BestFitRotationEnabled">
      <summary>Specifies whether or not the best fit rotation angle will be applied.</summary>
      <remarks>
            Setter:<br />
            Set whether or not to choose a best fit rotation angle instead of the
            one set by
            <see cref="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.RotationAngle" />
            .  Also, to apply the best fit rotation
            angle, the operation type of this layouter must be set to
            <see cref="F:yWorks.yFiles.Layout.Transformer.OperationType.Rotate" />
            .
            <p>
            Use
            <see cref="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.SetPreferedLayoutSize(System.Double,System.Double)" />
            to specify the preferred
            aspect ratio of the resulting layout.
            </p>
            <para />
            Getter:<br />
            Returns whether or not the best fit rotation angle will be applied.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns always <see langword="true" />.</summary>
      <remarks>Returns always <see langword="true" />.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.CoreLayouter">
      <summary>The core layouter.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Performs the selected transformation.</summary>
      <remarks>Performs the selected transformation.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.FindBestFitRotationAngle(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double)">
      <summary>
            Returns a rotation angle that, if applied to the given graph,
            would minimize the zoom-level needed to display the graph in
            an area of the given dimension.
            </summary>
      <remarks>
            Returns a rotation angle that, if applied to the given graph,
            would minimize the zoom-level needed to display the graph in
            an area of the given dimension.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.Operation">
      <summary>The transformation operation this layouter performs.</summary>
      <remarks>
            Specifies the transformation operation this layouter performs.
            <p>
            By default the <c>SCALE</c> operation is set.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.RotationAngle">
      <summary>The angle of rotation.</summary>
      <remarks>
            Specifies the angle of rotation. The angle must be given in degrees.
            This feature is only meaningful for the <c>ROTATE</c> operation.
            <p>
            By default the rotation angle is <c>0.0</c>.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.ScaleFactor">
      <summary>
            The uniform scaling factor used for the <c>SCALE</c>
            operation.
            </summary>
      <remarks>
            Sets the uniform scaling factor used for the <c>SCALE</c>
            operation.
            <p>
            By default the scaling factor is set to <c>1.0</c>
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.ScaleFactorX">
      <summary>The scaling factor used for the x-coordinate.</summary>
      <remarks>Returns the scaling factor used for the x-coordinate.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.ScaleFactorY">
      <summary>The scaling factor used for the y-coordinate.</summary>
      <remarks>Returns the scaling factor used for the y-coordinate.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.ScaleNodeSize">
      <summary>Specifies whether or not to scale node sizes.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to scale node sizes when performing the
            <c>SCALE</c> operation.
            <p>
            By default this feature is disabled.
            </p>
            <para />
            Getter:<br />
            Returns whether or not to scale node sizes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.ScaleToRect(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Util.Geom.Rectangle)">
      <summary>
            Scales the coordinates of the given graph in such a way
            that the resulting bounding box of the graph approximately equals
            the bounds of the given rectangle.
            </summary>
      <remarks>
            Scales the coordinates of the given graph in such a way
            that the resulting bounding box of the graph approximately equals
            the bounds of the given rectangle.
            <p>
            Note that this operation won't have any effects, if there is
            only one node in the graph or if there are nodes that are bigger
            than the requested bounding box size.
            </p>
            <p>
            The x- and y-scaling factors are returned
            in a double array of size 2.
            The first value of the array is the x-scaling factor
            that has was used and the second value is the y-scaling
            factor.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.SetMaximalBounds(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double,System.Double,System.Double)">
      <summary>Assures that the given graph fits into the given rectangular bounds.</summary>
      <param name="graph">the graph to modify</param>
      <param name="x">the upper left x coordinate of the bounds</param>
      <param name="y">the upper left y coordinate of the bounds</param>
      <param name="w">the width of the bounds</param>
      <param name="h">the height of the bounds</param>
      <remarks>
            Assures that the given graph fits into the given rectangular bounds.
            If the bounding box fits in the rectangle, nothing is done.
            Otherwise the graph is scaled and optionally moved to fit.
            This algorithm does not modify the node's sizes.
            Note that this operation won't have any effects,
            if there are nodes that are bigger
            than the requested bounding box size.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.SetPreferedLayoutSize(System.Double,System.Double)">
      <summary>Sets the preferred layout size for this layouter.</summary>
      <remarks>Sets the preferred layout size for this layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.SetScaleFactors(System.Double,System.Double)">
      <summary>
            Sets the scaling factors for the x-coordinates and y-coordinates
            used for the <c>SCALE</c> operation.
            </summary>
      <remarks>
            Sets the scaling factors for the x-coordinates and y-coordinates
            used for the <c>SCALE</c> operation.
            <p>
            By default the scaling factors are set to <c>1.0</c>
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphTransformer.Translate(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double)">
      <summary>Translates the layout coordinates by the vector <c>(dx,dy)</c>.</summary>
      <remarks>Translates the layout coordinates by the vector <c>(dx,dy)</c>.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.TranslateX">
      <summary>The horizontal translation distance.</summary>
      <remarks>
            Specifies the horizontal translation distance. A positive value
            means the graph is moved to the right; a negative value means the graph
            is moved to the left. Defaults to <c>0</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Transformer.GraphTransformer.TranslateY">
      <summary>The vertical translation distance.</summary>
      <remarks>
            Specifies the vertical translation distance. A positive value
            means the graph is moved downwards; a negative value means the graph
            is moved upwards. Defaults to <c>0</c>.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Transformer.GraphZoomer">
      <summary>
            This class contains algorithms which allow for zooming parts of a diagram only
            in a so-called fish-eye (radial) style.
            </summary>
      <remarks>
            This class contains algorithms which allow for zooming parts of a diagram only
            in a so-called fish-eye (radial) style. This type of zoom however will not
            introduce new bends for edges but will move the node centers and bends only.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.#ctor">
      <summary>Creates a new instance of <c>GraphZoomer</c>.</summary>
      <remarks>Creates a new instance of <c>GraphZoomer</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.AddRadialZoom(yWorks.yFiles.Algorithms.Geometry.YPoint,System.Double,System.Double,System.Double)">
      <summary>
            Adds a zoom operation to the list of operations to be performed on the graph
            during the doLayout phase.
            </summary>
      <param name="center">the center of the zoom</param>
      <param name="innerRadius">
            the radius of the circle around the center inside which the zoom level is
            constantly set to <c>zoomFactor</c></param>
      <param name="outerRadius">
            the radius of the outer circle around the center outside of which the zoomFactor
            should be unchanged. This value must be greater than innerRadius
            </param>
      <param name="zoomFactor">the zoomFactor inside the inner circle</param>
      <remarks>
            Adds a zoom operation to the list of operations to be performed on the graph
            during the doLayout phase.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.AddRectangularZoom(yWorks.yFiles.Algorithms.Geometry.YPoint,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Adds a zoom operation to the list of operations performed during the doLayout
            phase.
            </summary>
      <param name="center">the center of the zoom</param>
      <param name="innerRadius">
            the radius of the rectangular shape around the center inside which the zoom level is
            constantly set to <c>zoomFactor</c></param>
      <param name="outerRadius">
            the radius of the outer rectangular shape around the center outside of which the zoomFactor
            should be unchanged. This value must be greater than innerRadius
            </param>
      <param name="zoomFactor">the zoomFactor inside the inner rectangle</param>
      <remarks>
            Adds a zoom operation to the list of operations performed during the doLayout
            phase. This performs a zoom on a rectangular shape using the given radii and the
            ratio defining the rectangle.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true" /> iff the given graph can be laid
            out by this algorithm.
            </summary>
      <remarks>
            Returns <see langword="true" /> iff the given graph can be laid
            out by this algorithm. Calling <c>doLayout</c> with
            the given graph as it's argument will only success if
            this method returns <see langword="true" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
      <remarks>Assigns a new graph layout to the given layout graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.Zoom(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Layout.Transformer.GraphZoomer.IZoom)">
      <summary>Convenience method which applies a custom zoom to the graph</summary>
      <remarks>Convenience method which applies a custom zoom to the graph</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.ZoomRadial(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>Convenience method which applies a radial zoom to the graph</summary>
      <remarks>Convenience method which applies a radial zoom to the graph</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.ZoomRectangular(yWorks.yFiles.Layout.LayoutGraph,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>Convenience method which applies a rectangular zoom to the graph</summary>
      <remarks>Convenience method which applies a rectangular zoom to the graph</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Transformer.GraphZoomer.IZoom">
      <summary>This interface can be implemented for custom zoom types.</summary>
      <remarks>This interface can be implemented for custom zoom types.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Transformer.GraphZoomer.IZoom.ModifyPosition(yWorks.yFiles.Util.Geom.Point2D.Double)">
      <summary>
            This method take a Point2D as an argument, modifies it according to its
            zoom policy and writes the modification back to the argument.
            </summary>
      <remarks>
            This method take a Point2D as an argument, modifies it according to its
            zoom policy and writes the modification back to the argument.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Transformer.OperationType">
      <summary>Operation type constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Transformer.OperationType.MirrorXaxis">
      <summary>
            Operation type constant. Specifies that the graph should be
            mirrored along the x-axis.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Transformer.OperationType.MirrorYaxis">
      <summary>
            Operation type constant. Specifies that the graph should be
            mirrored along the y-axis.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Transformer.OperationType.Rotate">
      <summary>
            Operation type constant. Specifies that the graph should be
            rotated.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Transformer.OperationType.Scale">
      <summary>
            Operation type constant. Specifies that the graph should be
            scaled.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Transformer.OperationType.Translate">
      <summary>
            Operation type constant. Specifies that the graph should be
            translated.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.AbstractNodePlacer">
      <summary>
            Utility class that serves as a basis for implementations of the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface.
            </summary>
      <remarks>
            Utility class that serves as a basis for implementations of the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface. It provides convenience methods for
            often used sub tasks during a layout.
            Subclasses need to override the two abstract methods only.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.#ctor">
      <summary>Creates a new instance of AbstractNodePlacer</summary>
      <remarks>Creates a new instance of AbstractNodePlacer</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.Clone">
      <summary>Overwritten to support cloning.</summary>
      <returns>an exact copy of this instance</returns>
      <remarks>Overwritten to support cloning.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an optional Processor for pre- and post-processing.</summary>
      <param name="layouter" />
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
      <remarks>Creates an optional Processor for pre- and post-processing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface
            </returns>
      <remarks>
            This method must be implemented by subclasses. It assigns a connector shape
            direction to each child.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method initializes internal data structures and then uses the
            abstract method to determine the child node connector directions.
            </summary>
      <param name="localRoot">the local root node</param>
      <param name="connectorMap">the map that will be used to store the values</param>
      <remarks>
            This method initializes internal data structures and then uses the
            abstract method to determine the child node connector directions.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.GetNodeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Convenience method that queries the DataProvider for the shape of a single
            node as a SubtreeShape instance.
            </summary>
      <param name="node">the node whose shape will be returned in the form of a SubtreeShape instance</param>
      <returns>an instance that can be modified</returns>
      <remarks>
            Convenience method that queries the DataProvider for the shape of a single
            node as a SubtreeShape instance. This instance can be used to modify it and
            return it in the main placeSubtree method. <br />
            This method can be called during the execution of
            <see cref="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.GetSubtreeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Convenience method that queries the DataProvider for a SubtreeShape.</summary>
      <param name="node">the root node whose subtree shape will be returned in the form of a SubtreeShape instance</param>
      <returns>an instance that can be modified</returns>
      <remarks>
            Convenience method that queries the DataProvider for a SubtreeShape. <br />
            This method can be called during the execution of
            <see cref="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)" />
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.graph">
      <summary>The graph instance this class is working on</summary>
      <remarks>The graph instance this class is working on</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>
            This method initializes the local data structures and then delegates the work
            to the abstract variant.
            </summary>
      <remarks>
            This method initializes the local data structures and then delegates the work
            to the abstract variant.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main placeSubtree method that must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
      <remarks>The main placeSubtree method that must be implemented by subclasses.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer">
      <summary>
            This is an abstract base class for NodePlacers that supports rotations.<br />
            "Supporting rotation" means that the NodePlacers only implement the default direction (e.g.
            </summary>
      <remarks>
            This is an abstract base class for NodePlacers that supports rotations.<br />
            "Supporting rotation" means that the NodePlacers only implement the default direction (e.g. bottom-down).
            The other directions are calculated using the modification matrix within the constructor.<br />
            But take care! Using rotatable NodePlacers contains some pitfalls. Especially calculations must be aware of
            that. Especially operations on
            <see cref="T:yWorks.yFiles.Algorithms.Geometry.BorderLine" />
            s should not be called directly (e.g. mergeWithMin, mergeWithMax).
            Use the corresponding methods on AbstractRotatableNodePlacer instead.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Default constructor.</summary>
      <param name="modificationMatrix">the translation for the NodePlacer</param>
      <remarks>
            Default constructor. Instantiates a new instance with the
            given modification matrix.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.CreateComparator" />
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.createdChildren">
      <summary>List containing the created children</summary>
      <remarks>List containing the created children</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an optional Processor for pre- and post-processing.</summary>
      <param name="layouter" />
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
      <remarks>Creates an optional Processor for pre- and post-processing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.CreateRootNodeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Convenience method that queries the DataProvider for the shape of a single node as a SubtreeShape instance.</summary>
      <param name="node">the node whose shape will be returned in the form of a SubtreeShape instance</param>
      <returns>an instance that can be modified</returns>
      <remarks>
            Convenience method that queries the DataProvider for the shape of a single node as a SubtreeShape instance. This
            instance can be used to modify and return it in the main placeSubtree method. <br />
            This method can only be called during the execution of
            <see cref="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.CreateSubtreeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Convenience method that queries the DataProvider for a SubtreeShape.</summary>
      <param name="node">the root node whose subtree shape will be returned in the form of a SubtreeShape instance</param>
      <returns>an instance that can be modified</returns>
      <remarks>
            Convenience method that queries the DataProvider for a SubtreeShape. <br />
            This method can only be called during the execution of
            <see cref="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface
            </returns>
      <remarks>This method must be implemented by subclasses. It is used to assigns a connector shape direction to each child.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method initializes internal data structures, then uses the abstract method
            <see cref="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)" />
            to determine the child node connector directions.
            </summary>
      <param name="localRoot">the local root node</param>
      <param name="connectorMap">the map that will be used to store the values</param>
      <remarks>
            This method initializes internal data structures, then uses the abstract method
            <see cref="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)" />
            to determine the child node connector directions.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.GetPortConstraint(yWorks.yFiles.Algorithms.Node)">
      <summary>Lookup method to get the PortConstraint for the local root translated.</summary>
      <param name="localRoot">the local root</param>
      <returns>
            the PortConstraint for the local root. The PortConstraint is translated based on the
            actual modification matrix.
            </returns>
      <remarks>Lookup method to get the PortConstraint for the local root translated.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.GetSourcePointAbs(yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Translates the absolute source point of the given edge to the "view coordinates" (translated by
            the modification matrix)
            </summary>
      <param name="edge">the source point for is returned</param>
      <returns>the translated absolute source point for the given edge and the actual modification matrix</returns>
      <remarks>
            Translates the absolute source point of the given edge to the "view coordinates" (translated by
            the modification matrix)
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.graph">
      <summary>The graph instance this class is working on</summary>
      <remarks>The graph instance this class is working on</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.modificationMatrix">
      <summary>The active modification matrix.</summary>
      <remarks>The active modification matrix.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.ModificationMatrix">
      <summary>The actual modification matrix</summary>
      <remarks>The actual modification matrix</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.nodeShapeProvider">
      <summary>The actual node shape provider</summary>
      <remarks>The actual node shape provider</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>This method initializes the local data structures and then delegates the work to the abstract variant.</summary>
      <remarks>This method initializes the local data structures and then delegates the work to the abstract variant.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
      <remarks>This method must be implemented by subclasses.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Spacing">
      <summary>
            The spacing between subtrees this <c>NodePlacer</c> is
            arranging.
            </summary>
      <remarks>
            Specifies the spacing between subtrees this <c>NodePlacer</c> is
            arranging.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.subtreeShapeProvider">
      <summary>The actual subtree shape provider</summary>
      <remarks>The actual subtree shape provider</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.TranslateDirectionToModel(yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>Translates a "real" direction into a directionModel direction</summary>
      <param name="realDirection">the "real" direction</param>
      <returns>the translated direction</returns>
      <remarks>Translates a "real" direction into a directionModel direction</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.TranslateDirectionToReal(yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>Translates a modelDirectionModel into the "real" directionModel</summary>
      <param name="modelDirection">the model direction</param>
      <returns>the translated model direction</returns>
      <remarks>Translates a modelDirectionModel into the "real" directionModel</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.TranslatePoint(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix,yWorks.yFiles.Algorithms.Geometry.YPoint)">
      <summary>Translates a "real world point" to a "model point"</summary>
      <param name="modificationMatrix">the matrix to apply</param>
      <param name="realWorldPoint">the point with the coordinates from the real world</param>
      <returns>the model point</returns>
      <remarks>Translates a "real world point" to a "model point"</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix">
      <summary>
            Instances of this class may be used to configure the
            <see cref="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer" />
            .
            </summary>
      <remarks>
            Instances of this class may be used to configure the
            <see cref="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer" />
            .
            The possible transformations are:
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Default" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Rot90" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Rot180" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Rot270" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirHor" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirVert" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirHorRot90" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirVertRot90" />
            </li>
            </ul>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Available" />
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Default">
      <summary>no transformation</summary>
      <remarks>no transformation</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.EqualValues(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Compares the values of the actual matrix with the values of the given matrix</summary>
      <param name="result">the given matrix</param>
      <returns>true if all values are the same, false otherwise</returns>
      <remarks>Compares the values of the actual matrix with the values of the given matrix</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirHor">
      <summary>mirror horizontally</summary>
      <remarks>mirror horizontally</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirHorRot90">
      <summary>mirror horizontally and rotate by 90 degrees counter-clockwise</summary>
      <remarks>mirror horizontally and rotate by 90 degrees counter-clockwise</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirVert">
      <summary>mirror vertically</summary>
      <remarks>mirror vertically</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.MirVertRot90">
      <summary>mirror vertically and rotate by 90 degrees counter-clockwise</summary>
      <remarks>mirror vertically and rotate by 90 degrees counter-clockwise</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Multiply(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Multiplies this matrix with another matrix.</summary>
      <param name="other">the other matrix</param>
      <returns>the product of this and the other matrix</returns>
      <remarks>Multiplies this matrix with another matrix.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Rot180">
      <summary>rotation by 180 degrees</summary>
      <remarks>rotation by 180 degrees</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Rot270">
      <summary>rotation by 270 degrees counter-clockwise</summary>
      <remarks>rotation by 270 degrees counter-clockwise</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Rot90">
      <summary>rotation by 90 degrees counter-clockwise</summary>
      <remarks>rotation by 90 degrees counter-clockwise</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.ToString">
      <summary>Returns a String representation of this matrix.</summary>
      <returns>a String representing this matrix</returns>
      <remarks>Returns a String representation of this matrix.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment">
      <summary>This class represents the horizontal alignment of the root node.</summary>
      <remarks>
            This class represents the horizontal alignment of the root node.
            There are several implementation that may be used:
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Center" />
            : Placement in the center</li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.CenterOverChildren" />
            : Placement in the center of the direct children</li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Leading" />
            : Placement on the left of the children.</li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Trailing" />
            : Placement on the right of the children</li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Left" />
            : Left alignment of root and children</li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Right" />
            : Right alignment of root and children</li>
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment" /> class</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.All" />
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Center">
      <summary>Horizontal alignment at the center.</summary>
      <remarks>Horizontal alignment at the center.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.CenterOverChildren">
      <summary>Horizontal alignment at the center.</summary>
      <remarks>Horizontal alignment at the center. Only the shapes of the children are respected (not of the grandchildren).</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.GetBounds(yWorks.yFiles.Util.IList)">
      <summary>Calculates the bounds of a list of shapes.</summary>
      <param name="shapes">the list of shapes the bounds shall be calculated of.</param>
      <returns>the bounds around all shapes in the list.</returns>
      <remarks>Calculates the bounds of a list of shapes.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Leading">
      <summary>Horizontal alignment at the left side of the children</summary>
      <remarks>Horizontal alignment at the left side of the children</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Left">
      <summary>Horizontal alignment at the left.</summary>
      <remarks>Horizontal alignment at the left.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Median">
      <summary>Horizontal alignment at the median.</summary>
      <remarks>Horizontal alignment at the median.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.PlaceParentHorizontal(yWorks.yFiles.Layout.Tree.SubtreeShapeRotated,yWorks.yFiles.Util.IList,yWorks.yFiles.Util.Geom.Rectangle2D,System.Double)">
      <summary>This method moves the rootShape to the right position relative to the children's shapes.</summary>
      <param name="rootShape">the shape of the root node that is moved</param>
      <param name="shapes">list of shapes of the children nodes</param>
      <param name="shapeBounds">accumulated shapes of all children's shapes</param>
      <param name="spacing">the spacing that should be used.</param>
      <remarks>
            This method moves the rootShape to the right position relative to the children's shapes. The movement should
            only be done on the X-axis (horizontally).
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Right">
      <summary>Horizontal alignment at the right.</summary>
      <remarks>Horizontal alignment at the right.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment.Trailing">
      <summary>Horizontal alignment at the right side of the children.</summary>
      <remarks>Horizontal alignment at the right side of the children.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ARNodePlacer">
      <summary>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            and implements a
            sophisticated
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            .
            </summary>
      <remarks>
            This class is used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            and implements a
            sophisticated
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            . Subtrees are placed so that the overall
            subtree layout's aspect ratio will be close to a given aspect ratio.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARNodePlacer.#ctor">
      <summary>
            Creates a new instance of ARNodePlacer with default orientation (vertical),
            aspect ratio (1.0d), fill style (
            <see cref="F:yWorks.yFiles.Layout.Tree.FillStyle.Leading" />
            ),
            and default distances (<c>40.0d</c>).
            </summary>
      <remarks>
            Creates a new instance of ARNodePlacer with default orientation (vertical),
            aspect ratio (1.0d), fill style (
            <see cref="F:yWorks.yFiles.Layout.Tree.FillStyle.Leading" />
            ),
            and default distances (<c>40.0d</c>).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARNodePlacer.#ctor(System.Boolean,System.Double,yWorks.yFiles.Layout.Tree.FillStyle,System.Double,System.Double)">
      <summary>
            Creates a new instance of ARNodePlacer with given orientation
            and distances.
            </summary>
      <param name="horizontal">
        <see langword="true" /> for horizontal row mode</param>
      <param name="horizontalDistance">horizontal distance between adjacent elements</param>
      <param name="verticalDistance">vertical distance between adjacent elements</param>
      <param name="aspectRatio">the aspectRatio, this instance should try to obey</param>
      <param name="fillStyle">a fill style constant describing the node distribution</param>
      <remarks>
            Creates a new instance of ARNodePlacer with given orientation
            and distances.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARNodePlacer.AspectRatio">
      <summary>The preferred aspect ratio.</summary>
      <remarks>Specifies the preferred aspect ratio.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARNodePlacer.FillStyle">
      <summary>The fill style.</summary>
      <remarks>
            Specifies the fill style. The byte constant defines how nodes should
            be distributed within their lanes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARNodePlacer.Horizontal">
      <summary>
            Specifies whether this instance is configured to create horizontal
            rows of child nodes.
            </summary>
      <remarks>
            Specifies whether this instance is configured to create horizontal
            rows of child nodes.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARNodePlacer.HorizontalDistance">
      <summary>
            The horizontal distance this NodePlacer should use for the
            arrangement of the elements.
            </summary>
      <remarks>
            Specifies the horizontal distance this NodePlacer should use for the
            arrangement of the elements.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main placeSubtree method that must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARNodePlacer.VerticalDistance">
      <summary>
            The vertical distance this NodePlacer should use for the
            arrangement of the elements.
            </summary>
      <remarks>
            Specifies the vertical distance this NodePlacer should use for the
            arrangement of the elements.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ARTreeLayouter">
      <summary>
            This tree layouter tries to generate compact tree layouts with a certain aspect
            ratio.
            </summary>
      <remarks>
            This tree layouter tries to generate compact tree layouts with a certain aspect
            ratio. The ratio can be specified for each subtree.
            <p />
            Here is a sample layout output (using an aspect ratio of 1 by 2)
            <p />
            <center><img src="doc-files/y.layout.tree.ARTreeLayouter.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.#ctor">
      <summary>Initializes a new instance of the ARTreeLayouter class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.AspectRatio">
      <summary>The preferred aspect ratio for this <c>ARTreeLayouter</c>.</summary>
      <remarks>Specifies the preferred aspect ratio for this <c>ARTreeLayouter</c>.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.BendDistance">
      <summary>The preferred distance between any two bends of an edge.</summary>
      <remarks>
            Specifies the preferred distance between any two bends of an edge.
            Additionally, the preferred bend distance governs the distance between the
            first and last edges and the corresponding ports.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>The core layouter can layout trees.</summary>
      <remarks>The core layouter can layout trees.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.Comparator">
      <summary>
            The
            <see cref="T:System.Collections.IComparer" />
            that will be used
            to sort the
            <see cref="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">outgoing edges</see>
            of each local root in the tree before they are being arranged.
            </summary>
      <remarks>
            Specifies the
            <see cref="T:System.Collections.IComparer" />
            that will be used
            to sort the
            <see cref="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">outgoing edges</see>
            of each local root in the tree before they are being arranged.
            Note that the algorithm will only use the order induced by the comparator,
            if the nodes (or better their whole subtrees) have equal size.
            The default value is <see langword="null" /> which indicates that the algorithm should
            use its built-in logic, only.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.CreateBends(yWorks.yFiles.Layout.IEdgeLayout,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Node,System.Object,System.Object)" />
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Core layout routine.</summary>
      <remarks>Core layout routine.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.GetAspectRatio(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the aspectRatio that should be used for the subtree starting
            at the given node.
            </summary>
      <remarks>
            Returns the aspectRatio that should be used for the subtree starting
            at the given node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.GetRootPlacement(System.Object)">
      <summary>Returns the desired placement for the given subtree root.</summary>
      <param name="root">the subtree root.</param>
      <returns>
            a symbolic constant representing the desired placement for the
            given subtree root.
            </returns>
      <remarks>
            Returns the desired placement for the given subtree root.
            Should be one of
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementTop" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCorner" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCornerSide" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCornerTop" />
            </li>
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.GetRoutingPolicy(System.Object)">
      <summary>
            Returns the routing policy used by this <c>ARTreeLayouter</c> for
            the given subtree root.
            </summary>
      <param name="root">the subtree root.</param>
      <returns>the routing policy used for the given subtree root.</returns>
      <remarks>
            Returns the routing policy used by this <c>ARTreeLayouter</c> for
            the given subtree root.
            Should be one of
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingHorizontal" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingVertical" />
            </li>
            </ul>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.ARTreeLayouter.GetSuccessors(yWorks.yFiles.Algorithms.Node)" />
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.graph" />
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.HorizontalSpace">
      <summary>The horizontal distance between adjacent nodes.</summary>
      <remarks>
            Specifies the horizontal distance between adjacent nodes.
            By default a value of <c>10</c> is set.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCorner">
      <summary>A data provider value used to specify the placement of the root.</summary>
      <remarks>A data provider value used to specify the placement of the root.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCornerSide">
      <summary>A data provider value used to specify the placement of the root.</summary>
      <remarks>A data provider value used to specify the placement of the root.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCornerTop">
      <summary>A data provider value used to specify the placement of the root.</summary>
      <remarks>A data provider value used to specify the placement of the root.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementTop">
      <summary>A data provider value used to specify the placement of the root.</summary>
      <remarks>A data provider value used to specify the placement of the root.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RatioDpKey">
      <summary>The data provider key used to specify target aspect ratio.</summary>
      <remarks>
            The data provider key used to specify target aspect ratio.
            Values larger than 1 produce layouts that are wider than high
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RootPlacement">
      <summary>The desired placement of the tree's root node.</summary>
      <remarks>
            Specifies the desired placement of the tree's root node.
            Should be one of
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementTop" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCorner" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCornerSide" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.PlacementCornerTop" />
            </li>
            </ul>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RootPlacementDpKey">
      <summary>The data provider key used to specify the placement of each subtree root.</summary>
      <remarks>The data provider key used to specify the placement of each subtree root.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingHorizontal">
      <summary>A data provider value used to specify the routing policy of each subtree.</summary>
      <remarks>A data provider value used to specify the routing policy of each subtree.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingPolicy">
      <summary>The routing policy used by this <c>ARTreeLayouter</c>.</summary>
      <remarks>
            Specifies the routing policy used by this <c>ARTreeLayouter</c>.
            Should be one of
            <ul>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingHorizontal" />
            </li>
            <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingVertical" />
            </li>
            </ul>
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingPolicyDpKey">
      <summary>The data provider key used to specify the routing policy of each subtree root.</summary>
      <remarks>The data provider key used to specify the routing policy of each subtree root.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ARTreeLayouter.RoutingVertical">
      <summary>A data provider value used to specify the routing policy of each subtree.</summary>
      <remarks>A data provider value used to specify the routing policy of each subtree.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.ARTreeLayouter.VerticalSpace">
      <summary>The vertical distance between adjacent nodes.</summary>
      <remarks>
            Specifies the vertical distance between adjacent nodes.
            By default a value of <c>10</c> is set.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.AssistantPlacer">
      <summary>
            The assistant placer is a NodePlacer that delegates the node placement to two different node placers depending
            on the type of the children.<br />
            The type of a child is recognized using a DataProvider providing boolean values.
            </summary>
      <remarks>
            The assistant placer is a NodePlacer that delegates the node placement to two different node placers depending
            on the type of the children.<br />
            The type of a child is recognized using a DataProvider providing boolean values. The data provider is registered
            using the key
            <see cref="F:yWorks.yFiles.Layout.Tree.AssistantPlacer.AssistantDpKey" />
            .<br />
            Assistant placer uses a
            <see cref="T:yWorks.yFiles.Layout.Tree.LeftRightPlacer" />
            for those nodes the DataProvider returns true (they are
            understood as "assistants").<br />
            Below the assistants the other children are arranged using the childNodePlacer (settable
            using
            <see cref="P:yWorks.yFiles.Layout.Tree.AssistantPlacer.ChildNodePlacer" />
            ).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.#ctor">
      <summary>Creates a default instance with horizontal orientation.</summary>
      <remarks>
            Creates a default instance with horizontal orientation.
            Call to this(Matrix.DEFAULT)
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Creates an AssistantPlacer for the given modification matrix.</summary>
      <param name="modificationMatrix">the modification matrix that is used as translation matrix.</param>
      <remarks>Creates an AssistantPlacer for the given modification matrix.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.AssistantPlacer.AssistantDpKey">
      <summary>
            Contains a boolean for each node whether it is an assistant or not.<br />
            True: Is assistant<br />
            False: Is not an assistant<br /></summary>
      <remarks>
            Contains a boolean for each node whether it is an assistant or not.<br />
            True: Is assistant<br />
            False: Is not an assistant<br />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.AssistantPlacer.ChildNodePlacer">
      <summary>The child node placer for the non-assistant children.</summary>
      <remarks>
            Setter:<br />
            Sets the child node placer. The child node placer is used to arrange the nodes that are not assistants.
            <see cref="F:yWorks.yFiles.Layout.Tree.AssistantPlacer.AssistantDpKey" />
            <para />
            Getter:<br />
            Returns the child node placer for the non-assistant children.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.CreateComparator">
      <summary>
            Returns <see langword="null" />, because no suitable comparator exists for this
            node placer.
            </summary>
      <returns>
        <see langword="null" />, because no suitable comparator exists for this
            node placer.
            </returns>
      <remarks>
            Returns <see langword="null" />, because no suitable comparator exists for this
            node placer.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates a processor that creates a dummy node and changes the edges for the non-assistant children.</summary>
      <param name="layouter" />
      <param name="graph" />
      <param name="currentRoot" />
      <returns>the processor that changes the graph structure suitable for the AssistantPlacer</returns>
      <remarks>Creates a processor that creates a dummy node and changes the edges for the non-assistant children.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>should not be called and throws a IllegalStateException</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>Delegates to the the left right placer.</summary>
      <param name="localRoot" />
      <param name="connectorMap" />
      <remarks>Delegates to the the left right placer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.GetNodeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the subtree shape for the given child node.</summary>
      <param name="node">the child node the subtree shape is returned for.</param>
      <returns>the subtree shape for the given child node.</returns>
      <remarks>Returns the subtree shape for the given child node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>Places the shapes.</summary>
      <param name="nodeShapeProvider" />
      <param name="subtreeShapeProvider" />
      <param name="graph" />
      <param name="localRoot" />
      <param name="parentConnectorDirection" />
      <remarks>Places the shapes.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.AssistantPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>Should not be called - throws IllegalStateException</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.AssistantPlacer.Spacing">
      <summary>
            The spacing between subtrees this <c>NodePlacer</c> is
            arranging.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.BalloonLayouter">
      <summary>
            A tree layouter that lays out the subtrees of the tree in a balloon-like
            fashion.
            </summary>
      <remarks>
            A tree layouter that lays out the subtrees of the tree in a balloon-like
            fashion.
            <p />
            Here is a sample layout output
            <p />
            <center><img src="doc-files/y.layout.tree.BalloonLayouter.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.BalloonLayouter" /> class</summary>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.AllowOverlaps">
      <summary>Specifies whether or not to allow partially overlapping nodes.</summary>
      <remarks>
            Setter:<br />
            Specifies whether or not this layouter should allow (partially)
            overlapping nodes.
            Activating this feature results in a more compact layout. The price for
            this feature is that some nodes may partially overlap.
            By default this feature is set to <see langword="false" />.
            <para />
            Getter:<br />
            Returns whether or not to allow partially overlapping nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.CalcAngles(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Calculates the angle wedge that has to be reserved for the subtree rooted
            at the given node.
            </summary>
      <remarks>
            Calculates the angle wedge that has to be reserved for the subtree rooted
            at the given node.
            <p />
            Subclasses may overwrite this method to perform a
            custom angle wedge assignment scheme.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.CalcChildArrangement(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Calculates the child nodes arrangement for a given root node of the
            tree.
            </summary>
      <remarks>
            Calculates the child nodes arrangement for a given root node of the
            tree. Subclasses may overwrite this method to perform a
            custom child node arrangement.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns true iff the core layouter can layout the given graph structure.</summary>
      <remarks>
            Returns true iff the core layouter can layout the given graph structure.
            This is the case iff the graph is a tree.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.ChildOrderingPolicy">
      <summary>The current policy for sorting the children around the local roots.</summary>
      <remarks>
            Specifies the current policy for sorting the children around the local roots.
            Possible values are
            <see cref="F:yWorks.yFiles.Layout.Tree.ChildOrderingPolicy.Compact" />
            and
            <see cref="F:yWorks.yFiles.Layout.Tree.ChildOrderingPolicy.Symmetric" />
            .
            Note: the policy is only considered if sketch mode is disabled (see method
            <see cref="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.FromSketchMode" />
            )
            and no comparator is set (see method
            <see cref="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.Comparator" />
            ).
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.CompactnessFactor">
      <summary>The compactness factor for this layouter.</summary>
      <remarks>
            Specifies the compactness factor for this layouter. This factor has to be a
            double value between 0 and 1.
            The smaller the factor the more compact will the layout potentially be.
            The price for a more compact layout is a potentially higher running time.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.Comparator">
      <summary>
            The
            <see cref="T:System.Collections.IComparer" />
            that will be used
            to sort the
            <see cref="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">outgoing edges</see>
            of each local root in the tree before they are being arranged.
            </summary>
      <remarks>
            Specifies the
            <see cref="T:System.Collections.IComparer" />
            that will be used
            to sort the
            <see cref="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">outgoing edges</see>
            of each local root in the tree before they are being arranged.
            The default value is <see langword="null" /> which indicates that the algorithm should
            use its built-in logic.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.DetermineRoot">
      <summary>
            Determines the root node of
            <see cref="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.graph" />
            according to the chosen root
            node policy.
            </summary>
      <returns>
            the root node of
            <see cref="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.graph" />
            .
            </returns>
      <remarks>
            Determines the root node of
            <see cref="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.graph" />
            according to the chosen root
            node policy.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Core layout routine.</summary>
      <remarks>Core layout routine.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.FromSketchMode">
      <summary>
            Specifies whether or not to take the coordinates of the input diagram
            into account when arranging the nodes of the elements of the tree.
            </summary>
      <remarks>
            Determines whether or not to take the coordinates of the input diagram
            into account when arranging the nodes of the elements of the tree.
            If this features is enabled, the original circular order of child nodes around
            each parent node will be maintained.
            <p />
            By default this feature is disabled.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.GetInfo(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the NodeInfo object that is associated with the given node
            while the layouter is active.
            </summary>
      <remarks>
            Returns the NodeInfo object that is associated with the given node
            while the layouter is active. Subclasses may want to use this information
            to refine the behavior of this algorithm.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.GetPreferredChildWedge(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns the preferred child wedge angle in degrees that is
            used for the children of the given root node.
            </summary>
      <remarks>
            Returns the preferred child wedge angle in degrees that is
            used for the children of the given root node.
            <p />
            Subclasses may overwrite this method to provide
            a custom child wedge function.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.graph">
      <summary>The layout graph being acted upon.</summary>
      <remarks>The layout graph being acted upon.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.MinimalEdgeLength">
      <summary>
            The minimal edge length that this layouter assigns
            to laid out edges.
            </summary>
      <remarks>
            Specifies the minimal edge length that this layouter assigns
            to laid out edges.
            <p />
            By default a minimal edge length of 40 is set.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.MinimalNodeDistance">
      <summary>The distance to keep between the nodes in the tree.</summary>
      <remarks>
            Getter:<br />
            Returns the distance to keep between the nodes in the tree.
            The default distance is 0.0.
            <para />
            Setter:<br />
            Sets the minimal distance to keep between the nodes in the tree.
            Note that this distance is not always considered if
            <see cref="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.AllowOverlaps" />
            is set to true.
            The default distance is 0.0.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.PreferredChildWedge">
      <summary>The preferred child wedge angle.</summary>
      <remarks>
            Setter:<br />
            Set the preferred radial amount in degrees that all child nodes
            may occupy around a parent node. This value controls the degree
            to which the child nodes may radiate away from the center of layout.
            By default the wedge is <c>340</c> degrees which means that
            the child nodes may radiate in almost any direction from a
            parent node.
            <p />
            Allowed values lie within <c>0</c> and <c>360</c>
            degrees.
            <p />
            By default a child wedge of <c>340</c> degrees is used.
            <para />
            Getter:<br />
            Returns the preferred child wedge angle.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.PreferredRootWedge">
      <summary>
            The preferred radial amount in degrees that stay unoccupied
            around the root node of the graph.
            </summary>
      <remarks>
            Setter:<br />
            Sets the preferred radial amount in degrees that stay unoccupied
            around the root node of the graph
            <p />
            Allowed values lie within <c>0</c> and <c>360</c>
            degrees.
            By default a root wedge of <c>360</c> degrees is used.
            <para />
            Getter:<br />
            Returns the preferred radial amount in degrees that stay unoccupied
            around the root node of the graph.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.RootNodePolicy">
      <summary>
            The root node policy that determines which node
            is chosen as (virtual) tree root for the layout process.
            </summary>
      <remarks>
            Specifies the root node policy that determines which node
            is chosen as (virtual) tree root for the layout process.
            <p />
            By default
            <see cref="F:yWorks.yFiles.Layout.Tree.RootNodePolicy.DirectedRoot" />
            is set.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.SortChildNodes(yWorks.yFiles.Algorithms.Node)">
      <summary>Sorts the child nodes of the given node.</summary>
      <remarks>
            Sorts the child nodes of the given node. This method uses
            the original node coordinates if <c>fromSketchMode</c> is enabled.
            Otherwise, it sorts the child nodes according to their wedge angle sizes, or, if present
            uses
            <see cref="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.Comparator">the specified comparator</see>
            to sort the outgoing edges of
            the local root node.
            The biggest one receives median position in the sorting order.
            The smaller the wedges the further away a node will be placed from the
            median position.
            <p />
            This method gets called within method
            <see cref="M:yWorks.yFiles.Layout.Tree.BalloonLayouter.CalcChildArrangement(yWorks.yFiles.Algorithms.Node)" />
            before coordinates are assigned and
            just after the wedges sizes for all subgraphs rooted at root were determined.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo">
      <summary>Encapsulates information bound to a node during the algorithm calculates a layout</summary>
      <remarks>Encapsulates information bound to a node during the algorithm calculates a layout</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo.AngleSum">
      <summary>The sum of all wedge angles</summary>
      <remarks>Returns the sum of all wedge angles</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo.dist">
      <summary>the distance of the node to its root node.</summary>
      <remarks>the distance of the node to its root node.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo.gapAngle">
      <summary>The angle that of the gap that to the wedge of the previous child node.</summary>
      <remarks>The angle that of the gap that to the wedge of the previous child node.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo.lowerAngle">
      <summary>The lower angle of the subtree wedge rooted at the node.</summary>
      <remarks>The lower angle of the subtree wedge rooted at the node.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.BalloonLayouter.NodeInfo.upperAngle">
      <summary>The upper angle of the subtree wedge rooted at the node.</summary>
      <remarks>The upper angle of the subtree wedge rooted at the node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.BusPlacer">
      <summary>
            The BusPlacer is a special NodePlacer that creates a bus where all child nodes and the root node
            are connected to.<br />
            The BusPlacer is rotatable using the constructor
            <see cref="M:yWorks.yFiles.Layout.Tree.BusPlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)" />
            .
            </summary>
      <remarks>
            The BusPlacer is a special NodePlacer that creates a bus where all child nodes and the root node
            are connected to.<br />
            The BusPlacer is rotatable using the constructor
            <see cref="M:yWorks.yFiles.Layout.Tree.BusPlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.#ctor">
      <summary>Initializes a new instance with the Default matrix.</summary>
      <remarks>Initializes a new instance with the Default matrix.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Initializes a new BusPlacer with the given modification matrix.</summary>
      <param name="modificationMatrix" />
      <remarks>Initializes a new BusPlacer with the given modification matrix.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.CreateComparator" />
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child" />
      <returns>
        <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.South" />
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method initializes internal data structures, then uses the abstract method
            <see cref="M:yWorks.yFiles.Layout.Tree.BusPlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)" />
            to determine the child node connector directions.
            </summary>
      <param name="localRoot">the local root node</param>
      <param name="connectorMap">the map that will be used to store the values</param>
      <remarks>
            This method initializes internal data structures, then uses the abstract method
            <see cref="M:yWorks.yFiles.Layout.Tree.BusPlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)" />
            to determine the child node connector directions.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.BusPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>Places the root node and its children</summary>
      <param name="localRoot" />
      <param name="parentConnectorDirection" />
      <returns>the created subtree shape</returns>
      <remarks>Places the root node and its children</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ChildOrderingPolicy">
      <summary>Child ordering policy specifier constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildOrderingPolicy.Compact">
      <summary>
            Child ordering policy specifier constant.
            This policy sorts the child nodes according to the size of the subtree rooted by them in an interleaved fashion.
            Using this policy the produced results are often more compact.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildOrderingPolicy.Symmetric">
      <summary>
            Child ordering policy specifier constant.
            This policy sorts the child nodes according to their wedge angle sizes.
            The node with the biggest angle receives median position in the sorting order.
            The smaller the wedges the further away a node will be placed from the
            median position. Using this policy the produced results are often more symmetric.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ChildPlacement">
      <summary>Placement byte constant used for the <c>childPlacement</c> property.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacement.VerticalToLeft">
      <summary>
            Placement byte constant used for the <c>childPlacement</c> property.
            This placement strategy arranges child subtrees vertically beneath each other
            to the left of the root node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacement.VerticalToRight">
      <summary>
            Placement byte constant used for the <c>childPlacement</c> property.
            This placement strategy arranges child subtrees vertically beneath each other
            to the right of the root node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacement.HorizontalUpward">
      <summary>
            Placement byte constant used for the <c>childPlacement</c> property.
            This placement strategy arranges child subtrees horizontally next to each other
            above the root node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacement.HorizontalDownward">
      <summary>
            Placement byte constant used for the <c>childPlacement</c> property.
            This placement strategy arranges child subtrees horizontally next to each other
            below the root node.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ChildPlacementPolicy">
      <summary>Symbolic child placement policy specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacementPolicy.LeavesStacked">
      <summary>
            Symbolic child placement policy specifier.
            This setting configures the algorithm for a stacked style of leaf nodes.
            In this context, <em>stacked</em> means that leaf nodes that connect to
            the same root node are placed one upon the other.
            This results in horizontally compact layouts.
            Additionally, this policy tries to balance stack heights. I.e. for each
            subtree that consists of leaf nodes only,
            <see cref="F:yWorks.yFiles.Layout.Tree.ChildPlacementPolicy.LeavesStackedRight" />
            or
            <see cref="F:yWorks.yFiles.Layout.Tree.ChildPlacementPolicy.LeavesStackedLeftAndRight" />
            will be used
            depending on the number of leaves in the subtree.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacementPolicy.LeavesStackedLeft">
      <summary>
            Symbolic child placement policy specifier.
            This setting configures the algorithm for a stacked style of leaf nodes.
            In this context, <em>stacked</em> means that leaf nodes that connect to
            the same root node are placed one upon the other.
            This results in horizontally compact layouts.
            Moreover, the stack of leaf nodes is on the left.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacementPolicy.LeavesStackedRight">
      <summary>
            Symbolic child placement policy specifier.
            This setting configures the algorithm for a stacked style of leaf nodes.
            In this context, <em>stacked</em> means that leaf nodes that connect to
            the same root node are placed one upon the other.
            This results in horizontally compact layouts.
            Moreover, the stack of leaf nodes is on the right.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacementPolicy.LeavesStackedLeftAndRight">
      <summary>
            Symbolic child placement policy specifier.
            This setting configures the algorithm for a stacked style of leaf nodes.
            In this context, <em>stacked</em> means that leaf nodes that connect to
            the same root node are placed one upon the other.
            This results in horizontally compact layouts.
            Moreover, leaf nodes are distributed among two stacks, one on the left
            and one on the right.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacementPolicy.AllLeavesOnSameLayer">
      <summary>
            Symbolic child placement policy specifier.
            This results in a Dendrogram-style layout with all leaf nodes being
            placed in one layer (i.e. all leaves are being placed on one horizontal
            line in a top to bottom or bottom to top layout).
            A Dendrogram layout is often applied in computational biology in order to
            show clustering of genes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ChildPlacementPolicy.SiblingsOnSameLayer">
      <summary>
            Symbolic child placement policy specifier.
            This setting configures the algorithm to place siblings (leaf nodes with
            the same parent node) in the same layer (i.e. siblings are being placed
            on one horizontal line in a top to bottom or bottom to top layout).
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ConnectorDirection">
      <summary>
            Direction constant used by
            <see cref="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ConnectorDirection.North">
      <summary>
            Direction constant used by
            <see cref="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ConnectorDirection.East">
      <summary>
            Direction constant used by
            <see cref="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ConnectorDirection.South">
      <summary>
            Direction constant used by
            <see cref="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection" />
            .
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ConnectorDirection.West">
      <summary>
            Direction constant used by
            <see cref="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection" />
            .
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.DefaultNodePlacer">
      <summary>
            Versatile default implementation of
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            .
            </summary>
      <remarks>
            Versatile default implementation of
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            . This implementation provides
            a couple of related styles for laying out subtrees in a tree layout.
            The styles can be customized easily using a wealth of different options.
            This implementation is capable of dealing with PortConstraints correctly.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.#ctor">
      <summary>
            Creates a new DefaultNodePlacer with default alignment (
            <see cref="F:yWorks.yFiles.Layout.Tree.RootAlignment.Center" />
            ),
            default child placement (
            <see cref="F:yWorks.yFiles.Layout.Tree.ChildPlacement.HorizontalDownward" />
            ),
            and default edge routing (
            <see cref="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork" />
            ) and a horizontal and vertical distance
            of <c>40.0d</c>.
            </summary>
      <remarks>
            Creates a new DefaultNodePlacer with default alignment (
            <see cref="F:yWorks.yFiles.Layout.Tree.RootAlignment.Center" />
            ),
            default child placement (
            <see cref="F:yWorks.yFiles.Layout.Tree.ChildPlacement.HorizontalDownward" />
            ),
            and default edge routing (
            <see cref="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork" />
            ) and a horizontal and vertical distance
            of <c>40.0d</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.ChildPlacement,System.Double,System.Double)">
      <summary>
            Creates a new DefaultNodePlacer with default alignment (
            <see cref="F:yWorks.yFiles.Layout.Tree.RootAlignment.Center" />
            )
            and default edge routing (
            <see cref="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork" />
            ).
            </summary>
      <param name="childPlacement">placement constant describing the style of the arrangement</param>
      <param name="verticalDistance">
            the vertical distance between the root node and the subtree shapes or between
            subtree shapes in case of vertical child placement
            </param>
      <param name="horizontalDistance">
            the horizontal distance between the root node and the subtree shapes or between
            subtree shapes in case of horizontal child placement
            </param>
      <remarks>
            Creates a new DefaultNodePlacer with default alignment (
            <see cref="F:yWorks.yFiles.Layout.Tree.RootAlignment.Center" />
            )
            and default edge routing (
            <see cref="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork" />
            ).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.ChildPlacement,yWorks.yFiles.Layout.Tree.RootAlignment,System.Double,System.Double)">
      <summary>
            Creates a new DefaultNodePlacer with default edge routing (
            <see cref="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork" />
            ).
            </summary>
      <param name="childPlacement">placement constant describing the style of the arrangement</param>
      <param name="rootAlignment">
            alignment constant describing the position of the root nod
            with respect to the subtrees
            </param>
      <param name="verticalDistance">
            the vertical distance between the root node and the subtree shapes or between
            subtree shapes in case of vertical child placement
            </param>
      <param name="horizontalDistance">
            the horizontal distance between the root node and the subtree shapes or between
            subtree shapes in case of horizontal child placement
            </param>
      <remarks>
            Creates a new DefaultNodePlacer with default edge routing (
            <see cref="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork" />
            ).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.ChildPlacement,yWorks.yFiles.Layout.Tree.RootAlignment,yWorks.yFiles.Layout.Tree.RoutingStyle,System.Double,System.Double)">
      <summary>Creates a new DefaultNodePlacer.</summary>
      <param name="routingStyle">routing style constant</param>
      <param name="childPlacement">placement constant describing the style of the arrangement</param>
      <param name="rootAlignment">
            alignment constant describing the position of the root nod
            with respect to the subtrees
            </param>
      <param name="verticalDistance">
            the vertical distance between the root node and the subtree shapes or between
            subtree shapes in case of vertical child placement
            </param>
      <param name="horizontalDistance">
            the horizontal distance between the root node and the subtree shapes or between
            subtree shapes in case of horizontal child placement
            </param>
      <remarks>Creates a new DefaultNodePlacer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.CalcParentConnector(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape,yWorks.yFiles.Algorithms.Edge,yWorks.yFiles.Layout.IEdgeLayout,System.SByte)">
      <summary>Calculates the connector the the parent node.</summary>
      <param name="graph">the graph</param>
      <param name="localRoot">
            the root whose connector must be calculated and stored in the
            subtreeShape
            </param>
      <param name="rootLayout">the NodeLayout of the root node</param>
      <param name="subtreeShape">the shape to be used for the connector information</param>
      <param name="parentEdge">
            the edge that will later be routed according to the
            information in the subtreeShape
            </param>
      <param name="parentEdgeLayout">the current EdgeLayout of the edge</param>
      <param name="direction">
            the direction byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface which should be used for
            the connector
            </param>
      <remarks>
            Calculates the connector the the parent node.
            Subclasses may override this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.CalcSourceEdgeLayout(yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Performs the routing of the source side of the edge to
            the given child node.
            </summary>
      <param name="rootLayout">the NodeLayout of the local root node</param>
      <param name="childShape">
            the SubtreeShape instance of the corresponding child's
            subtree
            </param>
      <param name="edge">the edge</param>
      <remarks>
            Performs the routing of the source side of the edge to
            the given child node. This method calculates the source bends according to
            the current <c>routingStyle</c>, and connects the bends of the child
            SubtreeShape connector to the EdgeLayout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.CalcTargetEdgeLayout(yWorks.yFiles.Layout.INodeLayout,yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Performs the routing of the target side of the edge to
            the given child node.
            </summary>
      <param name="rootLayout">the NodeLayout of the local root node</param>
      <param name="childShape">
            the SubtreeShape instance of the corresponding child's
            subtree
            </param>
      <param name="edge">the edge</param>
      <remarks>
            Performs the routing of the target side of the edge to
            the given child node. This method does nothing but resets the current
            EdgeLayout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.ChildPlacement">
      <summary>The child node placement policy.</summary>
      <remarks>Specifies the child node placement policy.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.CreateComparator">
      <summary>
            Returns a Comparator instance that can be used to register with the
            GenericTreeLayouter.
            </summary>
      <returns>
            a Comparator instance that can be used for the current configuration of
            this instance.
            </returns>
      <remarks>
            Returns a Comparator instance that can be used to register with the
            GenericTreeLayouter. The returned instance can be used to sort the child
            nodes in such a way that the layout will look like the current arrangement
            of the nodes. This is especially useful for interactive or incremental layouts.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface
            </returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.HorizontalDistance">
      <summary>
            The horizontal distance this <c>NodePlacer</c> should use for the
            arrangement of the elements.
            </summary>
      <remarks>
            Specifies the horizontal distance this <c>NodePlacer</c> should use for the
            arrangement of the elements.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main placeSubtree method that must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.RootAlignment">
      <summary>The root node alignment policy.</summary>
      <remarks>Specifies the root node alignment policy.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.RoutingStyle">
      <summary>The current routing style byte constant.</summary>
      <remarks>
            Getter:<br />
            Returns the current routing style byte constant.
            <para />
            Setter:<br />
            Specifies the current routing style.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultNodePlacer.VerticalDistance">
      <summary>
            The vertical distance this NodePlacer should use for the
            arrangement of the elements.
            </summary>
      <remarks>
            Specifies the vertical distance this NodePlacer should use for the
            arrangement of the elements.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.DefaultPortAssignment">
      <summary>This class provides simple default port assignment strategies.</summary>
      <remarks>This class provides simple default port assignment strategies.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.#ctor">
      <summary>
            Creates a new DefaultPortAssignment instance using mode
            <see cref="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.Node" />
            .
            </summary>
      <remarks>
            Creates a new DefaultPortAssignment instance using mode
            <see cref="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.Node" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.#ctor(yWorks.yFiles.Layout.Tree.PortAssignmentMode)">
      <summary>Creates a new DefaultPortAssignment instance using the given mode.</summary>
      <remarks>
            Creates a new DefaultPortAssignment instance using the given mode.
            Possible values for <c>mode</c> are
            <see cref="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.Node" />
            and
            <see cref="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.PortConstraint" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.AssignChildEdgeSourcePort(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge,System.Int32)">
      <summary>This method assigns the source port of an edge that goes to a child node.</summary>
      <param name="graph">the graph which contains the node</param>
      <param name="node">the parent node</param>
      <param name="edge">the edge to the child node</param>
      <param name="index">the zero-based index of the child edge</param>
      <remarks>This method assigns the source port of an edge that goes to a child node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.AssignParentEdgeTargetPort(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.Edge)">
      <summary>This method assigns the target port of the edge that goes to the parent node.</summary>
      <param name="graph">the graph which contains the node</param>
      <param name="node">the node</param>
      <param name="edge">the edge to the parent node</param>
      <remarks>This method assigns the target port of the edge that goes to the parent node.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            before the actual layout
            of the graph takes place.
            </summary>
      <param name="graph">the graph instance the node is part of</param>
      <param name="node">the node whose adjacent edges' ports should be set</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.GetSourcePortConstraint(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge,System.Int32)">
      <summary>
            Returns the PortConstraint for the given edge or <see langword="null" /> if no
            PortConstraint is set.
            </summary>
      <param name="graph">the graph the edge is part of</param>
      <param name="edge">the edge whose PortConstraint is to be determined</param>
      <param name="index">the child's index</param>
      <returns>a PortConstraint or <see langword="null" /></returns>
      <remarks>
            Returns the PortConstraint for the given edge or <see langword="null" /> if no
            PortConstraint is set. This implementation uses the PortConstraint data provider
            that is bound to the graph, if available.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.GetTargetPortConstraint(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Returns the PortConstraint for the given edge or <see langword="null" /> if no
            PortConstraint is set.
            </summary>
      <param name="graph">the graph the edge is part of</param>
      <param name="edge">the edge whose PortConstraint is to be determined</param>
      <returns>a PortConstraint or <see langword="null" /></returns>
      <remarks>
            Returns the PortConstraint for the given edge or <see langword="null" /> if no
            PortConstraint is set. This implementation uses the PortConstraint data provider
            that is bound to the graph, if available.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DefaultPortAssignment.Mode">
      <summary>The port assignment mode.</summary>
      <remarks>
            Specifies the port assignment mode.
            Possible values are
            <see cref="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.Node" />
            and
            <see cref="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.PortConstraint" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer">
      <summary>
            The DelegatingNodePlacer may be used to layout the children of the actual
            node with two different <c>NodePlacer</c>s.
            </summary>
      <remarks>
            The DelegatingNodePlacer may be used to layout the children of the actual
            node with two different <c>NodePlacer</c>s.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix,yWorks.yFiles.Layout.Tree.INodePlacer,yWorks.yFiles.Layout.Tree.INodePlacer)">
      <summary>Creates a new instance using the given modification matrix an the node placers "this" delegates to.</summary>
      <remarks>Creates a new instance using the given modification matrix an the node placers "this" delegates to.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a processor that partitions child nodes of the specified root node
            into two subsets, one to be arranged by the "upper left"
            <c>NodePlacer</c> and one to be arranged by the "lower right"
            <c>NodePlacer</c>.
            </summary>
      <remarks>
            Creates a processor that partitions child nodes of the specified root node
            into two subsets, one to be arranged by the "upper left"
            <c>NodePlacer</c> and one to be arranged by the "lower right"
            <c>NodePlacer</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface
            </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method initializes internal data structures, then uses the abstract method
            <see cref="M:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)" />
            to determine the child node connector directions.
            </summary>
      <param name="localRoot">the local root node</param>
      <param name="connectorMap">the map that will be used to store the values</param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.GetLowerRightChildren(yWorks.yFiles.Algorithms.Node)">
      <summary>Determines the lower right children of the specified root node.</summary>
      <returns>a NodeList containing the lower right nodes.</returns>
      <remarks>
            Determines the lower right children of the specified root node.
            These nodes are placed using the <c>NodePlacer</c> returned by
            <see cref="P:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.PlacerLowerRight" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.GetUpperLeftChildren(yWorks.yFiles.Algorithms.Node)">
      <summary>Determines the upper left children of the specified root node.</summary>
      <returns>a NodeList containing the upper left nodes.</returns>
      <remarks>
            Determines the upper left children of the specified root node.
            These nodes are placed using the <c>NodePlacer</c> returned by
            <see cref="P:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.PlacerUpperLeft" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.Orientation">
      <summary>
            The orientation according to which node shapes are aligned by
            this placer.
            </summary>
      <remarks>
            Specifies the orientation according to which node shapes are aligned by
            this placer.
            Depending on the orientation the shapes are aligned on the x- or y-axis.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.PlacerLowerRight">
      <summary>
            The <c>NodePlacer</c> that is used to layout the nodes on
            the "lower right"
            </summary>
      <remarks>
            Returns the <c>NodePlacer</c> that is used to layout the nodes on
            the "lower right"
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.PlacerUpperLeft">
      <summary>
            The <c>NodePlacer</c> that is used to layout the nodes on
            the "upper left"
            </summary>
      <remarks>
            Returns the <c>NodePlacer</c> that is used to layout the nodes on
            the "upper left"
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>
            Places the shapes of the children using the two node placers
            <see cref="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.GetUpperLeftChildren(yWorks.yFiles.Algorithms.Node)" />
            and
            <see cref="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.GetLowerRightChildren(yWorks.yFiles.Algorithms.Node)" />
            .
            </summary>
      <returns>the subtree shape for the given local root.</returns>
      <remarks>
            Places the shapes of the children using the two node placers
            <see cref="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.GetUpperLeftChildren(yWorks.yFiles.Algorithms.Node)" />
            and
            <see cref="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.GetLowerRightChildren(yWorks.yFiles.Algorithms.Node)" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DelegatingNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.DendrogramPlacer">
      <summary>
            This is an implementation of the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface that
            can be used to create dendrogram-like tree layouts.
            </summary>
      <remarks>
            This is an implementation of the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface that
            can be used to create dendrogram-like tree layouts.
            This placer arranges nodes from top to bottom.
            It arranges subtrees in such a way that all subtrees of a single local root align at their bottom border.
            This implementation does not support
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            s.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DendrogramPlacer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.DendrogramPlacer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DendrogramPlacer.CreateComparator">
      <summary>Creates a comparator that can be used to do a from sketch layout.</summary>
      <returns>the comparator implementation to use to simulate from sketch layout</returns>
      <remarks>
            Creates a comparator that can be used to do a from sketch layout.
            If this instance is used for the root node's
            <see cref="F:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.ChildComparatorDpKey" />
            this implementation will do a from sketch layout.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DendrogramPlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an optional Processor for pre- and post-processing.</summary>
      <param name="layouter" />
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DendrogramPlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method is called by GenericTreeLayouter before the subtree shapes of
            this local root node's children are calculated.
            </summary>
      <param name="localRoot">
            the local root node whose child nodes will be provided with
            a byte constant indicating the direction of the connector
            </param>
      <param name="connectorMap">
            the map that should be used for storing the byte constant
            with the child nodes.
            </param>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DendrogramPlacer.MinimumRootDistance">
      <summary>The distance between the root shape and the bus connecting all of its subtrees.</summary>
      <remarks>
            Specifies the distance between the root shape and the bus connecting all of its subtrees.
            The default is <c>30</c>.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DendrogramPlacer.MinimumSubtreeDistance">
      <summary>The distance between two adjacent subtree shapes.</summary>
      <remarks>
            Specifies the distance between two adjacent subtree shapes.
            The default is <c>30</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DendrogramPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main method of the tree layout algorithm.</summary>
      <param name="nodeShapeProvider">
            this instance can be used to obtain an initial shape
            of the root node. This shape can then be merged with all the subtrees' shapes
            and finally be returned by this method.
            </param>
      <param name="subtreeShapeProvider">
            provides access to the pre-calculated shapes of
            the subtrees. It is guaranteed that at the time of the invocation of this
            method for every child node the subtree shape has already been calculated
            </param>
      <param name="graph">the graph which is to be laid out</param>
      <param name="localRoot">the root of the subtree that should be laid out by this method</param>
      <param name="parentConnectorDirection">
            the direction byte constant as it is defined
            in this interface, that must be used for initializing the connector of the
            localRoot node to the parent node of the localRoot node
            </param>
      <returns>the shape of the whole subtree</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.DoubleLinePlacer">
      <summary>
            The DoubleLinePlacer is a special node placer that places its children in
            two lines.<br />
            This node placer is especially useful for leaves with great width.
            </summary>
      <remarks>
            The DoubleLinePlacer is a special node placer that places its children in
            two lines.<br />
            This node placer is especially useful for leaves with great width.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DoubleLinePlacer.#ctor">
      <summary>Creates a new DoubleLinePlacer with the default modification matrix.</summary>
      <remarks>Creates a new DoubleLinePlacer with the default modification matrix.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DoubleLinePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Creates a new DoubleLinePlacer with the given modification matrix.</summary>
      <param name="modificationMatrix" />
      <remarks>Creates a new DoubleLinePlacer with the given modification matrix.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DoubleLinePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns
            <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North" /></summary>
      <param name="child" />
      <returns>
        <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North" />
      </returns>
      <remarks>
            Returns
            <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.DoubleLinePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>Places the subtree in two lines.</summary>
      <param name="localRoot" />
      <param name="parentConnectorDirection" />
      <returns>the subtree</returns>
      <remarks>Places the subtree in two lines.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.DoubleLinePlacer.RootAlignment">
      <summary>The horizontal alignment that is used for the root node.</summary>
      <remarks>Specifies the horizontal alignment that is used for the root node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.EdgeLayoutStyle">
      <summary>Layout style constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.EdgeLayoutStyle.Plain">
      <summary>Layout style constant. Draw edges as straight lines.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.EdgeLayoutStyle.Orthogonal">
      <summary>Layout style constant. Draw edges orthogonally in a bus-like fashion.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.FillStyle">
      <summary>Byte constant that can be used for the <c>fillStyle</c> property.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.FillStyle.Leading">
      <summary>
            Byte constant that can be used for the <c>fillStyle</c> property.
            Elements in one lane will be aligned with the leading edge.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.FillStyle.Centered">
      <summary>
            Byte constant that can be used for the <c>fillStyle</c> property.
            Elements in one lane will be centered with the bounds.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.FillStyle.Justify">
      <summary>
            Byte constant that can be used for the <c>fillStyle</c> property.
            Elements in one lane will be justified with the bounds.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.FillStyle.Trailing">
      <summary>
            Byte constant that can be used for the <c>fillStyle</c> property.
            Elements in one lane will be aligned with the trailing edge.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.FreePlacer">
      <summary>Placer that can be used as simple "pseudo"-placer.</summary>
      <remarks>
            Placer that can be used as simple "pseudo"-placer. May be useful if the localRoot does not have any children
            or you want to place them manually.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.FreePlacer.#ctor">
      <summary>Creates a new instance with the default matrix.</summary>
      <remarks>Creates a new instance with the default matrix.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.FreePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Creates a processor suitable to the FreePlacer.<br />
            This processor will change all descendants node placers to FreePlacer.
            </summary>
      <param name="layouter" />
      <param name="graph" />
      <param name="currentRoot" />
      <remarks>
            Creates a processor suitable to the FreePlacer.<br />
            This processor will change all descendants node placers to FreePlacer.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.FreePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child" />
      <returns>
        <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.None" />
      </returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.FreePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>Creates the subtree shape</summary>
      <param name="localRoot" />
      <param name="parentConnectorDirection" />
      <returns>the created subtree shape</returns>
      <remarks>Creates the subtree shape</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter">
      <summary>This class implements the basis of a generic tree layout algorithm.</summary>
      <remarks>
            This class implements the basis of a generic tree layout algorithm.
            It can be customized easily to control the
            placement and order of child nodes, the edge routing and port assignment on a per node basis.<br /> Using
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            s, one can specify objects that implement the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface. Those instances are
            responsible for the arrangement of the subtrees of the node's they are registered with and the routing of the
            connecting edges. <br /> Likewise instances of
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            are responsible for the assignment of the ports
            and
            <see cref="T:System.Collections.IComparer" />
            instances can be used to sort the outgoing edges of each node. <br /> Customization of this
            class should be done via own implementations of the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            , possibly
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            , and
            <see cref="T:System.Collections.IComparer" />
            instances.
            <p />
            Here is an example output that shows multiple different configurations in one layout using
            <see cref="T:yWorks.yFiles.Layout.Tree.DefaultNodePlacer" />
            instances:
            <p />
            <center><img src="doc-files/y.layout.tree.GenericTreeLayouter.generic.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.#ctor">
      <summary>
            Creates a new GenericTreeLayouter with a default
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            , a default
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            instance and
            no default edge comparator.
            </summary>
      <remarks>
            Creates a new GenericTreeLayouter with a default
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            , a default
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            instance and
            no default edge comparator.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Subclasses have to provide information whether or not they
            can layout the given graph.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.ChildComparatorDpKey">
      <summary>
            DataProvider key that can be registered with the graph to provide each node with its own
            <see cref="T:System.Collections.IComparer" />
            instance that will be used to sort its outgoing edges.
            </summary>
      <remarks>
            DataProvider key that can be registered with the graph to provide each node with its own
            <see cref="T:System.Collections.IComparer" />
            instance that will be used to sort its outgoing edges.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DefaultChildComparator">
      <summary>
            The default
            <see cref="T:System.Collections.IComparer" />
            instance or <see langword="null" /> that will be used for those subtrees, that
            don't have their own specific instance set via the appropriate DataProvider.
            </summary>
      <remarks>
            Getter:<br />
            Returns the default
            <see cref="T:System.Collections.IComparer" />
            instance or <see langword="null" /> that will be used for those subtrees, that
            don't have their own specific instance set via the appropriate DataProvider.
            <para />
            Setter:<br />
            Sets the default
            <see cref="T:System.Collections.IComparer" />
            instance that will be used for those subtrees that don't have their own
            specific instance set via the appropriate DataProvider. This can be set to <see langword="null" /> which implies no
            sorting by default.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DefaultLeafPlacer">
      <summary>
            The default
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            instance that will be used for the leaf nodes of the tree.
            </summary>
      <remarks>
            Specifies the default
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            instance that will be used for the leaf nodes of the tree.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DefaultNodePlacer">
      <summary>
            The default
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            instance that will be used for those subtrees, that don't have their own
            specific instance set via the appropriate DataProvider.
            </summary>
      <remarks>
            Specifies the default
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            instance that will be used for those subtrees, that don't have their own
            specific instance set via the appropriate DataProvider. This should be non-<see langword="null" />, unless it is
            guaranteed that for any node in the graph there is a specific instance provided by the registered DataProvider
            instance.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DefaultPortAssignment">
      <summary>
            The default
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            instance that will be used for those subtrees, that don't have their
            own specific instance set via the appropriate DataProvider.
            </summary>
      <remarks>
            Specifies the default
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            instance that will be used for those subtrees, that don't have their own
            specific instance set via the appropriate DataProvider. This should be non-<see langword="null" />, unless it is
            guaranteed that for any node in the graph there is a specific instance provided by the registered DataProvider
            instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DirectTree">
      <summary>This method is called initially with the graph to calculate a rooted tree.</summary>
      <returns>an EdgeList containing all the edges that need to be reversed</returns>
      <remarks>
            This method is called initially with the graph to calculate a rooted tree. It returns a list of edges that have to
            be reversed in order for the graph to become a valid rooted and directed tree.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Subclasses have to provide core layout code in this method.</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetChildNodeInEdgeComparator(yWorks.yFiles.Algorithms.Node)">
      <summary>
            This method returns a
            <see cref="T:System.Collections.IComparer" />
            instance or <see langword="null" /> that will be used for the sorting of the
            outgoing edges at the given Node.
            </summary>
      <param name="localRoot">the root of the local subtree</param>
      <returns>
            a readily configured instance of
            <see cref="T:System.Collections.IComparer" />
            or <see langword="null" /> that can be used sort the outgoing
            edges of the given node
            </returns>
      <remarks>
            This method returns a
            <see cref="T:System.Collections.IComparer" />
            instance or <see langword="null" /> that will be used for the sorting of the
            outgoing edges at the given Node. This method is allowed to return a shared instance for multiple different nodes,
            the instances are not used after subsequent calls to this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetNodePlacer(yWorks.yFiles.Algorithms.Node)">
      <summary>
            This method returns a
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            instance that will be used for the placement of the root node and the
            subtree shapes.
            </summary>
      <param name="localRoot">the root of the local subtree</param>
      <returns>
            a readily configured instance of
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            that can be used to layout the subtree under the given
            local root node.
            </returns>
      <remarks>
            This method returns a
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            instance that will be used for the placement of the root node and the
            subtree shapes. This method is allowed to return a shared instance for multiple different nodes, the instances are
            not used after subsequent calls to this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetNodeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Factory method that creates a SubtreeShape for a given node, that consists of the bounds of the node only.</summary>
      <param name="node">the node that will be represented by a SubTreeShape instance</param>
      <returns>a newly created SubtreeShape describing the bounds of the given node</returns>
      <remarks>Factory method that creates a SubtreeShape for a given node, that consists of the bounds of the node only.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetPortAssignment(yWorks.yFiles.Algorithms.Node)">
      <summary>
            This method returns a
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            instance that will be used for the port assignments at the given Node.
            </summary>
      <param name="localRoot">the root of the local subtree</param>
      <returns>
            a readily configured instance of
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            that can be used to assign the ports of the edges
            at the given local root node.
            </returns>
      <remarks>
            This method returns a
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            instance that will be used for the port assignments at the given Node.
            This method is allowed to return a shared instance for multiple different nodes, the instances are not used after
            subsequent calls to this method.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetRootsArray(yWorks.yFiles.Algorithms.Node)">
      <summary>Returns the array of the nodes to be laid out.</summary>
      <param name="root">the node that should be used as the root of the tree</param>
      <returns>all nodes in the graph that should be laid out in order</returns>
      <remarks>
            Returns the array of the nodes to be laid out. The order of the elements is chosen so that no parent is laid out
            before one of its successors.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetSubtreeShape(yWorks.yFiles.Algorithms.Node)">
      <summary>Provides access to the SubTreeShape instances for each node.</summary>
      <param name="localRoot">the node for which the subtree should be returned</param>
      <returns>the SubTreeShape instance if it has been calculated already or <see langword="null" /> otherwise</returns>
      <remarks>
            Provides access to the SubTreeShape instances for each node. Those instances should be modified only during the
            layout of the parent node.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.graph">
      <summary>the graph this layout is running on</summary>
      <remarks>the graph this layout is running on</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GroupingSupported">
      <summary>True if grouping support is enabled.</summary>
      <remarks>
            Whether or not grouping support should be enabled.
            Note that the grouping only works correctly, if each group represents a complete subtree.
            This means that for each group there is a node v such that the group contains exactly v and all its descendants.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.IntegratedEdgeLabeling">
      <summary>
            Specifies whether integrated edge labeling is enabled (extension of the
            shapes of subtrees with the labels of the edges).
            </summary>
      <remarks>
            Getter:<br />
            Returns whether integrated edge labeling is enabled (extension of the
            shapes of subtrees with the labels of the edges).
            <para />
            Setter:<br />
            Specifies whether or not to use integrated edge labeling
            (extension of the shapes of the subtrees with the labels for the edges).
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.IntegratedNodeLabeling">
      <summary>
            Specifies whether integrated node labeling is enabled (extension of the
            shapes of the nodes with its labels).
            </summary>
      <remarks>
            Setter:<br />
            Specifies whether or not to use integrated node labeling.
            If set to <see langword="true" />, the shape of the nodes will be extended with
            the shapes of its labels.
            <para />
            Getter:<br />
            Returns whether integrated node labeling is enabled (extension of the
            shapes of the nodes with its labels).
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.LayoutRoot(yWorks.yFiles.Algorithms.Node)">
      <summary>This is the core method of the algorithm.</summary>
      <param name="localRoot">The root to be laid out together with its SubtreeShapes</param>
      <returns>the combined SubtreeShape of the local root node and all of its children and connecting edges</returns>
      <remarks>
            This is the core method of the algorithm. This method is invoked for each node in the tree exactly once in such an
            order that all of the child nodes of each node have already been calculated by the time of the method invocation.
            <br /> This method uses the
            <see cref="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.GetSubtreeShape(yWorks.yFiles.Algorithms.Node)" />
            callback to retrieve the shapes of the subtrees of all
            of the children of <c>localRoot</c>.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.NodePlacerDpKey">
      <summary>
            DataProvider key that can be registered with the graph to provide each node with its own
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            instance.
            </summary>
      <remarks>
            DataProvider key that can be registered with the graph to provide each node with its own
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            instance.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.PortAssignmentDpKey">
      <summary>
            DataProvider key that can be registered with the graph to provide each node with its own
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            instance.
            </summary>
      <remarks>
            DataProvider key that can be registered with the graph to provide each node with its own
            <see cref="T:yWorks.yFiles.Layout.Tree.IPortAssignment" />
            instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.ReverseEdges(yWorks.yFiles.Algorithms.EdgeList)">
      <summary>This method is used for the actual reversal of edges.</summary>
      <param name="reversedEdges">the edges that will be reversed by this method</param>
      <remarks>
            This method is used for the actual reversal of edges.
            It will be called initially after the
            <see cref="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.DirectTree" />
            method and finally
            after the layout has been calculated.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SourcePortConstraintDataAcceptor">
      <summary>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            implementation
            that can be used to overwrite the source port constraint (
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            temporarily for use during the layout.
            </summary>
      <remarks>
            Returns a
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            implementation
            that can be used to overwrite the source port constraint (
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            temporarily for use during the layout.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.TargetPortConstraintDataAcceptor">
      <summary>
            A
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            implementation
            that can be used to overwrite the target port constraint (
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            temporarily for use during the layout.
            </summary>
      <remarks>
            Returns a
            <see cref="T:yWorks.yFiles.Algorithms.IDataAcceptor" />
            implementation
            that can be used to overwrite the target port constraint (
            <see cref="T:yWorks.yFiles.Layout.PortConstraint" />
            temporarily for use during the layout.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape">
      <summary>Instances of this class are used to represent the shape of subtrees during the layout.</summary>
      <remarks>Instances of this class are used to represent the shape of subtrees during the layout.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AddBoundsToShape(System.Double,System.Double,System.Double,System.Double)">
      <summary>Adds a rectangular shape to the current shape.</summary>
      <remarks>Adds a rectangular shape to the current shape.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AddEdgeSegments(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Edge)">
      <summary>
            Helper method that takes all edge segments of the given Edge instance and updates the shape bounds with that
            information.
            </summary>
      <param name="lg">the LayoutGraph that contains the edge</param>
      <param name="e">the edge whose path will be used to update the shape</param>
      <remarks>
            Helper method that takes all edge segments of the given Edge instance and updates the shape bounds with that
            information.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AddLineSegment(System.Double,System.Double,System.Double,System.Double)">
      <summary>Convenience method that updates the shape to respect the given line segment.</summary>
      <remarks>Convenience method that updates the shape to respect the given line segment.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AddTargetPoint(System.Double,System.Double)">
      <summary>Adds another point to the connecting edge (away from the target node).</summary>
      <param name="x">the current x coordinate of the point</param>
      <param name="y">the current x coordinate of the point</param>
      <remarks>Adds another point to the connecting edge (away from the target node).</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AppendTargetPoints(yWorks.yFiles.Layout.IEdgeLayout)">
      <summary>Appends all target points that have previously been added to this shape to the given EdgeLayout instance.</summary>
      <param name="el">the EdgeLayout that will be modified</param>
      <remarks>
            Appends all target points that have previously been added to this shape to the given EdgeLayout instance. Used by
            NodePlacer instances for the final edge connections.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.AssignValuesTo(yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape,yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Copies this instance to another shape, applying a modification matrix.</summary>
      <remarks>Copies this instance to another shape, applying a modification matrix.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.Bounds">
      <summary>The current bounds of this SubtreeShape</summary>
      <remarks>Returns the current bounds of this SubtreeShape</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorDirection">
      <summary>
            The direction byte constant as defined in this class, that indicates the direction of the last connecting
            edge segment.
            </summary>
      <remarks>
            Returns the direction byte constant as defined in this class, that indicates the direction of the last connecting
            edge segment.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorX">
      <summary>
            The current x coordinate of the connection point where the layout algorithm should connect the ingoing
            edge to.
            </summary>
      <remarks>
            Returns the current x coordinate of the connection point where the layout algorithm should connect the ingoing
            edge to.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ConnectorY">
      <summary>
            The current y coordinate of the connection point where the layout algorithm should connect the ingoing
            edge to.
            </summary>
      <remarks>
            Returns the current y coordinate of the connection point where the layout algorithm should connect the ingoing
            edge to.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.CoreBounds">
      <summary>
            Yields the bounds of the
            <see cref="T:yWorks.yFiles.Layout.INodeLayout" />
            of the root node.
            </summary>
      <remarks>
            Yields the bounds of the
            <see cref="T:yWorks.yFiles.Layout.INodeLayout" />
            of the root node.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.CreateCopy(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Creates a clone of this instance, modifying it using the provided matrix.</summary>
      <remarks>Creates a clone of this instance, modifying it using the provided matrix.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.GetBorderLine(System.Int32)">
      <summary>Returns the BorderLine instance for the given direction.</summary>
      <param name="index">
            the direction index where
            <c>0</c> is north,
            <c>1</c> is east,
            <c>2</c> is south, and
            <c>3</c> is west.
            </param>
      <returns>
            the current
            <see cref="T:yWorks.yFiles.Algorithms.Geometry.BorderLine" />
            instance
            </returns>
      <remarks>Returns the BorderLine instance for the given direction.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.MaxX">
      <summary>The current maximum x coordinate of this shape.</summary>
      <remarks>Returns the current maximum x coordinate of this shape.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.MaxY">
      <summary>The current maximum y coordinate of this shape.</summary>
      <remarks>Returns the current maximum y coordinate of this shape.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.MergeWith(yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape)">
      <summary>Merges the given SubtreeShape with this shape's bounds.</summary>
      <param name="other">the shape to be merged with this shape</param>
      <remarks>Merges the given SubtreeShape with this shape's bounds.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.MinX">
      <summary>The current minimal x coordinate of this shape.</summary>
      <remarks>Returns the current minimal x coordinate of this shape.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.MinY">
      <summary>The current minimal y coordinate of this shape.</summary>
      <remarks>Returns the current minimal y coordinate of this shape.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.Move(System.Double,System.Double)">
      <summary>Moves this shape and its connector by the given offsets.</summary>
      <param name="dx">the delta x offset this shape will be moved by</param>
      <param name="dy">the delta y offset this shape will be moved by</param>
      <remarks>
            Moves this shape and its connector by the given offsets. This is a cheap operation and does not depend on the
            size or complexity of the shape or connector.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.OriginX">
      <summary>The current x coordinate of the origin of this shape.</summary>
      <remarks>
            Returns the current x coordinate of the origin of this shape. The origin is defined as the upper left corner of
            the NodeLayout of the local root of this shape.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.OriginY">
      <summary>The current y coordinate of the origin of this shape.</summary>
      <remarks>
            Returns the current y coordinate of the origin of this shape. The origin is defined as the upper left corner of
            the NodeLayout of the local root of this shape.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.ToString">
      <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
      <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.GenericTreeLayouter.SubtreeShape.UpdateConnectorShape">
      <summary>Adds the line segments of the connector shape to the bounds and borderlines of this SubTreeShape</summary>
      <remarks>Adds the line segments of the connector shape to the bounds and borderlines of this SubTreeShape</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.HVTreeLayouter">
      <summary>
            This tree layouter allows to layout a tree such that
            each subgraph rooted at a node can either have a horizontal or
            vertical layout.
            </summary>
      <remarks>
            This tree layouter allows to layout a tree such that
            each subgraph rooted at a node can either have a horizontal or
            vertical layout.
            <p />
            Here is an sample output of the layouter
            <p />
            <center><img src="doc-files/y.layout.tree.HVTreeLayouter.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.HVTreeLayouter" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>The core layouter can layout trees.</summary>
      <remarks>The core layouter can layout trees.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.HVTreeLayouter.Comparator">
      <summary>
            The
            <see cref="T:System.Collections.IComparer" />
            that will be used
            to sort the
            <see cref="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">outgoing edges</see>
            of each local root in the tree before they are being arranged.
            </summary>
      <remarks>
            Specifies the
            <see cref="T:System.Collections.IComparer" />
            that will be used
            to sort the
            <see cref="M:yWorks.yFiles.Algorithms.Node.SortOutEdges(System.Collections.IComparer)">outgoing edges</see>
            of each local root in the tree before they are being arranged.
            The default value is <see langword="null" /> which indicates that the algorithm should
            use its built-in logic.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Core layout routine.</summary>
      <remarks>Core layout routine.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.GetSuccessors(yWorks.yFiles.Algorithms.Node)" />
    <member name="F:yWorks.yFiles.Layout.Tree.HVTreeLayouter.graph">
      <summary>The layout graph being acted upon.</summary>
      <remarks>The layout graph being acted upon.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.HVTreeLayouter.HorizontalSpace">
      <summary>The horizontal distance between adjacent nodes.</summary>
      <remarks>
            Specifies the horizontal distance between adjacent nodes.
            By default a value of <c>10</c> is set.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.HVTreeLayouter.HorizontalSubtree">
      <summary>Subtree orientation specifier.</summary>
      <remarks>
            Subtree orientation specifier. This specifier indicated
            that the subtree rooted at the associated node should be laid
            out horizontally.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.IsHorizontalRoot(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the subtree rooted at the given node should
            be laid out horizontally.
            </summary>
      <remarks>
            Returns whether or not the subtree rooted at the given node should
            be laid out horizontally.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.HVTreeLayouter.IsVerticalRoot(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns whether or not the subtree rooted at the given node should
            be laid out vertically.
            </summary>
      <remarks>
            Returns whether or not the subtree rooted at the given node should
            be laid out vertically.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.HVTreeLayouter.SubtreeOrientationDpKey">
      <summary>
            The data provider key used to specify the subtree orientation
            of each node in the tree.
            </summary>
      <remarks>
            The data provider key used to specify the subtree orientation
            of each node in the tree.
            This layout algorithm will try to retrieve a
            data provider from the tree to be laid out with this key.
            The looked up data provider should provide either
            <see cref="F:yWorks.yFiles.Layout.Tree.HVTreeLayouter.HorizontalSubtree" />
            ,
            <see cref="F:yWorks.yFiles.Layout.Tree.HVTreeLayouter.VerticalSubtree" />
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.HVTreeLayouter.VerticalSpace">
      <summary>The vertical distance between adjacent nodes.</summary>
      <remarks>
            Specifies the vertical distance between adjacent nodes.
            By default a value of <c>10</c> is set.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.HVTreeLayouter.VerticalSubtree">
      <summary>Subtree orientation specifier.</summary>
      <remarks>
            Subtree orientation specifier. This specifier indicated
            that the subtree rooted at the associated node should be laid
            out vertically.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.INodePlacer">
      <summary>
            This interface is used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            .
            </summary>
      <remarks>
            This interface is used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            . Classes implementing this
            interface are responsible for the arrangement of a root node and all of its subtrees.
            Subtrees are represented as shapes with a connecting edge to the root of the subtree.
            <br />
            Instances have to:
            <ul>
            <li>arrange the subtree shapes and the root node
            (only the relative position matters, shapes can be placed at any absolute location,
            GenericTreeLayouter will perform the final alignment).
            </li>
            <li>perform the edge routing from the root node to all child nodes with respect
            to the connector provided by the subtree shapes</li>
            <li>
            calculate the union of the subtree shapes and the shape of the root node as well as
            any edges added in this run
            </li>
            <li>
            initialize the connector of the root node with respect to the preferred connection
            direction
            </li>
            <li>
            return the subtree shape
            </li>
            </ul>
            Instances may modify the subtree shape instances of the subtrees of the current
            root node and use the subtree shape obtained by the DataProvider as the return value.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.INodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an optional Processor for pre- and post-processing.</summary>
      <param name="layouter" />
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
      <remarks>Creates an optional Processor for pre- and post-processing.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.INodePlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method is called by GenericTreeLayouter before the subtree shapes of
            this local root node's children are calculated.
            </summary>
      <param name="localRoot">
            the local root node whose child nodes will be provided with
            a byte constant indicating the direction of the connector
            </param>
      <param name="connectorMap">
            the map that should be used for storing the byte constant
            with the child nodes.
            </param>
      <remarks>
            This method is called by GenericTreeLayouter before the subtree shapes of
            this local root node's children are calculated.
            This method must provide for each child node a byte constant indicating
            the preferred direction of the connector to the subtree shape.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.INodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main method of the tree layout algorithm.</summary>
      <param name="nodeShapeProvider">
            this instance can be used to obtain an initial shape
            of the root node. This shape can then be merged with all the subtrees' shapes
            and finally be returned by this method.
            </param>
      <param name="subtreeShapeProvider">
            provides access to the pre-calculated shapes of
            the subtrees. It is guaranteed that at the time of the invocation of this
            method for every child node the subtree shape has already been calculated
            </param>
      <param name="graph">the graph which is to be laid out</param>
      <param name="localRoot">the root of the subtree that should be laid out by this method</param>
      <param name="parentConnectorDirection">
            the direction byte constant as it is defined
            in this interface, that must be used for initializing the connector of the
            localRoot node to the parent node of the localRoot node
            </param>
      <returns>the shape of the whole subtree</returns>
      <remarks>
            The main method of the tree layout algorithm. This method arranges the
            SubtreeShapes and the shape of the local root, routes the edges to the
            SubtreeShapes, calculates the resulting SubtreeShape and returns it.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.IPortAssignment">
      <summary>
            This interface is used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            .
            </summary>
      <remarks>
            This interface is used by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            . Classes implementing
            this interface are responsible for the assignment of the edges' ports.
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            instances will have to obey the currently set ports.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.IPortAssignment.AssignPorts(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            before the actual layout
            of the graph takes place.
            </summary>
      <param name="graph">the graph instance the node is part of</param>
      <param name="node">the node whose adjacent edges' ports should be set</param>
      <remarks>
            Called by
            <see cref="T:yWorks.yFiles.Layout.Tree.GenericTreeLayouter" />
            before the actual layout
            of the graph takes place. This method assigns both the single
            incoming edge's target port as well as all source ports for all
            outgoing child edges. Note that at the time this method gets invoked,
            GenericTreeLayouter may have reversed some edges in order to normalize the
            tree structure.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.IProcessor">
      <summary>
            A processor is the possibility for each NodePlacer to prepare (and clean up) the graph for its children.<br />
            It is created within
            <see cref="M:yWorks.yFiles.Layout.Tree.INodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)" />
            and called by the
            GenericTreeLayouter at specific positions of the life-cycle.<br />
            The processor may change the values within the DataMaps for its children.
            </summary>
      <remarks>
            A processor is the possibility for each NodePlacer to prepare (and clean up) the graph for its children.<br />
            It is created within
            <see cref="M:yWorks.yFiles.Layout.Tree.INodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)" />
            and called by the
            GenericTreeLayouter at specific positions of the life-cycle.<br />
            The processor may change the values within the DataMaps for its children.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.IProcessor.PostProcess">
      <summary>This method is called from the GenericTreeLayouter after the layout has finished.</summary>
      <remarks>
            This method is called from the GenericTreeLayouter after the layout has finished. It can be used for
            cleanup tasks<br />.
            E.g. changes on the graph structure that have been made in
            <see cref="M:yWorks.yFiles.Layout.Tree.IProcessor.PreProcess(yWorks.yFiles.Algorithms.IDataMap,yWorks.yFiles.Algorithms.IDataMap,yWorks.yFiles.Algorithms.IDataMap)" />
            can be undone here.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.IProcessor.PreProcess(yWorks.yFiles.Algorithms.IDataMap,yWorks.yFiles.Algorithms.IDataMap,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>This method is called before the NodePlacers are called recursively.</summary>
      <param name="nodePlacerDataProvider" />
      <param name="portAssignmentDataProvider" />
      <param name="childComparatorProvider" />
      <remarks>
            This method is called before the NodePlacers are called recursively. A NodePlacer may change different
            settings within this method. This can be used to specify values for its children, manipulate the graph structure
            or do anything else that needs to be done.<br />
            But only changes for the descendants of current root are allowed.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.LayeredNodePlacer">
      <summary>This NodePlacer calculates and respects layers.</summary>
      <remarks>
            This NodePlacer calculates and respects layers.
            <p>
            <b>Warning:</b> Changing the orientation within the LayeredNodePlacers will
            result in dubious problems.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.LayeredNodePlacer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix,System.Object)">
      <summary>Default constructor.</summary>
      <param name="modificationMatrix">the translation for the NodePlacer</param>
      <remarks>Default constructor. Instantiates a new instance with the given modification matrix.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.BusAlignment">
      <summary>The actual set bus alignment.</summary>
      <remarks>
            Getter:<br />
            Returns the actual set bus alignment. The bus alignment represents the position of the "bus" within the spacing
            between the layers (
            <see cref="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.LayerSpacing" />
            ). 0: the bus is a the top of the space between the layers 0.5: the
            bus is exactly in the middle 1: the bus is at the bottom
            <para />
            Setter:<br />
            Sets the vertical alignment of the bus
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an processor that distributes the LayerRoot</summary>
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
      <remarks>Creates an processor that distributes the LayerRoot</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.DendrogramStyle" />
    <member name="M:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="child">the child node</param>
      <returns>
            a byte constant as defined in the
            <see cref="T:yWorks.yFiles.Layout.Tree.INodePlacer" />
            interface
            </returns>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.DistanceToParentMapDpKey">
      <summary>References a NodeMap that contains double values.</summary>
      <remarks>
            References a NodeMap that contains double values. Those values represent the distance between the center of the
            actual node and the center of its children
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.Id">
      <summary>The ID.</summary>
      <remarks>
            Returns the ID. The ID is used to identify LayeredNodePlacers that share information about their height. Using
            different IDs offers aligned layouts within different subtrees.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.LayerSpacing">
      <summary>The spacing between two layers.</summary>
      <remarks>Specifies the spacing between two layers.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>This method must be implemented by subclasses.</summary>
      <param name="localRoot">the local root node</param>
      <param name="parentConnectorDirection">the direction of the connector shape</param>
      <returns>a SubtreeShape instance that describes the shape of the whole subtree</returns>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.PolylineLabelingEnabled">
      <summary>Specifies whether polyline labeling is used.</summary>
      <remarks>
            Specifies whether polyline labeling should be used. <p> If set to <see langword="true" />, the poly line connectors
            between the parent and its children are added to the shape. Labels (of nodes and edges) will not cut them. </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.RootAlignment">
      <summary>The alignment strategy for the tree's root node.</summary>
      <remarks>Specifies the alignment strategy for the tree's root node.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.RoutingStyle">
      <summary>The routing style.</summary>
      <remarks>
            Specifies the routing style. The possible values are: <ul> <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.LayeredRoutingStyle.Orthogonal" />
            </li> <li>
            <see cref="F:yWorks.yFiles.Layout.Tree.LayeredRoutingStyle.Plain" />
            </li> </ul>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LayeredNodePlacer.VerticalAlignment">
      <summary>
            The relative vertical alignment of nodes within their respective
            layers.
            </summary>
      <remarks>
            Specifies the relative vertical alignment of nodes within their respective
            layers.
            A value of <c>0</c> means nodes are top aligned;
            a value of <c>1</c> means nodes are bottom aligned.
            <p>
            Defaults to <c>0.5</c>, i.e. nodes are center aligned.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.LayeredRoutingStyle">
      <summary>Layout style constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.LayeredRoutingStyle.Plain">
      <summary>Layout style constant. Draw edges as straight lines.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.LayeredRoutingStyle.Orthogonal">
      <summary>Layout style constant. Draw edges orthogonally in a bus-like fashion.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.LeafPlacer">
      <summary>This implementation can be used to "place" leafs.</summary>
      <remarks>
            This implementation can be used to "place" leafs.
            It only routes the first incoming edge.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeafPlacer.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.LeafPlacer" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeafPlacer.CreateProcessor(yWorks.yFiles.Layout.Tree.GenericTreeLayouter,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node)">
      <summary>Creates an optional Processor for pre- and post-processing.</summary>
      <param name="layouter" />
      <param name="graph">the actual graph</param>
      <param name="currentRoot">the actual root node for this node placer</param>
      <returns>a Processor or null</returns>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeafPlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>
            This method is called by GenericTreeLayouter before the subtree shapes of
            this local root node's children are calculated.
            </summary>
      <param name="localRoot">
            the local root node whose child nodes will be provided with
            a byte constant indicating the direction of the connector
            </param>
      <param name="connectorMap">
            the map that should be used for storing the byte constant
            with the child nodes.
            </param>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeafPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Algorithms.IDataProvider,yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>The main method of the tree layout algorithm.</summary>
      <param name="nodeShapeProvider">
            this instance can be used to obtain an initial shape
            of the root node. This shape can then be merged with all the subtrees' shapes
            and finally be returned by this method.
            </param>
      <param name="subtreeShapeProvider">
            provides access to the pre-calculated shapes of
            the subtrees. It is guaranteed that at the time of the invocation of this
            method for every child node the subtree shape has already been calculated
            </param>
      <param name="graph">the graph which is to be laid out</param>
      <param name="localRoot">the root of the subtree that should be laid out by this method</param>
      <param name="parentConnectorDirection">
            the direction byte constant as it is defined
            in this interface, that must be used for initializing the connector of the
            localRoot node to the parent node of the localRoot node
            </param>
      <returns>the shape of the whole subtree</returns>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.LeftRightPlacer">
      <summary>
            The LeftRightPlacer is a NodePlacer that arranges the Nodes on the left and
            right side of a vertical bus.
            </summary>
      <remarks>
            The LeftRightPlacer is a NodePlacer that arranges the Nodes on the left and
            right side of a vertical bus.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.#ctor">
      <summary>Creates a LeftRightPlacer with the default modificationMatrix</summary>
      <remarks>Creates a LeftRightPlacer with the default modificationMatrix</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Creates a LeftRightPlacer with the given modificationMatrix</summary>
      <remarks>Creates a LeftRightPlacer with the given modificationMatrix</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.CreateComparator">
      <summary>Returns <see langword="null" /> because no comparator exists for this node placer.</summary>
      <returns>
        <see langword="null" />
      </returns>
      <remarks>Returns <see langword="null" /> because no comparator exists for this node placer.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>Throws IllegalStateException, should not be reached.</summary>
      <exception cref="T:System.InvalidOperationException">always.</exception>
      <remarks>Throws IllegalStateException, should not be reached.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.DetermineChildConnectors(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Algorithms.IDataMap)">
      <summary>Determines the direction the children should place their connectors.</summary>
      <remarks>Determines the direction the children should place their connectors.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LeftRightPlacer.HorizontalDistance">
      <summary>The horizontal distance/spacing between subtree shapes.</summary>
      <remarks>
            Specifies the horizontal distance/spacing between subtree shapes.
            <p>
            By default, a value of <c>20</c> is used.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LeftRightPlacer.PlaceLastOnBottom">
      <summary>Specifies whether or not the last child is placed at the bottom of the other.</summary>
      <remarks>
            Specifies whether or not the last child is placed at the bottom of the other.
            <p>
            By default, this feature is enabled.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.LeftRightPlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>Places the shapes of the children on the left and right side of a vertical bus.</summary>
      <returns>the new subtree shape</returns>
      <remarks>Places the shapes of the children on the left and right side of a vertical bus.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LeftRightPlacer.Spacing">
      <summary>
            Specifies the spacing between subtrees this <c>NodePlacer</c> is
            arranging.
            </summary>
      <remarks>
            Specifies the spacing between subtrees this <c>NodePlacer</c> is
            arranging. Calls
            <blockquote>
            <c>setHorizontalDistance(spacing);</c><br />
            <c>setVerticalDistance(spacing);</c>
            </blockquote>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.LeftRightPlacer.VerticalDistance">
      <summary>The vertical distance/spacing between subtree shapes.</summary>
      <remarks>
            Specifies the vertical distance/spacing between subtree shapes.
            <p>
            By default, a value of <c>20</c> is used.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.NodeOrderComparator">
      <summary>
            This comparator compares edges by examining the
            <see cref="T:System.IComparable" />
            that is obtained by passing the
            <see cref="P:yWorks.yFiles.Algorithms.Edge.Target">target nodes</see>
            to
            the
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)">get method</see>
            of the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            bound to the graph via the
            <see cref="F:yWorks.yFiles.Layout.Tree.NodeOrderComparator.NodeOrderDpKey" />
            key.
            </summary>
      <remarks>
            This comparator compares edges by examining the
            <see cref="T:System.IComparable" />
            that is obtained by passing the
            <see cref="P:yWorks.yFiles.Algorithms.Edge.Target">target nodes</see>
            to
            the
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)">get method</see>
            of the
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            bound to the graph via the
            <see cref="F:yWorks.yFiles.Layout.Tree.NodeOrderComparator.NodeOrderDpKey" />
            key.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.NodeOrderComparator.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.NodeOrderComparator" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.NodeOrderComparator.Compare(System.Object,System.Object)">
      <summary>
            Object is actually expected to be
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            .
            </summary>
      <remarks>
            Object is actually expected to be
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            .
            Compares values returned by
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)" />
            for
            the
            <see cref="P:yWorks.yFiles.Algorithms.Edge.Target">target nodes</see>
            of the edges.
            <see langword="null" /> values or instances that do not implement the
            <see cref="T:System.IComparable" />
            interface will be treated as (equal) smaller values.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.NodeOrderComparator.NodeOrderDpKey">
      <summary>
            A data provider key that can be used to register a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            for each
            <see cref="T:yWorks.yFiles.Algorithms.Node" />
            in the graph that yields a
            <see cref="T:System.IComparable" />
            object
            via the
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)" />
            method.
            </summary>
      <remarks>
            A data provider key that can be used to register a
            <see cref="T:yWorks.yFiles.Algorithms.IDataProvider" />
            for each
            <see cref="T:yWorks.yFiles.Algorithms.Node" />
            in the graph that yields a
            <see cref="T:System.IComparable" />
            object
            via the
            <see cref="M:yWorks.yFiles.Algorithms.IDataProvider.Get(System.Object)" />
            method.
            The values can be used by the various tree layouter implementations to sort the children
            of each node in the tree and use the order to influence the layout.
            To achieve this use this comparator and assign it to the layouter implementations
            comparator property.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.Orientation">
      <summary>Orientation specifier.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.Orientation.Horizontal">
      <summary>Orientation specifier. Node shapes will be aligned on the x-axis.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.Orientation.Vertical">
      <summary>Orientation specifier. Node shapes will be aligned on the y-axis.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.ParentConnectorDirection" />
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.None">
      <summary>
            Byte constant that is as argument to the main method, indicating that no connector
            should be calculated.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.Any">
      <summary>
            Byte constant that is an argument to the main method, indicating that any connector
            direction can be used for the connection to the parent node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North">
      <summary>
            Byte constant that is an argument to the main method, indicating that the connector
            direction to the parent node should end in a segment that can be extended by a segment
            that goes into north direction.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.East">
      <summary>
            Byte constant that is an argument to the main method, indicating that the connector
            direction to the parent node should end in a segment that can be extended by a segment
            that goes into east direction.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.South">
      <summary>
            Byte constant that is an argument to the main method, indicating that the connector
            direction to the parent node should end in a segment that can be extended by a segment
            that goes into south direction.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.West">
      <summary>
            Byte constant that is an argument to the main method, indicating that the connector
            direction to the parent node should end in a segment that can be extended by a segment
            that goes into west direction.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.PortAssignmentMode" />
    <member name="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.PortConstraint">
      <summary>
            Mode constant describing the strategy where edges having
            <ul><li>
            a weak port constraint, i.e., effectively a side constraint, will be anchored
            at the center of that side
            </li><li>
            no port constraint set will be anchored at the center of the node
            </li></ul>
            Edges having a strong port constraint are anchored at that coordinates.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.PortAssignmentMode.Node">
      <summary>
            Mode constant describing the strategy where all ports are reset to the center
            of their nodes.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.PortStyle">
      <summary>Port style constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.PortStyle.NodeCenter">
      <summary>Port style constant. Uses (0,0) as port offset.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.PortStyle.BorderCenter">
      <summary>Port style constant. Ports will lie at the center of a node border.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.PortStyle.BorderDistributed">
      <summary>Port style constant. Ports will be distributed evenly on the side of a node.</summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.RootAlignment">
      <summary>Alignment byte constant used for the <c>rootAlignment</c> property.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.LeadingOffset">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant places the root ahead of all the child subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.Leading">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant aligns the root with the first of its subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.Center">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant aligns the root at the center of its subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.Median">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant aligns the root at the median of the connection points to its subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.Trailing">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant aligns the root at with the last of its subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.TrailingOffset">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant places the root after all of its subtrees.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.TrailingOnBus">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant places the root after all of its subtrees and centered on the bus.
            <p>
            Note: The vertical/horizontal distance between the root node and the subtree shapes depend on the value
            of parameters verticalDistance/horizontalDistance passed to the Constructor.
            </p></summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootAlignment.LeadingOnBus">
      <summary>
            Alignment byte constant used for the <c>rootAlignment</c> property.
            This constant places the root ahead of all the child subtrees and centered on the bus.
            <p>
            Note: The vertical/horizontal distance between the root node and the subtree shapes depend on the value
            of parameters verticalDistance/horizontalDistance passed to the Constructor.
            </p></summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.RootNodePolicy">
      <summary>Root node policy specifier constant.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootNodePolicy.DirectedRoot">
      <summary>
            Root node policy specifier constant. A node with indegree 0
            is chosen as root node of the tree. If no node with that property
            is present the an arbitrary node is chosen.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootNodePolicy.CenterRoot">
      <summary>
            Root node policy specifier constant. A center node
            will be chosen as root node of the tree.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RootNodePolicy.WeightedCenterRoot">
      <summary>
            Root node policy specifier constant. A weighted center node
            will be chosen as root node of the tree.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.RoutingStyle">
      <summary>Routing style byte constant used for the <c>routingStyle</c> property.</summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Fork">
      <summary>
            Routing style byte constant used for the <c>routingStyle</c> property.
            Using this value will result in orthogonally routed child node
            connectors where the bends are placed in the channel between the
            root node and the child nodes.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RoutingStyle.ForkAtRoot">
      <summary>
            Routing style byte constant used for the <c>routingStyle</c> property.
            Using this value will result in orthogonally routed child node
            connectors with one bend each placed next to the root node.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RoutingStyle.Straight">
      <summary>
            Routing style byte constant used for the <c>routingStyle</c> property.
            Using this value will result in straight connections to the child nodes.
            Edges may overlap nodes in this case.
            </summary>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.RoutingStyle.PolyLine">
      <summary>
            Routing style byte constant used for the <c>routingStyle</c> property.
            Using this value will result in straight connections to the connector of the subtree.
            </summary>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.SimpleNodePlacer">
      <summary>This is a "default" NodePlacer.</summary>
      <remarks>
            This is a "default" NodePlacer.
            It arranges its children simply in one row.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.#ctor">
      <summary>
            Default constructor that creates an instance with the modification matrix
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Default" /></summary>
      <remarks>
            Default constructor that creates an instance with the modification matrix
            <see cref="F:yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix.Default" />
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix)">
      <summary>Constructor that creates an instance with the given modification matrix.</summary>
      <remarks>Constructor that creates an instance with the given modification matrix.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.#ctor(yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.Matrix,yWorks.yFiles.Layout.Tree.AbstractRotatableNodePlacer.RootAlignment)">
      <summary>Constructor that creates an instance with the given modification matrix and the horizontal root alignment</summary>
      <remarks>Constructor that creates an instance with the given modification matrix and the horizontal root alignment</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.CreateBus">
      <summary>Specifies whether a bus should be created between the parent and its children.</summary>
      <remarks>Specifies whether a bus should be created between the parent and its children.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.DetermineChildConnector(yWorks.yFiles.Algorithms.Node)">
      <summary>
            Returns
            <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North" />
            .
            </summary>
      <returns>
        <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North" />
            .
            </returns>
      <remarks>
            Returns
            <see cref="F:yWorks.yFiles.Layout.Tree.ParentConnectorDirection.North" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.PlaceSubtree(yWorks.yFiles.Algorithms.Node,yWorks.yFiles.Layout.Tree.ParentConnectorDirection)">
      <summary>Places the children in a single row.</summary>
      <remarks>Places the children in a single row.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.SimpleNodePlacer.RootAlignment">
      <summary>The horizontal alignment of the root node.</summary>
      <remarks>Specifies the horizontal alignment of the root node.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.SubtreeShapeRotated">
      <summary>Decorates a SubtreeShape and provides rotated access on it.</summary>
      <remarks>Decorates a SubtreeShape and provides rotated access on it.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.SubtreeShapeRotated.#ctor">
      <summary>For testing purposes only</summary>
      <remarks>For testing purposes only</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.TreeComponentLayouter">
      <summary>
            This stage can be used to do mix layouts for tree-like subgraph structures and
            the non-tree like rest of a graph.
            </summary>
      <remarks>
            This stage can be used to do mix layouts for tree-like subgraph structures and
            the non-tree like rest of a graph.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.#ctor(yWorks.yFiles.Layout.ILayouter)">
      <summary>
            Creates a new instance of TreeComponentLayouter using the specified
            layouter for laying out the subtrees.
            </summary>
      <remarks>
            Creates a new instance of TreeComponentLayouter using the specified
            layouter for laying out the subtrees.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>
            Returns <see langword="true" /> iff the given graph can be laid
            out by this algorithm.
            </summary>
      <remarks>
            Returns <see langword="true" /> iff the given graph can be laid
            out by this algorithm. Calling <c>doLayout</c> with
            the given graph as its argument will only success if
            this method returns <see langword="true" />.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.CoreLayouter">
      <summary>The core layouter.</summary>
      <remarks>Specifies the core layouter.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Assigns a new graph layout to the given layout graph.</summary>
      <remarks>Assigns a new graph layout to the given layout graph.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.DoLayoutUsingDummies(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IDataProvider)">
      <summary>
            Called by
            <see cref="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            to delegate to the
            <see cref="P:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.CoreLayouter" />
            , adding the dummy provider to the graph instance.
            </summary>
      <remarks>
            Called by
            <see cref="M:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
            to delegate to the
            <see cref="P:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.CoreLayouter" />
            , adding the dummy provider to the graph instance.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.DummyNodeDpKey">
      <summary>
            During the main run of the layout dummy nodes can be identified by looking
            at the value of the registered DataProvider which can be obtained from
            the graph using this key.
            </summary>
      <remarks>
            During the main run of the layout dummy nodes can be identified by looking
            at the value of the registered DataProvider which can be obtained from
            the graph using this key.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.OrientationOptimizationActive">
      <summary>
        <see langword="true" /> if this layouter tries to improve tree component
            placement by changing the components orientation and <see langword="false" />
            otherwise.
            </summary>
      <remarks>
            Getter:<br />
            Returns <see langword="true" /> if this layouter tries to improve tree component
            placement by changing the components orientation and <see langword="false" />
            otherwise.
            <para />
            Setter:<br />
            Specifies whether this layouter should try to improve tree component
            placement by changing the components orientation.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeComponentLayouter.TreeComponentCoreLayouter">
      <summary>The core layouter used for tree components.</summary>
      <remarks>Specifies the core layouter used for tree components.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.TreeLayouter">
      <summary>Implementation of a layout algorithm for trees.</summary>
      <remarks>
            Implementation of a layout algorithm for trees.
            <p />
            Here is an sample output of the layouter using left to right orientation and
            <see cref="F:yWorks.yFiles.Layout.Tree.EdgeLayoutStyle.Orthogonal" />
            layout style.
            <p />
            <center><img src="doc-files/y.layout.tree.TreeLayouter.gif" border="1" /></center>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeLayouter.#ctor">
      <summary>Creates a new instance of TreeLayouter.</summary>
      <remarks>Creates a new instance of TreeLayouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.BusAlignment">
      <summary>The actual set bus alignment.</summary>
      <remarks>
            Getter:<br />
            Returns the actual set bus alignment. The bus alignment represents the position of the "bus" within the spacing
            between the layers (
            <see cref="P:yWorks.yFiles.Layout.Tree.TreeLayouter.MinimalLayerDistance" />
            ). 0: the bus is a the top of the space between the layers
            0.5: the bus is exactly in the middle 1: the bus is at the bottom
            <para />
            Setter:<br />
            Sets the vertical alignment of the bus
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeLayouter.CanLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns true iff the core layouter can layout the given graph structure.</summary>
      <remarks>Returns true iff the core layouter can layout the given graph structure. This is the case iff the graph is a tree.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.ChildPlacementPolicy">
      <summary>The layout policy for leaf nodes.</summary>
      <exception cref="T:System.ArgumentException">if the specified policy does not match one of the leaf layout policy constants.</exception>
      <remarks>
            Specifies the layout policy for leaf nodes.
            <p>
            Defaults to
            <see cref="F:yWorks.yFiles.Layout.Tree.ChildPlacementPolicy.SiblingsOnSameLayer" />
            .
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.Comparator">
      <summary>
            The comparator for outgoing edges at a node This comparator defines the relative order of the child nodes
            in the layout to be calculated.
            </summary>
      <remarks>
            Specifies the comparator for outgoing edges at a node This comparator defines the relative order of the child nodes in
            the layout to be calculated. By default
            <see cref="T:yWorks.yFiles.Layout.Tree.XCoordComparator" />
            is set.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeLayouter.DoLayoutCore(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Starts the tree layout process</summary>
      <remarks>Starts the tree layout process</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.EnforceGlobalLayering">
      <summary>Specifies whether or not global layering is enforced.</summary>
      <remarks>
            Specifies whether or not global layering is enforced.
            If this feature is enabled, the algorithm ensures that nodes never span
            more than one layer. Otherwise, a large node might span two, three, etc
            layers of smaller nodes to produce a more compact layout.
            <p>
            Disabling this feature to generate more compact layouts will usually
            result in the algorithm ignoring the specified relative vertical alignment
            for nodes.
            </p><p>
            By default, this feature is enabled.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.GroupingSupported">
      <summary>True if grouping support is enabled.</summary>
      <remarks>
            Whether or not grouping support should be enabled. Note that the grouping only works correctly, if each group
            represents a complete subtree. This means that for each group there is a node v such that the group contains
            exactly v and all its descendants.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.IntegratedEdgeLabeling">
      <summary>Specifies whether integrated edge labeling is enabled.</summary>
      <remarks>Specifies whether integrated edge labeling is enabled.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.IntegratedNodeLabeling">
      <summary>Specifies whether integrated node labeling is enabled.</summary>
      <remarks>Specifies whether integrated node labeling is enabled.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.LayoutStyle">
      <summary>The layout style of this layouter.</summary>
      <remarks>Specifies the layout style of this layouter.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.MinimalLayerDistance">
      <summary>The minimal distance between adjacent layers for the layout.</summary>
      <remarks>Specifies the minimal distance between adjacent layers for the layout. Default value is 40.0.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.MinimalNodeDistance">
      <summary>The minimum horizontal distance between adjacent nodes for this layouter.</summary>
      <remarks>
            Setter:<br />
            Sets the minimum distance between adjacent nodes within a layer. Default value is 20.0.
            <para />
            Getter:<br />
            Returns the minimum horizontal distance between adjacent nodes for this layouter.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.ModificationMatrix">
      <summary>The modification matrix that is used to rotate / mirror the tree layout.</summary>
      <remarks>Specifies the modification matrix that is used to rotate / mirror the tree layout.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.PortStyle">
      <summary>The port assignment style.</summary>
      <remarks>Specifies the port assignment style.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeLayouter.VerticalAlignment">
      <summary>
            The relative vertical alignment of nodes within their respective
            layers.
            </summary>
      <remarks>
            Specifies the relative vertical alignment of nodes within their respective
            layers.
            A value of <c>0</c> means nodes are top aligned;
            a value of <c>1</c> means nodes are bottom aligned.
            <p>
            If global layering is not enforced, the value of this property is usually
            ignored.
            </p><p>
            Defaults to <c>0.5</c>, i.e. nodes are center aligned.
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.TreeReductionStage">
      <summary>
            This stage can be used to layout non-tree structures with a
            tree layout algorithm.
            </summary>
      <remarks>
            This stage can be used to layout non-tree structures with a
            tree layout algorithm.
            First this stage transforms a graph into a tree or forest by removing some
            edges.
            Then it invokes the core layout algorithm on the reduced graph.
            Finally, it reinserts the hidden non-tree edges to the graph
            again and optionally routes these edges.
            <p>
            Typical usage:
            </p>
            <pre>
            TreeLayouter tl = new TreeLayouter();
            TreeReductionStage trs = new TreeReductionStage();
            trs.setNonTreeEdgeRouter(new OrganicEdgeRouter());
            trs.setNonTreeEdgeSelectionKey(OrganicEdgeRouter.ROUTE_EDGE_DPKEY);
            tl.appendStage(trs);
            new BufferedLayouter(tl).doLayout(graph);
            tl.removeStage(trs);
            </pre>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeReductionStage.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.TreeReductionStage" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeReductionStage.CanLayout(yWorks.yFiles.Layout.LayoutGraph)">
      <summary>Returns <see langword="true" />.</summary>
      <remarks>Returns <see langword="true" />.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeReductionStage.CreateStraightlineRouter">
      <summary>
            Creates a layouter that can be used to route all non-tree edges
            as a single straight-line segment.
            </summary>
      <remarks>
            Creates a layouter that can be used to route all non-tree edges
            as a single straight-line segment.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeReductionStage.DoLayout(yWorks.yFiles.Layout.LayoutGraph)" />
    <member name="P:yWorks.yFiles.Layout.Tree.TreeReductionStage.NonTreeEdgeRouter">
      <summary>The currently set edge router for non-tree edges.</summary>
      <remarks>
            Getter:<br />
            Returns the currently set edge router for non-tree edges.
            <para />
            Setter:<br />
            Sets the edge router for non-tree edges. Very often, this method should
            be used in conjunction with
            <see cref="P:yWorks.yFiles.Layout.Tree.TreeReductionStage.NonTreeEdgeSelectionKey" />
            to
            control the set of edges that should be handled by the edge router.
            </remarks>
    </member>
    <member name="F:yWorks.yFiles.Layout.Tree.TreeReductionStage.NonTreeEdgesDpKey">
      <summary>
            DataProvider key that can be used to explicitly mark (some) edges
            that should not be considered to belong to a tree.
            </summary>
      <remarks>
            DataProvider key that can be used to explicitly mark (some) edges
            that should not be considered to belong to a tree.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Layout.Tree.TreeReductionStage.NonTreeEdgeSelectionKey">
      <summary>The currently set non-tree edge selection key.</summary>
      <remarks>
            Getter:<br />
            Returns the currently set non-tree edge selection key.
            <para />
            Setter:<br />
            Sets the DataProvider key that will be used by the non-tree edge
            router to determine the set of edges that should be routed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.TreeReductionStage.RouteNonTreeEdges(yWorks.yFiles.Layout.LayoutGraph,yWorks.yFiles.Algorithms.IEdgeMap)">
      <summary>Routes the non-tree edges.</summary>
      <param name="graph">graph that can contain tree and non-tree edges.</param>
      <param name="nonTreeEdgeMap">
            an edge map that marks all non-tree edges
            in the graph with boolean value <see langword="true" />.
            </param>
      <remarks>Routes the non-tree edges.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Layout.Tree.XCoordComparator">
      <summary>
            This comparator compares edges by examining the x-coordinates of the centers
            of their target nodes.
            </summary>
      <remarks>
            This comparator compares edges by examining the x-coordinates of the centers
            of their target nodes.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.XCoordComparator.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Layout.Tree.XCoordComparator" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Layout.Tree.XCoordComparator.Compare(System.Object,System.Object)">
      <summary>
            Object is actually expected to be
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            .
            </summary>
      <remarks>
            Object is actually expected to be
            <see cref="T:yWorks.yFiles.Algorithms.Edge" />
            .
            Compares the x-coordinates of the centers of the target nodes.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.CollectionFactory">
      <summary>
            A factory class that creates instances of the classes implementing
            <see cref="T:yWorks.yFiles.Util.ICollection" />
            .
            </summary>
      <remarks>
            A factory class that creates instances of the classes implementing
            <see cref="T:yWorks.yFiles.Util.ICollection" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.CollectionFactory.CreateArrayList">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.ArrayList" />
            .
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.ArrayList" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.ArrayList" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.CollectionFactory.CreateArrayList(yWorks.yFiles.Util.ICollection)">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.ArrayList" />
            with the contents of the specified
            collection.
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.ArrayList" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.ArrayList" />
            with the contents of the specified
            collection.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.CollectionFactory.CreateHashSet">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.HashSet" />
            .
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.HashSet" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.HashSet" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.CollectionFactory.CreateHashSet(yWorks.yFiles.Util.ICollection)">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.HashSet" />
            with the contents of the specified
            collection.
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.HashSet" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.HashSet" />
            with the contents of the specified
            collection.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.CollectionFactory.CreateTreeSet">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.TreeSet" />
            .
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.TreeSet" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.TreeSet" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.CollectionFactory.CreateTreeSet(yWorks.yFiles.Util.ICollection)">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.TreeSet" />
            with the contents of the specified
            collection.
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.TreeSet" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.TreeSet" />
            with the contents of the specified
            collection.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.ICollection">
      <summary>The basic interface in the hierarchy of collection classes.</summary>
      <remarks>
            The basic interface in the hierarchy of collection classes.
            <p>
            A collection contains a number of items. These may or may not be in a
            specific order. The collection may or may not contain duplicate items.
            </p>
            <p>
            A collection allows adding and removing single as well as whole
            collections of items.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Add(System.Object)">
      <summary>Adds the given item to this collection.</summary>
      <param name="o">the object to add to the collection</param>
      <returns>
        <see langword="true" /> if this collection has been modified due to the call of this method.</returns>
      <remarks>Adds the given item to this collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.AddAll(yWorks.yFiles.Util.ICollection)">
      <summary>Adds all items of the given collection to this collection.</summary>
      <param name="c">the collection which items should be added to this collection.</param>
      <returns>
        <see langword="true" /> if this collection has been modified due to the call of this method.</returns>
      <remarks>Adds all items of the given collection to this collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Clear">
      <summary>Removes all items in this collection.</summary>
      <remarks>Removes all items in this collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Contains(System.Object)">
      <summary>Checks if this collection contains the given item.</summary>
      <param name="o">the item to check.</param>
      <returns>
        <see langword="true" /> if this collection contains the given item.</returns>
      <remarks>Checks if this collection contains the given item.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.ContainsAll(yWorks.yFiles.Util.ICollection)">
      <summary>Checks if this collection contains all the items of the given collection.</summary>
      <param name="c">the collection that contains the items to check.</param>
      <returns>
        <see langword="true" /> if this collection contains all the items of the given collection.</returns>
      <remarks>Checks if this collection contains all the items of the given collection.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.ICollection.Count">
      <summary>The number of elements in this collection.</summary>
      <remarks>Returns the number of elements in this collection.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.ICollection.Empty">
      <summary>Checks if this collection is empty.</summary>
      <remarks>Checks if this collection is empty.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Equals(System.Object)">
      <summary>Checks if this collection is equal to the given object.</summary>
      <param name="o">the object to check equality with.</param>
      <returns>
        <see langword="true" /> if this collection is equal to the given object.</returns>
      <remarks>Checks if this collection is equal to the given object.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.GetHashCode">
      <summary>Gets the hash code of this collection.</summary>
      <returns>the hash code of this collection.</returns>
      <remarks>Gets the hash code of this collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Iterator">
      <summary>Gets an iterator for the items of this collection.</summary>
      <returns>an iterator for the items of this collection.</returns>
      <remarks>Gets an iterator for the items of this collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.Remove(System.Object)">
      <summary>Removes the given item from this collection.</summary>
      <param name="o">the item to remove from the collection.</param>
      <returns>
        <see langword="true" /> if this collection has been modified due to the call of this method.</returns>
      <remarks>Removes the given item from this collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.RemoveAll(yWorks.yFiles.Util.ICollection)">
      <summary>Removes all items of the given collection from this collection.</summary>
      <param name="c">the collection which items should be removed from this collection.</param>
      <returns>
        <see langword="true" /> if this collection has been modified due to the call of this method.</returns>
      <remarks>Removes all items of the given collection from this collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.RetainAll(yWorks.yFiles.Util.ICollection)">
      <summary>Keeps all the items in this collection that are contained in the given collection.</summary>
      <param name="c">The collection that contains the items that should be retained.</param>
      <returns>
        <see langword="true" /> if this collection has been modified due to the call of this method.</returns>
      <remarks>
            Keeps all the items in this collection that are contained in the given collection.
            items that are not part of the given collection are removed.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.ToArray">
      <summary>Creates an array containing the items of this collection.</summary>
      <returns>a new array with the items of this collection.</returns>
      <remarks>Creates an array containing the items of this collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ICollection.ToArray(System.Array)">
      <summary>Copies the content of this collection to an array.</summary>
      <param name="a">an optional array to use.</param>
      <returns>an array with the same content as this collection.</returns>
      <remarks>
            Copies the content of this collection to an array. If an array is given and it is large enough, the given array is
            used to copy the content to. Otherwise, a new array is created.
            <p />
            If the given array is larger than this collection, the first array element after the content is set to null.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.IComparator">
      <summary>Compares two arbitrary objects.</summary>
      <remarks>
            Compares two arbitrary objects.
            <p>
            Comparing two objects allows to assign an order to a number of elements.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IComparator.Compare(System.Object,System.Object)">
      <summary>Compares the two given objects.</summary>
      <param name="o1">the first object to compare.</param>
      <param name="o2">the object to compare the first object with.</param>
      <returns>
            a negative integer if the first argument is considered less than that the second,
            zero if both objects are considered equally great and positive if the first argument is considered
            greater.
            </returns>
      <remarks>
            Compares the two given objects.
            <p>
            The return value is negative if the first argument is considered less than that the second,
            zero if both objects are considered equally great and positive if the first argument is considered
            greater.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IComparator.Equals(System.Object)" />
    <member name="T:yWorks.yFiles.Util.IIterator">
      <summary>An iterator over the items of a collection.</summary>
      <remarks>
            An iterator over the items of a collection.
            <p>
            Iterators allow to iterate over the items of a collection one-by-one as
            well as remove the item last iterated over from the list.
            </p>
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.IIterator.HasNext">
      <summary>Checks if there is another item in the collection.</summary>
      <remarks>Checks if there is another item in the collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IIterator.Next">
      <summary>Gets the next item in the collection.</summary>
      <returns>the next item in the collection.</returns>
      <remarks>Gets the next item in the collection.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IIterator.Remove">
      <summary>Returns from the collection the last element returned by <c>next()</c>.</summary>
      <remarks>Returns from the collection the last element returned by <c>next()</c>.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.IList">
      <summary>An ordered collection of items.</summary>
      <remarks>
            An ordered collection of items.
            <p>
            Items can be appended as well as inserted at a specific index. Also, items
            can be retrieved or removed from the list at a certain position using an
            integer index.
            </p>
            <p>
            A list, unlike a set, can contain the same item more than once at distinct
            positions.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Add(System.Int32,System.Object)">
      <summary>Adds the given object to the collection at the specified index.</summary>
      <param name="index">the index at which to insert the item</param>
      <param name="item">the item to insert</param>
      <remarks>
            Adds the given object to the collection at the specified index.
            <p>
            All subsequent items are shifted to the right one step.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Add(System.Object)">
      <summary>Appends the given item at the end of the list.</summary>
      <param name="o">the object to add</param>
      <returns>
        <see langword="true" /> if this list has been modified due to the call of this method.</returns>
      <remarks>Appends the given item at the end of the list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.AddAll(System.Int32,yWorks.yFiles.Util.ICollection)">
      <summary>Adds all items of the given collection at the specified index.</summary>
      <param name="index">the index at which to insert the items.</param>
      <param name="c">the collection whose items will be added.</param>
      <returns>
        <see langword="true" /> if this list has been modified due to the call of this method.</returns>
      <remarks>
            Adds all items of the given collection at the specified index.
            <p>
            All subsequent items are shifted to the right by the number of items added.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.AddAll(yWorks.yFiles.Util.ICollection)">
      <summary>Appends all items of the given collection at the end of this list.</summary>
      <param name="c">the collection which items should be added.</param>
      <returns>
        <see langword="true" /> if this list has been modified due to the call of this method.</returns>
      <remarks>Appends all items of the given collection at the end of this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Clear">
      <summary>
            Clears this collection and makes it empty.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Contains(System.Object)">
      <summary>
            Determines whether the provided object is part of this collection.
            </summary>
    </member>
    <member name="P:yWorks.yFiles.Util.IList.Count">
      <summary>
            Yields the number of items in this collection.
            </summary>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Get(System.Int32)">
      <summary>Returns the item at the specified index.</summary>
      <param name="index">the index of the item that is retrieved.</param>
      <returns>the item at the specified index.</returns>
      <remarks>Returns the item at the specified index.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.IndexOf(System.Object)">
      <summary>
            Returns the index of first occurrence of the specified item in this list,
            or -1 if the list does not contain the object.
            </summary>
      <param name="o">the item whose index is being returned.</param>
      <returns>the index of the specified item, or -1.</returns>
      <remarks>
            Returns the index of first occurrence of the specified item in this list,
            or -1 if the list does not contain the object.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.LastIndexOf(System.Object)">
      <summary>
            Returns the index of the last occurrence of the specified item in this list,
            or -1 if the list does not contain the object.
            </summary>
      <param name="o">the item whose last index is being returned.</param>
      <returns>the index of last occurrence of the specified item, or -1.</returns>
      <remarks>
            Returns the index of the last occurrence of the specified item in this list,
            or -1 if the list does not contain the object.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.ListIterator">
      <summary>
            Returns a list iterator that can be used to iterate over all items of this list
            in correct order.
            </summary>
      <returns>a list iterator that iterates over the items of this list.</returns>
      <remarks>
            Returns a list iterator that can be used to iterate over all items of this list
            in correct order.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.ListIterator(System.Int32)">
      <summary>
            Returns a list iterator that can be used to iterate over all items of this list
            in correct order.
            </summary>
      <param name="index">the index at which to start the iteration.</param>
      <returns>
            a list iterator that iterates over the items of this list, starting at the
            specified index.
            </returns>
      <remarks>
            Returns a list iterator that can be used to iterate over all items of this list
            in correct order. The iteration starts at the specified index.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Remove(System.Int32)">
      <summary>Removes the object at the specified index.</summary>
      <param name="index">the index of the item to be removed.</param>
      <returns>the object previously at the specified position</returns>
      <remarks>
            Removes the object at the specified index.
            <p>
            All subsequent list items are shifted to the left by one step.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Remove(System.Object)">
      <summary>Removes the first occurrence of the given item from this list.</summary>
      <param name="o">the item to remove.</param>
      <returns>
        <see langword="true" /> if this collection has been modified due to the call of this method.</returns>
      <remarks>Removes the first occurrence of the given item from this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.RemoveAll(yWorks.yFiles.Util.ICollection)">
      <summary>Removes all items of the given collection from this list.</summary>
      <param name="c">the collection which items should be removed from this collection.</param>
      <returns>
        <see langword="true" /> if this collection has been modified due to the call of this method.</returns>
      <remarks>Removes all items of the given collection from this list.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.Set(System.Int32,System.Object)">
      <summary>Replaces the item at the specified index with the given item.</summary>
      <param name="index">the index at which to replace the item.</param>
      <param name="item">the item which should be set at the specified index.</param>
      <returns>the item that was previously at the specified index.</returns>
      <remarks>Replaces the item at the specified index with the given item.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IList.SubList(System.Int32,System.Int32)">
      <summary>Returns a list that contains the specified range of items in this list.</summary>
      <param name="fromIndex">the index of the item that is the first element of the returned list.</param>
      <param name="toIndex">
            the end index the returned list. The item at this index is not included
            in the returned list.
            </param>
      <returns>a list that contains the items of this list in the specified range.</returns>
      <remarks>Returns a list that contains the specified range of items in this list.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.IListIterator">
      <summary>Iterates over a list of items either forwards or backwards.</summary>
      <remarks>
            Iterates over a list of items either forwards or backwards.
            <p>
            Also allows to insert items into the list at the current
            position.
            </p>
            <p>
            The cursor can be regarded as being located between two list items. There
            is no current, but only a next and a previous item.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.Add(System.Object)">
      <summary>Adds an item to the list next to the current cursor position.</summary>
      <param name="o">the item to be added.</param>
      <remarks>Adds an item to the list next to the current cursor position.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.IListIterator.HasPrevious">
      <summary>Checks if there is an item before the current cursor position.</summary>
      <remarks>Checks if there is an item before the current cursor position.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.NextIndex">
      <summary>Gets the index of the next element.</summary>
      <returns>
            the index of the next element, or the size of the list if there is
            no next item.
            </returns>
      <remarks>Gets the index of the next element.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.Previous">
      <summary>Get the element before the current cursor position.</summary>
      <returns>the element before the current cursor position.</returns>
      <remarks>Get the element before the current cursor position.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.PreviousIndex">
      <summary>Gets the index of the previous element.</summary>
      <returns>
            the index of the previous element, or -1 if there is
            no previous item.
            </returns>
      <remarks>Gets the index of the previous element.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IListIterator.Set(System.Object)">
      <summary>
            Assigns the specified object to the index of the element that was last
            returned by <c>next()</c> or <c>previous()</c>.
            </summary>
      <param name="o">the item which to set at the index of the last item.</param>
      <remarks>
            Assigns the specified object to the index of the element that was last
            returned by <c>next()</c> or <c>previous()</c>. The item
            previously at this position is replaced.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.IMap">
      <summary>An interface for objects that store associations between <i>keys</i> and <i>values</i>.</summary>
      <remarks>
            An interface for objects that store associations between <i>keys</i> and <i>values</i>.
            <p>
            Maps are also known as <i>dictionaries</i> or <i>associative arrays</i> and map each element in the
            <see cref="M:yWorks.yFiles.Util.IMap.KeySet" />
            collection
            to exactly one element in the
            <see cref="M:yWorks.yFiles.Util.IMap.Values" />
            collection (which may be  <see langword="null" />). Each key-value pair is represented by
            an instance of
            <see cref="T:yWorks.yFiles.Util.IMapEntry" />
            . The set of all key-value pairs can be accessed through the
            <see cref="M:yWorks.yFiles.Util.IMap.EntrySet" />
            collection.
            </p>
            <p>
            This interface does not impose restrictions on the <i>order</i> of the entries and on the
            type of either keys or values. Concrete implementations may thus allow or disallow <see langword="null" /> keys or impose a specific order of the entries.
            </p>
            <p>
            Note that the behavior is undefined if you use mutable objects as keys and change them in a way that affects equality comparisons
            with other keys as long as the object is used as key in the map.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Clear">
      <summary>Clears all mappings from this instance.</summary>
      <remarks>Clears all mappings from this instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.ContainsKey(System.Object)">
      <summary>Returns <see langword="true" /> if the given object is currently mapped to a (possibly <see langword="null" />) value.</summary>
      <param name="key">The object whose use as a key is checked.</param>
      <returns>
        <see langword="true" /> if <c>key</c> is currently mapped to a value.</returns>
      <remarks>Returns <see langword="true" /> if the given object is currently mapped to a (possibly <see langword="null" />) value.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.ContainsValue(System.Object)">
      <summary>Returns <see langword="true" /> if the given object is currently associated to at least one key.</summary>
      <param name="value">The object whose use as a key is checked.</param>
      <returns>
        <see langword="true" /> if <c>value</c> is currently associated to at least one key.</returns>
      <remarks>Returns <see langword="true" /> if the given object is currently associated to at least one key.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.IMap.Empty">
      <summary>
        <see langword="true" /> iff this map does not contain any entries.</summary>
      <remarks>Returns <see langword="true" /> iff this map does not contain any entries.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.EntrySet">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Util.ISet" />
            of all key-value mappings in this map.
            </summary>
      <returns>The set of key-value mappings in this instance.</returns>
      <remarks>
            The
            <see cref="T:yWorks.yFiles.Util.ISet" />
            of all key-value mappings in this map.
            <p>
            The entries are of type
            <see cref="T:yWorks.yFiles.Util.IMapEntry" />
            . This is a live view on the map entries in the sense that
            changes in the map are automatically reflected in this collection and vice-versa.
            </p>
            <p>
            Note that modifications on the map instance while iterating over the set are not supported (i.e. the behavior is undefined)
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Equals(System.Object)">
      <summary>Returns whether <c>o</c> is equal to this instance.</summary>
      <param name="o">The object that is compared for equality with this instance</param>
      <returns>
        <see langword="true" /> when both objects are equal.</returns>
      <remarks>
            Returns whether <c>o</c> is equal to this instance.
            <c>o</c> and this instance are considered equal when <c>o</c>
            is also a <c>Map</c> and both
            <see cref="M:yWorks.yFiles.Util.IMap.EntrySet" />
            s are equal.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Get(System.Object)">
      <summary>Retrieves the value that <c>key</c> maps to.</summary>
      <param name="key">The key object for which the mapped value is requested.</param>
      <returns>The value to which the specified key is mapped, or <see langword="null" /> if no such mapping exists.</returns>
      <remarks>
            Retrieves the value that <c>key</c> maps to.
            If no mapping for <c>key</c> exists, this method returns <see langword="null" />. A <see langword="null" /> return value
            may also occur if <c>key</c> has been explicitly mapped to <see langword="null" />. To check whether a mapping for the key exists
            at all, use the
            <see cref="M:yWorks.yFiles.Util.IMap.ContainsKey(System.Object)" />
            method instead.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.GetHashCode">
      <summary>Returns the hash code for this map instance.</summary>
      <returns>The hash code for this map instance.</returns>
      <remarks>Returns the hash code for this map instance.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.KeySet">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Util.ISet" />
            of all keys in this map.
            </summary>
      <returns>The set of keys in this instance.</returns>
      <remarks>
            The
            <see cref="T:yWorks.yFiles.Util.ISet" />
            of all keys in this map.
            <p>
            This is a live view on the map keys in the sense that
            changes in the map are automatically reflected in this collection and vice-versa.
            </p>
            <p>
            Note that modifications on the map instance while iterating over the set are not supported (i.e. the behavior is undefined)
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Put(System.Object,System.Object)">
      <summary>Maps <c>key</c> to <c>value</c>.</summary>
      <param name="key">The key that maps to <c>value</c>.</param>
      <param name="value">The value that is associated to <c>key</c>.</param>
      <returns>The previous value associated with <c>key</c>, or <see langword="null" /> if no previous mapping existed.</returns>
      <remarks>
            Maps <c>key</c> to <c>value</c>.
            An existing mapping for <c>key</c> will be replaced. Implementations may impose additional restrictions
            on the type or value of <c>key</c>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.PutAll(yWorks.yFiles.Util.IMap)">
      <summary>Inserts all mappings in <c>t</c> into this map.</summary>
      <param name="t">The map whose mappings should be copied.</param>
      <remarks>Inserts all mappings in <c>t</c> into this map.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Remove(System.Object)">
      <summary>Removes the mapping from <c>key</c> to its associated value.</summary>
      <param name="key">The key whose mapping should be removed.</param>
      <returns>The previous value associated with <c>key</c>, or <see langword="null" /> if no previous mapping existed.</returns>
      <remarks>
            Removes the mapping from <c>key</c> to its associated value.
            <c>key</c> need not be present as an actual key in this map, in which case the map is not modified.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Size">
      <summary>Returns the number of entries in this map.</summary>
      <returns>The number of entries in this map.</returns>
      <remarks>Returns the number of entries in this map.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMap.Values">
      <summary>
            The
            <see cref="T:yWorks.yFiles.Util.ICollection" />
            of all values in this map.
            </summary>
      <returns>The collection of values in this instance.</returns>
      <remarks>
            The
            <see cref="T:yWorks.yFiles.Util.ICollection" />
            of all values in this map.
            <p>
            This is a live view on the map values in the sense that
            changes in the map are automatically reflected in this collection and vice-versa. This collection may contain duplicate entries
            if a value is associated with more than one key.
            </p>
            <p>
            Note that modifications on the map instance while iterating over the set are not supported (i.e. the behavior is undefined)
            </p>
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.IMapEntry">
      <summary>
            The representation of a key-value mapping in a
            <see cref="T:yWorks.yFiles.Util.IMap" />
            .
            </summary>
      <remarks>
            The representation of a key-value mapping in a
            <see cref="T:yWorks.yFiles.Util.IMap" />
            .
            Instances of this interface are returned in the
            <see cref="M:yWorks.yFiles.Util.IMap.EntrySet" />
            set. These instances may be invalidated
            if the underlying map is modified. Therefore, it is only safe to use these objects during an iteration that does not modify the
            map.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMapEntry.Equals(System.Object)">
      <summary>Checks for equality between this object and <c>o</c>.</summary>
      <param name="o">The object that is checked for equality.</param>
      <returns>
        <see langword="true" /> iff <c>o</c> and this instance are equal.</returns>
      <remarks>Checks for equality between this object and <c>o</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMapEntry.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>The hash code for this instance.</returns>
      <remarks>Returns the hash code for this instance.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.IMapEntry.Key">
      <summary>The key stored in this entry.</summary>
      <remarks>
            Returns the key stored in this entry.
            If the mapping has been removed on the underlying map instance, the behavior is undefined.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.IMapEntry.SetValue(System.Object)">
      <summary>Changes the value associated with this entry.</summary>
      <param name="value">The value that should be associated to the <c>key</c> of this entry.</param>
      <returns>The value previously associated to the <c>key</c> of this entry.</returns>
      <remarks>
            Changes the value associated with this entry.
            This is a live operation on the underlying map. If the mapping for the <c>key</c> has been removed
            on the underlying map instance, the behavior is undefined.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.IMapEntry.Value">
      <summary>The value stored in this entry.</summary>
      <remarks>
            Returns the value stored in this entry.
            If the mapping has been removed on the underlying map instance, the behavior is undefined.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.ISet">
      <summary>An interface for collections that contain no duplicates.</summary>
      <remarks>
            An interface for collections that contain no duplicates.
            <p>
            For each pair of elements <c>e1</c> and <c>e2</c> in a set, <c>e1.equals(e2)</c> is always <see langword="false" />.
            In addition, the
            <see cref="M:yWorks.yFiles.Util.ISet.Add(System.Object)" />
            and
            <see cref="M:yWorks.yFiles.Util.ISet.AddAll(yWorks.yFiles.Util.ICollection)" />
            methods do not insert objects that are already
            present in the set (again, according to the <c>equals</c> method of the entries).
            </p>
            <p>
            This interface does not impose restrictions on the <i>order</i> or the type of the entries.
            Concrete implementations may thus allow or disallow <see langword="null" /> entries or impose a specific order of the entries.
            </p>
            <p>
            Note that the behavior is undefined if you use mutable objects as entries and change them in a way that affects equality comparisons
            with other entries as long as the object is stored in the set.
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.Add(System.Object)">
      <summary>Adds the given object to this instance if not already present.</summary>
      <param name="o">The object to insert.</param>
      <returns>
        <see langword="true" /> iff the object was not already present in the map and could be inserted.</returns>
      <remarks>
            Adds the given object to this instance if not already present.
            If <c>o</c> is <c>equal</c> to an existing entry in the set, the object is <i>not</i> inserted and this method
            will return <see langword="false" />.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ISet.AddAll(yWorks.yFiles.Util.ICollection)">
      <summary>Adds all elements in <c>c</c> to this instance if not already present.</summary>
      <param name="c">The collection whose entries should be inserted.</param>
      <returns>
        <see langword="true" /> iff this set was changed as a result of this operation.</returns>
      <remarks>
            Adds all elements in <c>c</c> to this instance if not already present.
            If an element in <c>c</c> is <c>equal</c> to an existing entry in the set, this element is <i>not</i> inserted.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.ISortedMap">
      <summary>A map that guarantees an order on its entries.</summary>
      <remarks>
            A map that guarantees an order on its entries.
            <p>
            Implementations of this interface will guarantee that each of the collection views (
            <see cref="M:yWorks.yFiles.Util.IMap.EntrySet" />
            ,
            <see cref="M:yWorks.yFiles.Util.IMap.KeySet" />
            ,
            <see cref="M:yWorks.yFiles.Util.IMap.Values" />
            will be ordered in ascending order of the keys. The ordering of the keys can either be the intrinsic ordering if the
            keys implement the
            <see cref="T:System.IComparable" />
            interface, or it can be explicitly given by specifying a
            <see cref="T:System.Collections.IComparer" />
            instance
            to the map. In either case, the ordering must be total, i.e. all keys must be mutually comparable, either by their
            own
            <see cref="M:System.IComparable.CompareTo(System.Object)" />
            methods, or through
            <see cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)" />
            .
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ISortedMap.Comparator">
      <summary>
            Returns the optional
            <see cref="T:System.Collections.IComparer" />
            used to specify the order of the keys.
            </summary>
      <returns>
            Returns the
            <see cref="T:System.Collections.IComparer" />
            used to specify the order of the keys, or <see langword="null" /> if the natural order
            of the keys should be used.
            </returns>
      <remarks>
            Returns the optional
            <see cref="T:System.Collections.IComparer" />
            used to specify the order of the keys.
            If <see langword="null" />, the natural order of the keys is used. In that case, all key objects must implement the
            <see cref="T:System.IComparable" />
            interface.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ISortedMap.FirstKey">
      <summary>
            The first key in the
            <see cref="M:yWorks.yFiles.Util.IMap.KeySet" />
            collection.
            </summary>
      <returns>
            The first key in the
            <see cref="M:yWorks.yFiles.Util.IMap.KeySet" />
            collection.
            </returns>
      <remarks>
            The first key in the
            <see cref="M:yWorks.yFiles.Util.IMap.KeySet" />
            collection.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ISortedMap.LastKey">
      <summary>
            The last key in the
            <see cref="M:yWorks.yFiles.Util.IMap.KeySet" />
            collection.
            </summary>
      <returns>
            The last key in the
            <see cref="M:yWorks.yFiles.Util.IMap.KeySet" />
            collection.
            </returns>
      <remarks>
            The last key in the
            <see cref="M:yWorks.yFiles.Util.IMap.KeySet" />
            collection.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.ISortedSet">
      <summary>A set that guarantees an order on its entries.</summary>
      <remarks>
            A set that guarantees an order on its entries.
            <p>
            Implementations of this interface will guarantee that the entries will be ordered in ascending order. The ordering
            can either be the intrinsic ordering if the entries implement the
            <see cref="T:System.IComparable" />
            interface, or it can be
            explicitly given by specifying a
            <see cref="T:System.Collections.IComparer" />
            instance
            to the set. In either case, the ordering must be total, i.e. all entries must be mutually comparable, either by their
            own
            <see cref="M:System.IComparable.CompareTo(System.Object)" />
            methods, or through
            <see cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)" />
            .
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ISortedSet.Comparator">
      <summary>
            Returns the optional
            <see cref="T:System.Collections.IComparer" />
            used to specify the order of the entries.
            </summary>
      <returns>
            Returns the
            <see cref="T:System.Collections.IComparer" />
            used to specify the order of the entries, or <see langword="null" /> if the natural order
            of the entries should be used.
            </returns>
      <remarks>
            Returns the optional
            <see cref="T:System.Collections.IComparer" />
            used to specify the order of the entries.
            If <see langword="null" />, the natural order of the entries is used. In that case, all entries must implement the
            <see cref="T:System.IComparable" />
            interface.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ISortedSet.First">
      <summary>The first entry in the set.</summary>
      <returns>The first entry in the set.</returns>
      <remarks>The first entry in the set.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.ISortedSet.Last">
      <summary>The last entry in the set.</summary>
      <returns>The last entry in the set.</returns>
      <remarks>The last entry in the set.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.MapFactory">
      <summary>
            A factory class that creates instances of the classes implementing
            <see cref="T:yWorks.yFiles.Util.IMap" />
            .
            </summary>
      <remarks>
            A factory class that creates instances of the classes implementing
            <see cref="T:yWorks.yFiles.Util.IMap" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.MapFactory.CreateHashMap">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.HashMap" />
            .
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.HashMap" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.HashMap" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.MapFactory.CreateHashMap(yWorks.yFiles.Util.IMap)">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.HashMap" />
            with the contents of the specified
            <see cref="T:yWorks.yFiles.Util.IMap" />
            .
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.HashMap" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.HashMap" />
            with the contents of the specified
            <see cref="T:yWorks.yFiles.Util.IMap" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.MapFactory.CreateTreeMap">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.TreeMap" />
            .
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.TreeMap" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.TreeMap" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.MapFactory.CreateTreeMap(System.Collections.IComparer)">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.TreeMap" />
            with the specified
            <see cref="T:System.Collections.IComparer" />
            .
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.TreeMap" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.TreeMap" />
            with the specified
            <see cref="T:System.Collections.IComparer" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.MapFactory.CreateTreeMap(yWorks.yFiles.Util.IMap)">
      <summary>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.TreeMap" />
            with the contents of the specified
            <see cref="T:yWorks.yFiles.Util.IMap" />
            .
            </summary>
      <returns>
            a new instance of
            <see cref="T:yWorks.yFiles.Util.TreeMap" />
            .
            </returns>
      <remarks>
            Creates a new
            <see cref="T:yWorks.yFiles.Util.TreeMap" />
            with the contents of the specified
            <see cref="T:yWorks.yFiles.Util.IMap" />
            .
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.Random">
      <summary>This class can be used to generate a sequence of pseudo random numbers.</summary>
      <remarks>
            This class can be used to generate a sequence of pseudo random numbers.
            <p>
            This class can be used with a specified seed value, either at initialization (
            <see cref="M:yWorks.yFiles.Util.Random.#ctor(System.Int64)" />
            ) or on the fly (
            <see cref="P:yWorks.yFiles.Util.Random.Seed" />
            .
            Two instances with the same seed will return the same sequence of random numbers.
            </p>
            <p>
            This implementation uses the the algorithms as specified from <c>java.util.Random</c> from the Java Runtime:
            <i>Java implementations must use all the algorithms shown here for the class Random, for the sake of absolute portability of Java code.</i>
            </p>
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.#ctor">
      <summary>Creates a new instance.</summary>
      <remarks>
            Creates a new instance.
            The seed is initialized from the current system time.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.#ctor(System.Int64)">
      <summary>Creates a new instance with the given seed value</summary>
      <param name="seed">The seed value for the random number sequence.</param>
      <remarks>Creates a new instance with the given seed value</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.Next(System.Int32)">
      <summary>Generate the next pseudo random number</summary>
      <param name="bits">the bits from which the next pseudo random number is generated</param>
      <returns>the next random number.</returns>
      <remarks>Generate the next pseudo random number</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextBoolean">
      <summary>Generate the next pseudo random number as a <c>boolean</c> value.</summary>
      <returns>the next <c>boolean</c> pseudo random number (either  <see langword="true" /> or <see langword="false" />).</returns>
      <remarks>
            Generate the next pseudo random number as a <c>boolean</c> value.
            Repeated calls to this method will return the values <see langword="true" /> and <see langword="false" /> with approximately the same probability.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextDouble">
      <summary>Generate the next pseudo random number as a <c>double</c> value in the interval 0.0 (inclusive) and 1.0 (exclusive)</summary>
      <returns>the next <c>double</c> pseudo random number in the range from 0.0 to 1.0</returns>
      <remarks>Generate the next pseudo random number as a <c>double</c> value in the interval 0.0 (inclusive) and 1.0 (exclusive)</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextFloat">
      <summary>Generate the next pseudo random number as a <c>float</c> value in the interval 0.0 (inclusive) and 1.0 (exclusive)</summary>
      <returns>the next <c>float</c> pseudo random number in the range from 0.0 to 1.0</returns>
      <remarks>Generate the next pseudo random number as a <c>float</c> value in the interval 0.0 (inclusive) and 1.0 (exclusive)</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextInt">
      <summary>Generate the next pseudo random number</summary>
      <returns>the next random number.</returns>
      <remarks>Generate the next pseudo random number</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Random.NextInt(System.Int32)">
      <summary>Generate the next pseudo random number in the range from 0 (inclusive) to <c>n</c> (exclusive)</summary>
      <param name="n">the upper bound of the random number range.</param>
      <returns>the next random number in the specified range.</returns>
      <remarks>Generate the next pseudo random number in the range from 0 (inclusive) to <c>n</c> (exclusive)</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Random.Seed">
      <summary>The seed of this instance.</summary>
      <remarks>
            Sets the seed of this instance.
            After setting this value, subsequent to generate random numbers will create the same sequence as when this instance
            had just been initialized with <c>seed</c>.
            </remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.Geom.Insets">
      <summary>Double-precision immutable insets representation.</summary>
      <remarks>Double-precision immutable insets representation.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>Creates a new instance with the given values</summary>
      <param name="top">The new top inset value</param>
      <param name="left">The new left inset value</param>
      <param name="bottom">The new bottom inset value</param>
      <param name="right">The new right inset value</param>
      <remarks>Creates a new instance with the given values</remarks>
    </member>
    <member name="F:yWorks.yFiles.Util.Geom.Insets.bottom">
      <summary>The inset from the bottom.</summary>
      <remarks>The inset from the bottom.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.Clone">
      <summary>Creates a new object that is a copy of the current instance.</summary>
      <returns>A new object that is a copy of this instance.</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.Equals(System.Object)">
      <summary>Returns whether this insets object and <c>o</c> are equal.</summary>
      <param name="o">The object to test for equality</param>
      <returns>
        <see langword="true" /> if both objects are equal.</returns>
      <remarks>
            Returns whether this insets object and <c>o</c> are equal.
            Two insets are considered equal if the have the same values for each side.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="F:yWorks.yFiles.Util.Geom.Insets.left">
      <summary>The inset from the left.</summary>
      <remarks>The inset from the left.</remarks>
    </member>
    <member name="F:yWorks.yFiles.Util.Geom.Insets.right">
      <summary>The inset from the right.</summary>
      <remarks>The inset from the right.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.Set(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Sets the values of this instance to the given ones.
            </summary>
      <param name="top">The new top inset.</param>
      <param name="left">The new left inset.</param>
      <param name="bottom">The new bottom inset.</param>
      <param name="right">The new right inset.</param>
    </member>
    <member name="F:yWorks.yFiles.Util.Geom.Insets.top">
      <summary>The inset from the top.</summary>
      <remarks>The inset from the top.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Insets.ToString">
      <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
      <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="T:yWorks.yFiles.Util.Geom.Point2D">
      <summary>
            Represents a two-dimensional point located at <code>(x,
            y)</code>.
            </summary>
      <remarks>
            Represents a two-dimensional point located at <code>(x,
            y)</code>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.#ctor">
      <summary>Initializes a new instance of the <see cref="T:yWorks.yFiles.Util.Geom.Point2D" /> class</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Clone">
      <summary>Creates a new instance of this class that has the same values as this objects.</summary>
      <returns>a new instance of this class that has the same values as this objects.</returns>
      <remarks>Creates a new instance of this class that has the same values as this objects.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Distance(System.Double,System.Double)">
      <summary>Calculates the distance between this points and another one, given as its coordinates.</summary>
      <param name="px">The x coordinate of the second point.</param>
      <param name="py">The y coordinate of the second point.</param>
      <returns>the distance between this points and another one, given as its coordinates.</returns>
      <remarks>Calculates the distance between this points and another one, given as its coordinates.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Distance(System.Double,System.Double,System.Double,System.Double)">
      <summary>Calculates the distance between two points, given as their coordinates.</summary>
      <param name="x1">The x coordinate of the first point.</param>
      <param name="y1">The y coordinate of the first point.</param>
      <param name="x2">The x coordinate of the second point.</param>
      <param name="y2">The y coordinate of the second point.</param>
      <returns>the distance between two points, given as their coordinates.</returns>
      <remarks>Calculates the distance between two points, given as their coordinates.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Distance(yWorks.yFiles.Util.Geom.Point2D)">
      <summary>Calculates the distance between this points and another one.</summary>
      <param name="p">The second point.</param>
      <returns>the distance between this points and another one.</returns>
      <remarks>Calculates the distance between this points and another one.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.DistanceSq(System.Double,System.Double)">
      <summary>Calculates the squared distance between this points and another one, given as its coordinates.</summary>
      <param name="px">The x coordinate of the second point.</param>
      <param name="py">The y coordinate of the second point.</param>
      <returns>the squared distance between this points and another one, given as its coordinates.</returns>
      <remarks>Calculates the squared distance between this points and another one, given as its coordinates.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.DistanceSq(System.Double,System.Double,System.Double,System.Double)">
      <summary>Calculates the squared distance between two points, given as their coordinates.</summary>
      <param name="x1">The x coordinate of the first point.</param>
      <param name="y1">The y coordinate of the first point.</param>
      <param name="x2">The x coordinate of the second point.</param>
      <param name="y2">The y coordinate of the second point.</param>
      <returns>the squared distance between two points, given as their coordinates.</returns>
      <remarks>Calculates the squared distance between two points, given as their coordinates.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.DistanceSq(yWorks.yFiles.Util.Geom.Point2D)">
      <summary>Calculates the squared distance between this points and another one.</summary>
      <param name="p">The second point.</param>
      <returns>the squared distance between this points and another one.</returns>
      <remarks>Calculates the squared distance between this points and another one.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Equals(System.Object)">
      <summary>Returns whether this point and <c>obj</c> are equal.</summary>
      <param name="obj">The object to test for equality</param>
      <returns>
        <see langword="true" /> if both objects are equal.</returns>
      <remarks>
            Returns whether this point and <c>obj</c> are equal.
            Two points are considered equal if the have the same location.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Point2D.Location">
      <summary>The location of this point to the same values as for the given point.</summary>
      <remarks>Sets the location of this point to the same values as for the given point.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.SetLocation(System.Double,System.Double)">
      <summary>Sets the location of this point to the given coordinates.</summary>
      <param name="x">the new x coordinate</param>
      <param name="y">the new y coordinate</param>
      <remarks>Sets the location of this point to the given coordinates.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.ToString">
      <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
      <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Point2D.X">
      <summary>The x coordinate of this point.</summary>
      <remarks>Returns the x coordinate of this point.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Point2D.Y">
      <summary>The y coordinate of this point.</summary>
      <remarks>Returns the y coordinate of this point.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.Geom.Point2D.Double">
      <summary>
            Concrete implementation of
            <see cref="T:yWorks.yFiles.Util.Geom.Point2D" />
            .
            </summary>
      <remarks>
            Concrete implementation of
            <see cref="T:yWorks.yFiles.Util.Geom.Point2D" />
            .
            </remarks>
      <remarks>
            Concrete implementation of
            <see cref="T:yWorks.yFiles.Util.Geom.Point2D" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Double.#ctor">
      <summary>Creates a new instance that is located at <c>(0,0)</c></summary>
      <remarks>Creates a new instance that is located at <c>(0,0)</c></remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Double.#ctor(System.Double,System.Double)">
      <summary>Creates a new instance at the given location.</summary>
      <param name="x">The x coordinate of the new point</param>
      <param name="y">The x coordinate of the new point</param>
      <remarks>Creates a new instance at the given location.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Double.Clone">
      <summary>Creates a new instance of this class that has the same values as this objects.</summary>
      <returns>a new instance of this class that has the same values as this objects.</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Point2D.Double.SetLocation(System.Double,System.Double)">
      <summary>Sets the location of this point to the given coordinates.</summary>
      <param name="x">the new x coordinate</param>
      <param name="y">the new y coordinate</param>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Point2D.Double.X">
      <summary>The x coordinate of this point.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Point2D.Double.Y">
      <summary>The y coordinate of this point.</summary>
    </member>
    <member name="T:yWorks.yFiles.Util.Geom.Rectangle">
      <summary>
            Represents a two-dimensional rectangle of size <c>(width x height)</c>, located at the point <code>(x,
            y)</code>.
            </summary>
      <remarks>
            Represents a two-dimensional rectangle of size <c>(width x height)</c>, located at the point <code>(x,
            y)</code>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.#ctor">
      <summary>Creates a new empty instance located at the coordinate system origin.</summary>
      <remarks>Creates a new empty instance located at the coordinate system origin.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.#ctor(System.Int32,System.Int32)">
      <summary>Creates a new instance located at the coordinate system origin with the given dimensions.</summary>
      <param name="height">the height of the new rectangle</param>
      <param name="width">the width of the new rectangle</param>
      <remarks>Creates a new instance located at the coordinate system origin with the given dimensions.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Creates a new instance with the given location and dimensions.</summary>
      <param name="x">the x coordinate of the upper left corner of the new rectangle</param>
      <param name="y">the y coordinate of the upper left corner of the new rectangle</param>
      <param name="height">the height of the new rectangle</param>
      <param name="width">the width of the new rectangle</param>
      <remarks>Creates a new instance with the given location and dimensions.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.#ctor(yWorks.yFiles.Util.Geom.Rectangle)">
      <summary>Creates a new instance with the same values as in the given rectangle.</summary>
      <param name="r">The rectangle whose values are used for the initialization</param>
      <remarks>Creates a new instance with the same values as in the given rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Add(System.Int32,System.Int32)">
      <summary>Adds a point, specified by its coordinates, to this rectangle.</summary>
      <param name="px">the x coordinate of the point to add</param>
      <param name="py">the y coordinate of the point to add</param>
      <remarks>
            Adds a point, specified by its coordinates, to this rectangle.
            The rectangle will be grown if necessary. Note that for points that would lie on the right or bottom border of the rectangle,
            <see cref="M:yWorks.yFiles.Util.Geom.Rectangle.Contains(System.Int32,System.Int32)" />
            will still return <see langword="false" /> for the added point.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Add(yWorks.yFiles.Util.Geom.Rectangle)">
      <summary>Adds a rectangle to this rectangle.</summary>
      <param name="r">the rectangle to add</param>
      <remarks>
            Adds a rectangle to this rectangle.
            The rectangle will be grown to the union of both rectangles
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Bounds">
      <summary>
            The bounds of this rectangle as a new
            <see cref="T:yWorks.yFiles.Util.Geom.Rectangle" />
            instance.
            </summary>
      <remarks>
            Returns the bounds of this rectangle as a new
            <see cref="T:yWorks.yFiles.Util.Geom.Rectangle" />
            instance.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Bounds2D">
      <summary>
            The bounds of this rectangle as a new
            <see cref="T:yWorks.yFiles.Util.Geom.Rectangle2D" />
            instance.
            </summary>
      <remarks>
            Returns the bounds of this rectangle as a new
            <see cref="T:yWorks.yFiles.Util.Geom.Rectangle2D" />
            instance.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Clone">
      <summary>Creates a new instance of this class that has the same values as this objects.</summary>
      <returns>a new instance of this class that has the same values as this objects.</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Contains(System.Int32,System.Int32)">
      <summary>Checks if the point specified by the given coordinates is contained in this rectangle.</summary>
      <param name="px">the x-coordinate of the point.</param>
      <param name="py">the y-coordinate of the point.</param>
      <returns>
        <see langword="true" /> if the specified point is contained in this rectangle; <see langword="false" /> otherwise.</returns>
      <remarks>Checks if the point specified by the given coordinates is contained in this rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Contains(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Checks whether this rectangle completely contains the second specified rectangle.</summary>
      <param name="rx">the x coordinate of the second rectangle.</param>
      <param name="ry">the y coordinate of the second rectangle.</param>
      <param name="rw">the width coordinate of the second rectangle.</param>
      <param name="rh">the height coordinate of the second rectangle.</param>
      <returns>
        <see langword="true" /> if this rectangle contains the second one</returns>
      <remarks>Checks whether this rectangle completely contains the second specified rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Contains(yWorks.yFiles.Util.Geom.Rectangle)">
      <summary>Checks whether this rectangle completely contains the second specified rectangle.</summary>
      <param name="r">the rectangle to check for containment</param>
      <returns>
        <see langword="true" /> if this rectangle contains the second one</returns>
      <remarks>Checks whether this rectangle completely contains the second specified rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.CreateIntersection(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>Calculates the intersection of this rectangle with the given rectangle and returns the result as new rectangle.</summary>
      <param name="r">a rectangle to intersect with this rectangle.</param>
      <returns>a new rectangle that represents the calculated intersection.</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.CreateUnion(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>Calculates the union of this rectangle with the given rectangle and returns the result as new rectangle.</summary>
      <param name="r">a rectangle to union with this rectangle.</param>
      <returns>a new rectangle that represents the calculated union.</returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Empty">
      <summary>Specifies whether this instance is empty, i.e.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Equals(System.Object)">
      <summary>Returns whether this rectangle and <c>obj</c> are equal.</summary>
      <param name="obj">The object to test for equality</param>
      <returns>
        <see langword="true" /> if both objects are equal.</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Grow(System.Int32,System.Int32)">
      <summary>Enlarge this instance by the given amounts.</summary>
      <param name="dx">the enlargement in horizontal direction.</param>
      <param name="dy">the enlargement in vertical direction.</param>
      <remarks>
            Enlarge this instance by the given amounts.
            The rectangle will be resized by <c>dx</c> units on both the left and right side and <c>dy</c> units on both
            the top and bottom side. For negative values of <c>dx</c> or <c>dy</c>, the rectangle will shrink accordingly.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Height">
      <summary>The height of this rectangle.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Intersection(yWorks.yFiles.Util.Geom.Rectangle)">
      <summary>
            Calculates the intersection of this rectangle with the given rectangle and returns the result as new
            <see cref="T:yWorks.yFiles.Util.Geom.Rectangle" />
            .
            </summary>
      <param name="r">a rectangle to intersect with this rectangle.</param>
      <returns>a new rectangle that represents the calculated intersection.</returns>
      <remarks>
            Calculates the intersection of this rectangle with the given rectangle and returns the result as new
            <see cref="T:yWorks.yFiles.Util.Geom.Rectangle" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Intersects(yWorks.yFiles.Util.Geom.Rectangle)">
      <summary>Checks whether this rectangle and the second specified rectangle intersect.</summary>
      <param name="r">the second rectangle.</param>
      <returns>
        <see langword="true" /> if both rectangles intersect</returns>
      <remarks>Checks whether this rectangle and the second specified rectangle intersect.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Sets the location and size of this rectangle to the specified values.</summary>
      <param name="x">the new x-coordinate of the upper left corner.</param>
      <param name="y">the new y-coordinate of the upper left corner.</param>
      <param name="width">the new width.</param>
      <param name="height">the new height.</param>
      <remarks>Sets the location and size of this rectangle to the specified values.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.SetBounds(yWorks.yFiles.Util.Geom.Rectangle)">
      <summary>Sets the location and size of this rectangle to the same values as in the given rectangle.</summary>
      <param name="r">the rectangle where all values are taken from.</param>
      <remarks>Sets the location and size of this rectangle to the same values as in the given rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.SetLocation(System.Int32,System.Int32)">
      <summary>Sets the upper left corner of this rectangle to the given values</summary>
      <param name="x">the x coordinate of the new location</param>
      <param name="y">the y coordinate of the new location</param>
      <remarks>Sets the upper left corner of this rectangle to the given values</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.SetRect(System.Double,System.Double,System.Double,System.Double)">
      <summary>Sets the location and size of this rectangle to the specified values.</summary>
      <param name="x">the new x-coordinate of the upper left corner.</param>
      <param name="y">the new y-coordinate of the upper left corner.</param>
      <param name="width">the new width.</param>
      <param name="height">the new height.</param>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Translate(System.Int32,System.Int32)">
      <summary>Moves the rectangle by the given amount in x resp.</summary>
      <param name="mx">The movement in x direction</param>
      <param name="my">The movement in y direction</param>
      <remarks>Moves the rectangle by the given amount in x resp. y direction.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle.Union(yWorks.yFiles.Util.Geom.Rectangle)">
      <summary>
            Calculates the union of this rectangle with the given rectangle and returns the result as new
            <see cref="T:yWorks.yFiles.Util.Geom.Rectangle" />
            .
            </summary>
      <param name="r">a rectangle to union with this rectangle.</param>
      <returns>a new rectangle that represents the calculated union.</returns>
      <remarks>
            Calculates the union of this rectangle with the given rectangle and returns the result as new
            <see cref="T:yWorks.yFiles.Util.Geom.Rectangle" />
            .
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Width">
      <summary>The width of this rectangle.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.X">
      <summary>The x coordinate of the upper left corner.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle.Y">
      <summary>The y coordinate of the upper left corner.</summary>
    </member>
    <member name="T:yWorks.yFiles.Util.Geom.Rectangle2D">
      <summary>
            Represents a two-dimensional rectangle of size <c>(width x height)</c>, located at the point <code>(x,
            y)</code>.
            </summary>
      <remarks>
            Represents a two-dimensional rectangle of size <c>(width x height)</c>, located at the point <code>(x,
            y)</code>.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.#ctor">
      <summary>Cannot create instances of this abstract class.</summary>
      <remarks>Cannot create instances of this abstract class.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Add(System.Double,System.Double)">
      <summary>Adds a point, specified by its coordinates, to this rectangle.</summary>
      <param name="px">the x coordinate of the point to add</param>
      <param name="py">the y coordinate of the point to add</param>
      <remarks>
            Adds a point, specified by its coordinates, to this rectangle.
            The rectangle will be grown if necessary. Note that for points that would lie on the right or bottom border of the rectangle,
            <see cref="M:yWorks.yFiles.Util.Geom.Rectangle2D.Contains(System.Double,System.Double)" />
            will still return <see langword="false" /> for the added point.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Add(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>Adds a rectangle to this rectangle.</summary>
      <param name="r">the rectangle to add</param>
      <remarks>
            Adds a rectangle to this rectangle.
            The rectangle will be grown to the union of both rectangles
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.CenterX">
      <summary>The x coordinate of the center point of this rectangle.</summary>
      <remarks>Returns the x coordinate of the center point of this rectangle.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.CenterY">
      <summary>The y coordinate of the center point of this rectangle.</summary>
      <remarks>Returns the y coordinate of the center point of this rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Clone">
      <summary>Creates a new instance of this class that has the same values as this objects.</summary>
      <returns>a new instance of this class that has the same values as this objects.</returns>
      <remarks>Creates a new instance of this class that has the same values as this objects.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Contains(System.Double,System.Double)">
      <summary>Checks if the point specified by the given coordinates is contained in this rectangle.</summary>
      <param name="x">the x-coordinate of the point.</param>
      <param name="y">the y-coordinate of the point.</param>
      <returns>
        <see langword="true" /> if the specified point is contained in this rectangle; <see langword="false" /> otherwise.</returns>
      <remarks>Checks if the point specified by the given coordinates is contained in this rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Contains(System.Double,System.Double,System.Double,System.Double)">
      <summary>Checks whether this rectangle completely contains the second specified rectangle.</summary>
      <param name="x">the x coordinate of the second rectangle.</param>
      <param name="y">the y coordinate of the second rectangle.</param>
      <param name="width">the width coordinate of the second rectangle.</param>
      <param name="height">the height coordinate of the second rectangle.</param>
      <returns>
        <see langword="true" /> if this rectangle contains the second one</returns>
      <remarks>Checks whether this rectangle completely contains the second specified rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Contains(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>Checks whether this rectangle completely contains the second specified rectangle.</summary>
      <param name="rect">the rectangle to check for containment</param>
      <returns>
        <see langword="true" /> if this rectangle contains the second one</returns>
      <remarks>Checks whether this rectangle completely contains the second specified rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.CreateIntersection(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>Calculates the intersection of this rectangle with the given rectangle and returns the result as new rectangle.</summary>
      <param name="r">a rectangle to intersect with this rectangle.</param>
      <returns>a new rectangle that represents the calculated intersection.</returns>
      <remarks>Calculates the intersection of this rectangle with the given rectangle and returns the result as new rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.CreateUnion(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>Calculates the union of this rectangle with the given rectangle and returns the result as new rectangle.</summary>
      <param name="r">a rectangle to union with this rectangle.</param>
      <returns>a new rectangle that represents the calculated union.</returns>
      <remarks>Calculates the union of this rectangle with the given rectangle and returns the result as new rectangle.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Empty">
      <summary>Specifies whether this instance is empty, i.e.</summary>
      <remarks>Returns whether this instance is empty, i.e. covers no area.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Equals(System.Object)">
      <summary>Returns whether this rectangle and <c>obj</c> are equal.</summary>
      <param name="obj">The object to test for equality</param>
      <returns>
        <see langword="true" /> if both objects are equal.</returns>
      <remarks>
            Returns whether this rectangle and <c>obj</c> are equal.
            Two rectangles are considered equal if the have the same location and size.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Frame">
      <summary>The outer bounds of this rectangle in double coordinates.</summary>
      <remarks>
            Getter:<br />
            Returns the outer bounds of this rectangle in double coordinates.
            <para />
            Setter:<br />
            Sets the outer bounds of this rectangle based on the specified rectangle.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.GetHashCode">
      <summary>Serves as a hash function for a particular type. </summary>
      <returns>A hash code for the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Height">
      <summary>The height of this rectangle.</summary>
      <remarks>Returns the height of this rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Intersect(yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>
            Calculates the intersection of the first and second specified rectangle and sets the resulting location and size to
            the third rectangle.
            </summary>
      <param name="src1">the first rectangle to intersect.</param>
      <param name="src2">the second rectangle to intersect.</param>
      <param name="dst">the rectangle to which the result is set.</param>
      <remarks>
            Calculates the intersection of the first and second specified rectangle and sets the resulting location and size to
            the third rectangle.
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Intersects(System.Double,System.Double,System.Double,System.Double)">
      <summary>Checks whether this rectangle and the second specified rectangle intersect.</summary>
      <param name="x">the x coordinate of the second rectangle.</param>
      <param name="y">the y coordinate of the second rectangle.</param>
      <param name="width">the width coordinate of the second rectangle.</param>
      <param name="height">the height coordinate of the second rectangle.</param>
      <returns>
        <see langword="true" /> if both rectangles intersect</returns>
      <remarks>Checks whether this rectangle and the second specified rectangle intersect.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Intersects(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>Checks whether this rectangle and the second specified rectangle intersect.</summary>
      <param name="rect">the rectangle to check for intersection</param>
      <returns>
        <see langword="true" /> if both rectangles intersect</returns>
      <remarks>Checks whether this rectangle and the second specified rectangle intersect.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.IntersectsLine(System.Double,System.Double,System.Double,System.Double)">
      <summary>Checks if the line segment specified by the given coordinates intersects this rectangle.</summary>
      <param name="x1">the x-coordinate of the first end point of the line.</param>
      <param name="y1">the y-coordinate of the first end point of the line.</param>
      <param name="x2">the x-coordinate of the other end point of the line.</param>
      <param name="y2">the y-coordinate of the other end point of the line.</param>
      <returns>
        <see langword="true" /> if the specified line intersects this rectangle; <see langword="false" /> otherwise.</returns>
      <remarks>Checks if the line segment specified by the given coordinates intersects this rectangle.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.MaxX">
      <summary>The largest x coordinate of this rectangle.</summary>
      <remarks>Returns the largest x coordinate of this rectangle.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.MaxY">
      <summary>The largest y coordinate of this rectangle.</summary>
      <remarks>Returns the largest y coordinate of this rectangle.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.MinX">
      <summary>The smallest x coordinate of this rectangle.</summary>
      <remarks>Returns the smallest x coordinate of this rectangle.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.MinY">
      <summary>The smallest y coordinate of this rectangle.</summary>
      <remarks>Returns the smallest y coordinate of this rectangle.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Rect">
      <summary>The location and size of this rectangle to be similar to the specified rectangle.</summary>
      <remarks>Sets the location and size of this rectangle to be similar to the specified rectangle.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetFrame(System.Double,System.Double,System.Double,System.Double)">
      <summary>Sets the outer bounds of this rectangle based on the specified location and size.</summary>
      <param name="x">the new x-coordinate of the upper left corner.</param>
      <param name="y">the new y-coordinate of the upper left corner.</param>
      <param name="width">the new width.</param>
      <param name="height">the new height.</param>
      <remarks>Sets the outer bounds of this rectangle based on the specified location and size.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetFrameFromCenter(System.Double,System.Double,System.Double,System.Double)">
      <summary>Sets the outer bounds of this rectangle based on the specified new center and corner.</summary>
      <param name="centerX">the x-coordinate of the new center of this rectangle.</param>
      <param name="centerY">the y-coordinate of the new center of this rectangle.</param>
      <param name="cornerX">the x-coordinate of any new corner of this rectangle.</param>
      <param name="cornerY">the y-coordinate of any new corner of this rectangle.</param>
      <remarks>Sets the outer bounds of this rectangle based on the specified new center and corner.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetFrameFromCenter(yWorks.yFiles.Util.Geom.Point2D,yWorks.yFiles.Util.Geom.Point2D)">
      <summary>Sets the outer bounds of this rectangle based on the specified new center and corner.</summary>
      <param name="center">the new center of this rectangle.</param>
      <param name="corner">any new corner of this rectangle.</param>
      <remarks>Sets the outer bounds of this rectangle based on the specified new center and corner.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetFrameFromDiagonal(System.Double,System.Double,System.Double,System.Double)">
      <summary>Sets the outer bounds of this rectangle based on the end points of one of its diagonals.</summary>
      <param name="x1">the x-coordinate of the first end point of a diagonal.</param>
      <param name="y1">the y-coordinate of the first end point of a diagonal.</param>
      <param name="x2">the x-coordinate of the other end point of a diagonal.</param>
      <param name="y2">the y-coordinate of the other end point of a diagonal.</param>
      <remarks>Sets the outer bounds of this rectangle based on the end points of one of its diagonals.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetFrameFromDiagonal(yWorks.yFiles.Util.Geom.Point2D,yWorks.yFiles.Util.Geom.Point2D)">
      <summary>Sets the outer bounds of this rectangle based on the end points of one of its diagonals.</summary>
      <param name="p1">the first end point of a diagonal.</param>
      <param name="p2">the other end point of a diagonal.</param>
      <remarks>Sets the outer bounds of this rectangle based on the end points of one of its diagonals.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.SetRect(System.Double,System.Double,System.Double,System.Double)">
      <summary>Sets the location and size of this rectangle to the specified values.</summary>
      <param name="x">the new x-coordinate of the upper left corner.</param>
      <param name="y">the new y-coordinate of the upper left corner.</param>
      <param name="width">the new width.</param>
      <param name="height">the new height.</param>
      <remarks>Sets the location and size of this rectangle to the specified values.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.ToString">
      <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
      <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Union(yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D,yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>
            Calculates the union of the first and second specified rectangle and sets the resulting location and size to the
            third rectangle.
            </summary>
      <param name="src1">the first rectangle to union.</param>
      <param name="src2">the second rectangle to union.</param>
      <param name="dst">the rectangle to which the result is set.</param>
      <remarks>
            Calculates the union of the first and second specified rectangle and sets the resulting location and size to the
            third rectangle.
            </remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Width">
      <summary>The width of this rectangle.</summary>
      <remarks>Returns the width of this rectangle.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.X">
      <summary>The x coordinate of the upper left corner.</summary>
      <remarks>Returns the x coordinate of the upper left corner.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Y">
      <summary>The y coordinate of the upper left corner.</summary>
      <remarks>Returns the y coordinate of the upper left corner.</remarks>
    </member>
    <member name="T:yWorks.yFiles.Util.Geom.Rectangle2D.Double">
      <summary>
            Concrete implementation of
            <see cref="T:yWorks.yFiles.Util.Geom.Rectangle2D" />
            .
            </summary>
      <remarks>
            Concrete implementation of
            <see cref="T:yWorks.yFiles.Util.Geom.Rectangle2D" />
            .
            </remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.#ctor">
      <summary>Creates a new rectangle of size <c>(0 x 0)</c> at the location <c>(0, 0)</c>.</summary>
      <remarks>Creates a new rectangle of size <c>(0 x 0)</c> at the location <c>(0, 0)</c>.</remarks>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>Creates a new rectangle of the specified size at the specified location.</summary>
      <param name="x">the x-coordinate of the upper left corner of the created rectangle.</param>
      <param name="y">the y-coordinate of the upper left corner of the created rectangle.</param>
      <param name="width">the width of the created rectangle.</param>
      <param name="height">the height of the created rectangle.</param>
      <remarks>Creates a new rectangle of the specified size at the specified location.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Bounds2D">
      <summary>The bounds of this instance in double precision.</summary>
      <remarks>Returns the bounds of this instance in double precision.</remarks>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.CenterX">
      <summary>The x coordinate of the center point of this rectangle.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.CenterY">
      <summary>The y coordinate of the center point of this rectangle.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Clone">
      <summary>Creates a new instance of this class that has the same values as this objects.</summary>
      <returns>a new instance of this class that has the same values as this objects.</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.CreateIntersection(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>Calculates the intersection of this rectangle with the given rectangle and returns the result as new rectangle.</summary>
      <param name="r">a rectangle to intersect with this rectangle.</param>
      <returns>a new rectangle that represents the calculated intersection.</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.CreateUnion(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>Calculates the union of this rectangle with the given rectangle and returns the result as new rectangle.</summary>
      <param name="r">a rectangle to union with this rectangle.</param>
      <returns>a new rectangle that represents the calculated union.</returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Empty">
      <summary>Specifies whether this instance is empty, i.e.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Equals(System.Object)">
      <summary>Returns whether this rectangle and <c>obj</c> are equal.</summary>
      <param name="obj">The object to test for equality</param>
      <returns>
        <see langword="true" /> if both objects are equal.</returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Frame">
      <summary>The outer bounds of this rectangle in double coordinates.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Height">
      <summary>The height of this rectangle.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Intersects(System.Double,System.Double,System.Double,System.Double)">
      <summary>Checks whether this rectangle and the second specified rectangle intersect.</summary>
      <param name="x">the x coordinate of the second rectangle.</param>
      <param name="y">the y coordinate of the second rectangle.</param>
      <param name="width">the width coordinate of the second rectangle.</param>
      <param name="height">the height coordinate of the second rectangle.</param>
      <returns>
        <see langword="true" /> if both rectangles intersect</returns>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Intersects(yWorks.yFiles.Util.Geom.Rectangle2D)">
      <summary>Checks whether this rectangle and the second specified rectangle intersect.</summary>
      <param name="rect">the rectangle to check for intersection</param>
      <returns>
        <see langword="true" /> if both rectangles intersect</returns>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.MaxX">
      <summary>The largest x coordinate of this rectangle.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.MaxY">
      <summary>The largest y coordinate of this rectangle.</summary>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.SetFrame(System.Double,System.Double,System.Double,System.Double)">
      <summary>Sets the outer bounds of this rectangle based on the specified location and size.</summary>
      <param name="x">the new x-coordinate of the upper left corner.</param>
      <param name="y">the new y-coordinate of the upper left corner.</param>
      <param name="width">the new width.</param>
      <param name="height">the new height.</param>
    </member>
    <member name="M:yWorks.yFiles.Util.Geom.Rectangle2D.Double.SetRect(System.Double,System.Double,System.Double,System.Double)">
      <summary>Sets the location and size of this rectangle to the specified values.</summary>
      <param name="x">the new x-coordinate of the upper left corner.</param>
      <param name="y">the new y-coordinate of the upper left corner.</param>
      <param name="width">the new width.</param>
      <param name="height">the new height.</param>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Width">
      <summary>The width of this rectangle.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.X">
      <summary>The x coordinate of the upper left corner.</summary>
    </member>
    <member name="P:yWorks.yFiles.Util.Geom.Rectangle2D.Double.Y">
      <summary>The y coordinate of the upper left corner.</summary>
    </member>
  </members>
</doc>